{"meta":{"title":"秋季的blog","subtitle":"everyday","description":"","author":"他维忠","url":"http://peapod.top","root":"/"},"pages":[{"title":"所有分类","date":"2022-09-08T11:04:02.000Z","updated":"2022-09-08T11:13:14.433Z","comments":true,"path":"categories/index.html","permalink":"http://peapod.top/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2022-09-08T11:03:19.000Z","updated":"2022-09-08T11:13:17.022Z","comments":true,"path":"about/index.html","permalink":"http://peapod.top/about/index.html","excerpt":"","text":"人的一生"},{"title":"examples","date":"2022-09-08T11:08:04.000Z","updated":"2022-09-08T11:08:04.439Z","comments":true,"path":"examples/index.html","permalink":"http://peapod.top/examples/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2022-09-08T11:04:53.000Z","updated":"2022-09-08T11:28:26.245Z","comments":true,"path":"friends/index.html","permalink":"http://peapod.top/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"mylist","date":"2022-09-08T11:04:41.000Z","updated":"2022-09-08T11:14:29.641Z","comments":true,"path":"mylist/index.html","permalink":"http://peapod.top/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2022-09-08T11:04:28.000Z","updated":"2022-09-08T11:13:12.753Z","comments":true,"path":"tags/index.html","permalink":"http://peapod.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hyperledger Fabric 私有数据","slug":"Hyperledger-Fabric-私有数据","date":"2022-09-23T09:19:56.000Z","updated":"2022-09-24T02:25:48.347Z","comments":true,"path":"2022/09/23/Hyperledger-Fabric-私有数据/","link":"","permalink":"http://peapod.top/2022/09/23/Hyperledger-Fabric-%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE/","excerpt":"","text":"私有数据Fabric 提供了创建私有数据集合的功能，它允许在通道上定义的组织子集能够背书、提交或查询私有数据，而无需创建单独的通道。 私有数据集合集合是两个元素的组合: 实际的私有数据，通过 Gossip 协议点对点地发送给授权可以看到它的组织。 该数据的 hash 值，该 hash 值被背书、排序之后写入通道上每个节点的账本。 下面的图表说明了被授权和未被授权拥有私有数据的节点的账本内容。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://peapod.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"Hyperledger Fabric","slug":"Hyperledger-Fabric","permalink":"http://peapod.top/tags/Hyperledger-Fabric/"}],"author":"taweizhong"},{"title":"Hyperledger Fabric 排序服务","slug":"Hyperledger-Fabric-排序服务","date":"2022-09-23T09:19:46.000Z","updated":"2022-09-24T02:25:08.931Z","comments":true,"path":"2022/09/23/Hyperledger-Fabric-排序服务/","link":"","permalink":"http://peapod.top/2022/09/23/Hyperledger-Fabric-%E6%8E%92%E5%BA%8F%E6%9C%8D%E5%8A%A1/","excerpt":"","text":"排序服务排序排序节点使交易有序，并与其他排序节点一起形成一个排序服务。 本不会像其他分布式的以及无需许可的区块链中那样产生分叉。 排序节点还将链码执行的背书（发生在节点）与排序分离。 排序节点和通道配置排序节点还维护着允许创建通道的组织列表。 列表本身保存在“排序节点系统通道”（也称为“排序系统通道”）的配置中。 排序节点还对通道执行基本访问控制，限制谁可以读写数据，以及谁可以配置数据。 谁有权修改通道中的配置元素取决于相关管理员在创建联盟或通道时设置的策略。 排序节点和身份节点、应用程序、管理员和排序节点，都从它们的数字证书和成员服务提供者（MSP）定义中获取它们的组织身份。 与 Peer 节点一样，排序节点属于组织。也应该像 Peer 节点一样为每个组织使用单独的证书授权中心（CA）。 排序节点与交易流程提案客户端应用程序将交易提案发送给一组节点 节点将调用智能合约来生成一个账本更新提案，然后背书该结果。 背书节点将向客户端应用程序返回一个提案响应。 打包应用程序客户端把包含已背书交易提案响应的交易提交到排序服务节点。 排序服务创建交易区块，这些交易区块最终将分发给通道上的所有 Peer 节点 排序节点的第一个角色是打包提案的账本更新。 一个区块中交易的顺序不一定与排序服务接收的顺序相同，因为可能有多个排序服务节点几乎同时接收交易。 在 Hyperledger Fabric 中，由排序服务生成的区块是最终的。一旦一笔交易被写进一个区块，它在账本中的地位就得到了保证。 Hyperledger Fabric 的最终性意味着没有账本分叉，也就是说，经过验证的交易永远不会被重写或删除。 验证和提交每个节点将独立地以确定的方式验证区块，以确保账本保持一致。 无效的交易仍然保留在排序节点创建的区块中，但是节点将它们标记为无效，并且不更新账本的状态。 排序服务的实现几种不同的实现可以在排序服务节点之间就严格的交易排序达成共识。 Raft (推荐) 作为 v1.4.1 的新特性，Raft 是一种基于 etcd 中 Raft 协议实现的崩溃容错（Crash Fault Tolerant，CFT）排序服务。Raft 遵循“领导者跟随者”模型，这个模型中，在每个通道上选举领导者节点，其决策被跟随者复制。Raft 排序服务会比基于 Kafka 的排序服务更容易设置和管理，它的设计允许不同的组织为分布式排序服务贡献节点。 RaftFabric 实现了使用“领导者跟随者”模型的 Raft 协议，领导者是在一个通道的排序节点中动态选择的（这个集合的节点称为“共识者集合（consenter set）”），领导者将信息复制到跟随者节点。 Raft 被称为“崩溃容错”是因为系统可以承受节点的损失，包括领导者节点，前提是要剩余大量的排序节点（称为“法定人数（quorum）”）。 使用 Raft，所有内容都会嵌入到您的排序节点中。Raft 更容易设置。 使用 Raft，每个组织都可以有自己的排序节点参与排序服务，从而形成一个更加分散的系统。 Raft 是原生支持的，Raft 允许用户指定哪个排序节点要部署到哪个通道。 Raft 是向开发拜占庭容错（BFT）排序服务迈出的第一步。 日志条目（Log entry）Raft 排序服务中的主要工作单元是一个“日志条目”，该项的完整序列称为“日志”。 大多数成员（换句话说是一个法定人数）同意条目及其顺序，则我们认为条目是一致的，然后将日志复制到不同排序节点上。 共识者集合（Consenter set）主动参与给定通道的共识机制并接收该通道的日志副本的排序节点。 有限状态机（Finite-State Machine，FSM）Raft 中的每个排序节点都有一个 FSM，它们共同用于确保各个排序节点中的日志序列是确定（以相同的顺序编写）。 法定人数（Quorum）描述需要确认提案的最小同意人数。 对于每个共识者集合，这是大多数节点。 领导者通道的共识者集合都选择一个节点作为领导者，领导者负责接收新的日志条目，将它们复制到跟随者的排序节点，并在认为提交了某个条目时进行管理。 跟随者跟随者从领导者那里接收日志并复制它们，确保日志保持一致。 交易中的Raft在 Raft 中，交易（以提案或配置更新的形式）由接收交易的排序节点自动路由到该通道的当前领导者。 架构说明Raft 是如何选举领导者节点总是处于以下三种状态之一：跟随者、候选人或领导者。 所有节点最初都是作为跟随者开始的。 在一段时间内没有接收到日志条目或心跳（例如，5秒），节点将自己提升到候选状态。 在候选状态中，节点从其他节点请求选票。如果候选人获得法定人数的选票，那么他就被提升为领导者。 快照Raft 使用了一个称为“快照”的过程，在这个过程中，用户可以定义日志中要保留多少字节的数据。这个数据量将决定区块的数量。 快照中只存储完整的区块","categories":[{"name":"区块链","slug":"区块链","permalink":"http://peapod.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"Hyperledger Fabric","slug":"Hyperledger-Fabric","permalink":"http://peapod.top/tags/Hyperledger-Fabric/"}],"author":"taweizhong"},{"title":"Hyperledger Fabric 账本","slug":"Hyperledger-Fabric-账本","date":"2022-09-23T09:19:33.000Z","updated":"2022-09-24T02:24:42.835Z","comments":true,"path":"2022/09/23/Hyperledger-Fabric-账本/","link":"","permalink":"http://peapod.top/2022/09/23/Hyperledger-Fabric-%E8%B4%A6%E6%9C%AC/","excerpt":"","text":"账本账本、事实和状态账本储存的其实并不是业务对象本身，而是与业务对象相关的事实信息。 与业务对象当前状态相关的事实可能会发生改变，但是与之相关的事实历史是不可变的。 账本账本由“世界状态“和”区块链“这两部分组成，它们彼此不同但却相互关联。 世界状态是一个数据库，它存储了一组账本状态的当前值。 通过世界状态，程序可以直接访问一个账本状态的当前值，不需要遍历整个交易日志来计算当前值。 区块链是交易日志，它记录了促成当前世界状态的所有改变。 世界状态 W 由区块链 B 决定。 Fabric 网络维护着一个账本的多个副本，这些副本通过名为共识的过程来与其他副本保持一致。分布式账本技术（DLT） 世界状态世界状态将业务对象属性的当前值保存为唯一的账本状态。 世界状态包含两个状态。第一个状态是： key&#x3D;CAR1 和 value&#x3D;Audi。第二个状态中有一个更复杂的值：key&#x3D;CAR2 和 value&#x3D;{model:BMW, color&#x3D;red, owner&#x3D;Jane} 。 账本状态记录了一组与特定业务对象有关的事实。我们的示例展示的是 CAR1 和 CAR2 这两辆车的账本状态，二者都各有一个值和一个键。 世界状态被作为数据库来实现。 （所有被提交的交易，无论有效与否，都会被收进区块链）。 关键设计在于，只有那些受到相关背书组织签名的交易才会更新世界状态。 首次创建账本时，世界状态是空的。 个人理解：这个世界状态相当于比特币中的UTXO。 区块链世界状态存储了与业务对象当前状态相关的事实信息，而区块链是一种历史记录，它记录了这些业务对象是如何到达各自当前状态的相关事实。 区块链记录了每个账本状态之前的所有版本以及状态是如何被更改的。 区块排序以及区块内的交易排序，这一机制是在 Hyperledger Fabric 的排序服务组件首次创建区块时被建立起来的。 区块链总是以文件实现，而与之相反的是，世界状态以数据库实现。 区块链 B 包含了 B0、B1、B2、B3这四个区块。B0 是该区块链的第一个区块，也叫创世区块。 创世区块包含了一个配置交易，该交易含有网络配置（未显示）的初始状态。 区块区块结构： 区块头 包含三个字段，这些字段是在创建一个区块时候被写入的。 区块编号：编号从0（初始区块）开始，每在区块链上增加一个新区块，编号的数字都会加1。 当前区块的哈希值：当前区块中包含的所有交易的哈希值。 前一个区块头的哈希值：区块链中前一个区块头的哈希值。 区块数据：包含了一个有序的交易列表。区块数据是在排序服务创建区块时被写入的。 区块元数据：包含了区块被写入的时间，还有区块写入者的证书、公钥以及签名。 交易交易记录了世界状态发生的更新。 T4包括的内容如下：交易头 H4，一个交易签名 S4，一个交易提案 P4，一个交易响应 R4 和一系列背书 E4。 头 这部分用 H4 表示，它记录了关于交易的一些重要元数据，比如，相关链码的名字以及版本。 签名 这部分用 S4 表示，它包含了一个由客户端应用程序创建的加密签名。该字段是用来检查交易细节是否未经篡改，因为交易签名的生成需要用到应用程序的私钥。 提案 这部分用 P4 表示，它负责对应用程序供给智能合约的输入参数进行编码，随后该智能合约生成提案账本更新。在智能合约运行时，这个提案提供了一套输入参数，这些参数同当前的世界状态一起决定了新的账本世界状态。 响应 这部分用 R4 表示，它是以读写集 （RW-set）的形式记录下世界状态之前和之后的值。交易响应是智能合约的输出，如果交易验证成功，那么该交易会被应用到账本上，从而更新世界状态。 背书 就像 E4 显示的那样，它指的是一组签名交易响应，这些签名都来自背书策略规定的相关组织，并且这些组织的数量必须满足背书策略的要求。 世界状态数据库的选择世界状态是以数据库的形式实现的，旨在提供简单有效的账本状态存储和检索。 世界状态数据库的选项包括 LevelDB 和 CouchDB 。 LevelDB 是世界状态数据库的默认选项，当账本状态是简单的键值对时，使用 LevelDB 非常合适。 当账本状态结构为 JSON 文档时，以 CouchDB 来实现世界状态非常合适，这是因为业务交易涉及的数据类型通常十分丰富，而 CouchDB 可支持对这些数据类型进行各种形式的查询和更新。 在实现方面，CouchDB 是在单独的操作系统进程中运行的，但是节点和 CouchDB 实例之间仍然存在1:1的关系。 命名空间每个链码都有自己的世界状态，并且与所有其他链码的世界状态分离。 世界状态位于一个命名空间中，因此只有位于同一链码中的智能合约才能访问一个给定的命名空间。 区块链没有命名空间。它包含来自许多不同智能合约命名空间的交易。 通道每个通道都有一个完全独立的账本。这意味着完全独立的区块链和完全独立的世界状态，包括命名空间。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://peapod.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"Hyperledger Fabric","slug":"Hyperledger-Fabric","permalink":"http://peapod.top/tags/Hyperledger-Fabric/"}],"author":"taweizhong"},{"title":"Hyperledger Fabric 智能合约","slug":"Hyperledger-Fabric-智能合约","date":"2022-09-23T09:19:19.000Z","updated":"2022-09-24T02:24:24.815Z","comments":true,"path":"2022/09/23/Hyperledger-Fabric-智能合约/","link":"","permalink":"http://peapod.top/2022/09/23/Hyperledger-Fabric-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/","excerpt":"","text":"智能合约和链码账本包含了与一组业务对象的当前和历史状态有关的事实，而智能合约定义了生成这些被添加到账本中的新事实的可执行逻辑。 管理员通常使用链码将相关的智能合约组织起来进行部署，并且链码也可以用于 Fabric 的底层系统编程。 智能合约在各业务彼此进行交互之前，必须先定义一套通用的合约，其中包括通用术语、数据、规则、概念定义和流程。 智能合约用可执行的代码定义了不同组织之间的规则。 应用程序调用智能合约来生成被记录到账本上的交易。 组织 ORG1 和 ORG2 是如何通过定义一个 car 智能合约来实现 查询、转移 和 更新 汽车的。 可以将智能合约看成交易的管理者，而链码则管理着如何将智能合约打包以便用于部署。 一个智能合约定义在一个链码中。而多个智能合约也可以定义在同一个链码中。当一个链码部署完毕，该链码中的所有智能合约都可供应用程序使用。 vehicle 链码包含了以下三个智能合约：cars、boats 和 trucks；而 insurance 链码包含了以下四个智能合约：policy、liability、syndication 和 securitization。 账本智能合约以编程方式访问账本两个不同的部分： 一个是区块链（记录所有交易的历史，且记录不可篡改） 一个是世界状态（保存这些状态当前值的缓存，是经常需要用到的对象的当前值）。 智能合约主要在世界状态中将状态写入（put）、读取（get）和删除（delete），还可以查询不可篡改的区块链交易记录。 读取（get） 操作一般代表的是查询，目的是获取关于交易对象当前状态的信息。 写入（put） 操作通常生成一个新的业务对象或者对账本世界状态中现有的业务对象进行修改。 删除（delete） 操作代表的是将一个业务对象从账本的当前状态中移除，但不从账本的历史中移除。 开发智能合约是应用程序开发的重点。 智能合约的核心是一组 交易 定义。 例如，在 fabcar.js 中，创建了一辆新车的智能合约交易： 123456789101112async createCar(ctx, carNumber, make, model, color, owner) &#123; const car = &#123; color, docType: &#x27;car&#x27;, make, model, owner, &#125;; await ctx.stub.putState(carNumber, Buffer.from(JSON.stringify(car)));&#125; 背书每个链码都有一个背书策略与之相关联，该背书策略适用于此链码中定义的所有智能合约。 背书策略非常重要，它指明了区块链网络中哪些组织必须对一个给定的智能合约所生成的交易进行签名，以此来宣布该交易有效。 一个示例背书策略可能这样定义：参与区块链网络的四个组织中有三个必须在交易被认为有效之前签署该交易。所有的交易，无论是有效的还是无效的，都会被添加到分布式账本中，但只有有效交易会更新世界状态。 交易必须由 Fabric 网络中受信任的组织验证。 例如，一个政府组织必须签署一个有效的 issueIdentity 交易，或者一辆车的 买家 和 卖家 都必须签署一个 车辆 转移交易。 有效交易智能合约提取一组名为交易提案的输入参数，并将其与程序逻辑结合起来使用以读写账本。对世界状态的更改被捕获为交易提案响应（或简称交易响应），该响应包含一个读写集，其中既含有已读取的状态，也含有还未书写的新状态（如果交易有效的话）。 在执行智能合约时世界状态没有更新！ 所有交易，无论是否有效，都会被记录在区块链上，但仅有效交易会更新世界状态。 各节点通过两个阶段对其进行验证。 根据背书策略检查交易，确保该交易已被足够的组织签署。 该交易在受到背书节点签名时它的交易读集与世界状态的当前值匹配，并且中间过程中没有被更新。 交易通过了这两个测试，它就被标记为有效。 通道 通道在一群组织之间提供了一种完全独立的通信机制。当链码定义被提交到通道上时，该通道上所有的应用程序都可以使用此链码中的智能合约。 链码定义是一种包含了许多参数的结构，这些参数管理着链码的运行方式，包含着链码名、版本以及背书策略。各通道成员批准各自组织的一个链码定义，以表示其对该链码的参数表示同意。 链码的定义为通道成员提供了一种他们在通道上使用智能合约来交易之前，同意对于一个链码的管理的方式。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://peapod.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"Hyperledger Fabric","slug":"Hyperledger-Fabric","permalink":"http://peapod.top/tags/Hyperledger-Fabric/"}],"author":"taweizhong"},{"title":"Hyperledger Fabric 节点","slug":"Hyperledger-Fabric-节点","date":"2022-09-23T09:19:11.000Z","updated":"2022-09-24T02:23:53.522Z","comments":true,"path":"2022/09/23/Hyperledger-Fabric-节点/","link":"","permalink":"http://peapod.top/2022/09/23/Hyperledger-Fabric-%E8%8A%82%E7%82%B9/","excerpt":"","text":"节点Peer 是网络的基本元素，因为他们存储了账本和智能合约。 Peer 节点可以被创建、启动、停止、重新配置甚至删除。 暴露了一系列的 API，这就可以让管理者和应用程序同这些 API 提供的服务互动。 账本和链码Peer 节点在维护账本和链码。 Peer 节点维护的是账本及链码的实例。 应用程序及管理员访问这些资源，他们必须要和 Peer 节点进行交互。 多账本 大多数的 Peer 节点将会至少安装一个链码，用来查询或更新 Peer 节点的账本实例。 多链码 应用程序和节点当应用程序需要访问账本和链码的时候，他们总是需要连接到 Peer 节点。 Hyperledger Fabric SDK 将这个操作变得非常简单，它的 API 使应用程序能够连接到 Peer 节点，调用链码生成交易，提交交易到网络。 查询过程： A 连接到了 P1 且调用了链码 S1 来查询账本 L1 P1 调用了链码 S1 来生成提案响应（响应包含了查询结果） A 接收到了提案的响应 更新过程： A 连接到了 P1 且调用了链码 S1 来更新账本 L1 P1 调用了链码 S1 来生成提案响应（账本更新的提案） A 接收到了提案的响应 A 会从所有的响应中创建一笔交易 交易发送给排序节点 O1 进行排序。 区块分发到所有 Peer 节点上。 当 L1 被更新之后，P1 会生成一个事件，该事件会被 A 接收到，来标识这个过程结束了。 一个独立的 Peer 节点目前是不能进行账本更新的，因为其他的 Peer 节点必须首先要同意这个变动（即达成共识）。 因此，Peer 节点会返回给应用程序一个被提案过的更新，这个 Peer 节点会依据其他节点之前的协议来应用这个更新。 通道与节点 通道允许区块链网络中特定的一些 Peer 节点以及应用程序来彼此交互。 组织与节点 有一个工作原则：如果组织不为这个网络贡献他们的资源，这个网络是不会存在的。更关键的是，这个网络会随着这些互相合作的组织提供的资源而增长或者萎缩。 身份与节点Peer 节点会有一个身份信息被分给他们，这是通过一个特定的证书认证机构颁发的数字证书来实现的。 在网络中的每个 Peer 节点都会被所属组织的管理员分配一个数字证书。 当 Peer 节点连接到一个通道的时候，它的数字证书会通过通道 MSP 来识别它的所属组织。 P1 和 P2 具有由 CA1 颁发的身份信息。 通道 C 通过在它的通道配置中的策略来决定来自 CA1 的身份信息应该使用 ORG1.MSP 被关联到 Org1。 在通道配置中的策略会使用 Peer 节点的身份信息来确定它的权利。 关于身份信息和组织的映射是由成员服务提供者（MSP）来提供的，它决定了一个 Peer 节点如何在指定的组织中分配到特定的角色以及得到访问区块链资源的相关权限。 Peer 节点只能被一个组织所有，因此也就只能被关联到一个单独的 MSP。 Peer节点和排序节点一个单独的 Peer 节点不能够由它自己来更新账本——更新需要网络中其他节点的同意。 Peer 节点会请求网络中的其他 Peer 节点来批准这次更新。这个过程被称为共识。 更新账本的应用程序会被引入到一个三阶段的流程，确保 Peer 节点都彼此保持着一致的账本。 在第一个阶段，应用程序会跟背书节点的子集一起工作，其中的每个节点都会向应用程序为提案的账本更新提供背书，但是不会将提案的更新应用到他们的账本副本上。 在第二个阶段，这些分散的背书会被搜集到一起当做交易被打包进区块中。 在最后一个阶段，这些区块会被分发回每个 Peer 节点，在这些 Peer 节点上每笔交易在被应用到 Peer 节点的账本副本之前会被验证。 提案第一阶段只在乎应用程序询问不同组织的背书节点同意链码调用的提案结果。 应用程序会生成一笔交易的提案，它会把这个提案发送给一系列的被要求的节点来获得背书。 每一个背书节点接下来都会独立地使用交易提案来执行链码，以此来生成这个交易提案的响应。 简单地为它提供签名然后将它返回给应用程序。当应用程序接收到有效数量的被签过名的提案响应之后，交易流程中的第一个阶段就结束了。 应用程序 A1 生成了交易 T1 和提案 P 应用程序会将交易及提案发送给通道 C 上的 Peer 节点 P1 和 Peer 节点 P2 P1 使用交易 T1 和 提案 P 来执行链码 S1，这会生成对交易 T1 的响应 R1，它会提供背书 E1。 P2 使用交易 T1 提案 P 执行了链码 S1，这会生成对于交易 T1 的响应 R2，它会提供背书 E2。 应用程序 A1 对于交易 T1 接收到了两个背书响应，称为 E1 和 E2。 Peer 节点通过向提案的响应添加自己的数字签名的方式提供背书，并且使用它的私钥为整个的负载提供签名。 排序和将交易打包到区块排序节点是这个过程的关键——它接收交易，这些交易中包含了来自很多个应用的已经背书过的交易提案，并且将交易排序并打包进区块。 验证和提交在每个 Peer 节点上，区块中的每笔交易都会被验证，以确保它在被提交到账本之前，已经被所有相关的组织一致地背书过了。 排序节点 O1 将区块 B2 分发给了 Peer 节点 P1 和 Peer 节点 P2。 Peer P1 处理了区块 B2，产生了一个会被添加到 P1 的账本 L1 中的新区块。 peer P2 处理了区块 B2，产生了一个会被添加到 P2 的账本 L1 中的新区块。 阶段三是从排序节点将区块分发到所有与它连接的 Peer 节点开始的。Peer 节点会和通道中的排序节点相连，所有跟这个排序节点相连的 Peer 节点将会收到一个新的区块的副本。 不是每个 Peer 节点都需要连接到排序节点——Peer 节点可以使用 gossip 协议将区块的信息发送给其他 Peer 节点，其他 Peer 节点也可以独立地处理这些区块。 链码仅仅需要在背书节点中有效，而不需要在区块链网络的所有部分都要有。 当区块被提交到 Peer 节点的账本的时候，那个 Peer 节点会生成一个合适的事件。 应用程序可以对这些事件类型进行注册，所以在这些事件发生的时候他们能够被通知到。这些通知结束了交易流程的第三以及最后的阶段。 排序节点和共识整个交易处理流程被称为共识，因为所有 Peer 节点在由排序节点提供的流程中对交易的排序及内容都达成了一致。 排序节点理解为这样一些节点，它们从应用程序收集和分发账本更新提案以供 Peer 节点验证并写入账本中。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://peapod.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"Hyperledger Fabric","slug":"Hyperledger-Fabric","permalink":"http://peapod.top/tags/Hyperledger-Fabric/"}],"author":"taweizhong"},{"title":"Hyperledger Fabric 策略","slug":"Hyperledger-Fabric-策略","date":"2022-09-23T09:18:56.000Z","updated":"2022-09-24T02:23:34.208Z","comments":true,"path":"2022/09/23/Hyperledger-Fabric-策略/","link":"","permalink":"http://peapod.top/2022/09/23/Hyperledger-Fabric-%E7%AD%96%E7%95%A5/","excerpt":"","text":"策略策略是一组规则，用来定义如何做出决策和实现特定结果。 Fabric 策略表示成员如何同意或者拒绝网络、通道或者智能合约的变更。 策略是使 Hyperledger Fabric 不同于其他区块链系统的内容之一。 策略决定了那些组织可以访问或者更新 Fabric 网络，并且提供了强制执行这些决策的机制。 实现策略策略实现在 Fabric 网络的不同层次。 系统通道配置网络中必须有至少一个排序服务的排序系统通道，它是第一个被创建的通道。 该通道也包含着谁是排序服务（排序服务组织）以及在网络中交易（联盟组织）的成员。 策略治理着排序服务使用的共识，并定义了新区块如何被创建。 系统通道也治理着联盟中的哪些成员可以创建新通道。 应用通道配置应用 通道 用于向联盟中的组织间提供私有通信机制。 策略治理着从通道中添加和删除成员的能力。 治理着使用 Fabric 链码生命周期在链码定义和提交到通道前需要哪些组织同意。 权限从控制列表ACL 通过将资源和已有策略相关联的方式提供了资源访问配置的能力。 Fabric ACL 的默认集合在 configtx.yaml 文件的 Application: &amp;ApplicationDefaults 部分。 configtx.yaml 中定义的资源列表是 Fabric 当前定义的所有内部资源的完整集合。 智能合约背书策略每一个智能合约都有一个背书策略，该策略指明了需要通道中多少不同组织的成员根据指定智能合约执行和验证交易才能使一笔交易有效。 背书策略定义了必须“背书”（批准）提案执行的组织（的 Peer 节点）。 修改策略它是定义如何更新策略的策略。 策略作用域 系统通道配置为联盟成员提供了创建通道的能力。 应用通道和 ACL 是联盟组织用来从通道中添加或删除成员以及限制通道中智能合约和数据访问的机制。 写策略在 Hyperledger Fabric 中，策略中明确的签名使用 Signature 语法，隐含的签名使用 ImplicitMeta 语法。 签名策略Signature 策略定义了要满足策略就必须签名的特定用户类型，比如 Org1.Peer OR Org2.Peer。 例如，一个策略可以简单表达为使用 AND (Org1, Org2) ，表示满足该策略就同时需要 Org1 中的一个成员和 Org2 中的一个成员的签名。 隐元策略隐元策略只在通道配置上下文中有效，通道配置在配置树策略中是基于分层的层次结构。 应用通道分层的策略结构： 当满足配置层级中它的 Admins 子策略时，就代表也满足了其子策略的子策略条件。 隐元通道配置管理策略（称为 /Channel/Admins）。 在配置树中所有 Admins 策略都引用了的 Admin 子策略。 隐元策略比如 MAJORITY Admins 的主要优势在于当你向通道添加新组织的时候，你不必更新通道策略。 链码的生命周期configtx.yaml 文件中 Application 部分包含了默认的链码生命周期背书策略。 12345678910111213141516171819202122232425Application: &amp;ApplicationDefaults # Organizations is the list of orgs which are defined as participants on # the application side of the network Organizations: # Policies defines the set of policies at this level of the config tree # For Application policies, their canonical path is # /Channel/Application/&lt;PolicyName&gt; Policies: Readers: Type: ImplicitMeta Rule: &quot;ANY Readers&quot; Writers: Type: ImplicitMeta Rule: &quot;ANY Writers&quot; Admins: Type: ImplicitMeta Rule: &quot;MAJORITY Admins&quot; LifecycleEndorsement: Type: ImplicitMeta Rule: &quot;MAJORITY Endorsement&quot; Endorsement: Type: ImplicitMeta Rule: &quot;MAJORITY Endorsement&quot; LifecycleEndorsement 策略控制需要谁 批准链码定义 。 Endorsement 策略是 链码的默认背书策略 。 链码背书策略链码被批准并提交到通道时会指定一个背书策略。 批准阶段没有明确指明背书策略，就默认使用 Endorsement 策略 &quot;MAJORITY Endorsement&quot;。 要想使交易生效就需要大多数不同通道成员（组织）的执行并验证交易。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://peapod.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"Hyperledger Fabric","slug":"Hyperledger-Fabric","permalink":"http://peapod.top/tags/Hyperledger-Fabric/"}],"author":"taweizhong"},{"title":"Hyperledger Fabric MSP","slug":"Hyperledger-Fabric-MSP","date":"2022-09-23T04:46:20.000Z","updated":"2022-09-24T02:23:03.826Z","comments":true,"path":"2022/09/23/Hyperledger-Fabric-MSP/","link":"","permalink":"http://peapod.top/2022/09/23/Hyperledger-Fabric-MSP/","excerpt":"","text":"成员服务提供者（MSP）证书机构通过生成可以用来证实身份的由公钥和私钥形成的键值对来发放认证信息。 MSP是一个可让身份被信任和被网络中其他参与者公认的，而不需要暴露成员的私钥的机制。 MSP将一个身份(信用卡)转换为一个角色(在商店购买东西的能力)。 它给予组织、节点和通道建立MSPs的能力，使其确定谁可以在组织、节点和通道层次上运作。 加入一个需要许可的区块链网络： 拥有一个由网络信任的CA颁发的身份。 成为一个被网络成员认可和认可的 组织 的成员。MSP将身份与组织的成员资格联系在一起。成员资格是通过将成员的公钥添加到组织的MSP来实现的。 将MSP添加到网络上的一个联盟 或者通道。 确保MSP包括在网络中的策略 定义。 MSP通过标识参与者在节点或通道上拥有的特定特权，将身份转换为角色。 MSP域MSP 出现在两个位置： 在参与者节点本地（本地 MSP） 在通道配置中（通道 MSP） 本地MSP为客户端和节点(peer节点和排序节点)定义的。 本地MSPs定义节点的权限。(例如，谁是可以操作节点的peer节点管理员)。 每个节点都必须定义一个本地MSP，它定义了在该级别上谁拥有管理权或参与权。 通道MSP通道MSP在通道层面上定义了管理权和参与权。 本地MSP表现为文件系统上的文件夹结构，而通道MSP则在通道配置中被描述。 通道MSP识别谁在通道层次拥有权限。 每个参与通道的组织都必须为其定义一个MSP。 系统通道MSP包括参与排序服务的所有组织的MSP。 通道MSP也在通道中的每个节点的文件系统上实例化，并通过共识保持同步。 尽管每个节点的本地文件系统上都有每个通道MSP的副本，但从逻辑上讲，通道MSP存在并被维护于通道或网络上。 组织组织是一个逻辑上成员们的管理组。在单个MSP下管理其成员。 以组织的名字为前缀命名MSP。 组织单元（ou）一个组织也可以被划分为多个组织单元，每个单元都有一定的职责。 当CA颁发X.509证书时，证书中的OU字段指定该身份所属的业务流水线。 节点组织单元特殊类型的组织单元，有时称为节点组织单元，可用于授予角色以身份标识。 为了使用节点组织单元角色，通过在MSP目录下的配置文件config.yaml中启用“Node OUs”字段来实现: 1234567891011121314NodeOUs: Enable: true ClientOUIdentifier: Certificate: cacerts/ca.sampleorg-cert.pem OrganizationalUnitIdentifier: client PeerOUIdentifier: Certificate: cacerts/ca.sampleorg-cert.pem OrganizationalUnitIdentifier: peer AdminOUIdentifier: Certificate: cacerts/ca.sampleorg-cert.pem OrganizationalUnitIdentifier: admin OrdererOUIdentifier: Certificate: cacerts/ca.sampleorg-cert.pem OrganizationalUnitIdentifier: orderer MSP有4种节点组织单元角色: client peer admin orderer 联盟中的不同组织可以使用组织单元来区分彼此。在这种情况下，不同的组织必须为其信任链使用相同的根CA和中间CA，并分配OU字段来标识每个组织的成员们。 MSP结构本地MSP文件夹：","categories":[{"name":"区块链","slug":"区块链","permalink":"http://peapod.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"Hyperledger Fabric","slug":"Hyperledger-Fabric","permalink":"http://peapod.top/tags/Hyperledger-Fabric/"}],"author":"taweizhong"},{"title":"Hyperledger Fabric 身份\"","slug":"Hyperledger-Fabric-身份","date":"2022-09-23T04:09:28.000Z","updated":"2022-09-24T02:22:40.884Z","comments":true,"path":"2022/09/23/Hyperledger-Fabric-身份/","link":"","permalink":"http://peapod.top/2022/09/23/Hyperledger-Fabric-%E8%BA%AB%E4%BB%BD/","excerpt":"","text":"身份身份：确定了对资源的确切权限以及对参与者在区块链网络中拥有的信息的访问权限。 一个 MSP 是定义管理该组织有效身份规则的组件。 MSP 将可验证的身份转变为区块链网络的成员 。 Fabric 中默认的 MSP 实现使用 X.509 证书作为身份，采用传统的公钥基础结构（Public Key Infrastructure,PKI）分层模型。 PKI提供身份列表，MSP说哪些是参与网络的给定组织的成员。 PKI公钥基础结构（PKI）是一组互联网技术，可在网络中提供安全通信。 PKI 由向各方发布数字证书的证书授权中心组成。 PKI 有四个关键要素： 数字证书 公钥和私钥 证书授权中心 证书撤销列表 数字证书 数字证书是包含与证书持有者相关的属性的文档。 公钥是在证书中分发的，而私人签名密钥则不是。 只要对方信任证书颁发者，即证书授权中心（CA），密码学就允许 将证书提交给其他人以证明其身份。 CA 安全地保存某些加密信息（CA 的私钥），任何阅读证书的人都可以确定有关 Mary 的信息没有被篡改，它将始终具有 Mary Morris 的特定属性。 授权，公钥和私钥身份验证要求确保交换消息的各方创建特定消息的身份。 “完整性”的消息意味着在其传输期间不能被修改。 密钥之间唯一的数学关系使得私钥在消息上的签名，只有对应公钥在相同的消息上才可以与之匹配。 Mary 使用她的私钥对邮件进行签名。任何使用她的公钥查看签名消息的人都可以验证签名。 证书授权中心人员或节点能够通过由系统信任的机构为其发布的数字身份参与区块链网络。 数字身份：符合 X.509 标准并由证书授权中心（CA）颁发的经加密验证的数字证书。 证书授权中心向不同的参与者颁发证书。 证书由 CA 进行签名，并将参与者的公钥绑定在一起（并且可选是否具有全部属性列表）。 根 CA，中间 CA 和信任链 中间 CA 在跨多个组织颁发证书时提供了巨大的灵活性。 不同的组织可能使用不同的根 CA，或者使用具有不同中间 CA 的相同根 CA，这取决于网络的需求。 Fabric CA是一个私有根 CA 提供者，能够管理具有 X.509 证书形式的 Fabric 参与者的数字身份。 证书撤销列表是 CA 知道由于某些原因而被撤销的证书的引用列表。 当第三方想要验证另一方的身份时，它首先检查颁发 CA 的 CRL 以确保证书尚未被撤销。 MSP 发挥作用的地方——它确定了区块链网络特定组织的成员。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://peapod.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"Hyperledger Fabric","slug":"Hyperledger-Fabric","permalink":"http://peapod.top/tags/Hyperledger-Fabric/"}],"author":"taweizhong"},{"title":"Hyperledger Fabric网络架构","slug":"Hyperledger-Fabric网络架构","date":"2022-09-23T02:16:21.000Z","updated":"2022-09-24T02:22:18.824Z","comments":true,"path":"2022/09/23/Hyperledger-Fabric网络架构/","link":"","permalink":"http://peapod.top/2022/09/23/Hyperledger-Fabric%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/","excerpt":"","text":"区块链网络概念上描述组织以区块链网络的形式进行合作。 概念：区块链网络是一个为应用程序提供账本及智能合约服务的技术基础设施。 多个组织作为一个联盟形成一个网络，权限是由网络最初配置的时候联盟定义的规则实现。 实例网络 R4 被分配作为网络的初始者，它有权设置网络的初始版本。 网络是根据在网络配置 NC4 中指定的规则来进行管理 整个网络由组织 R1 和 R4 管理。 通道 C1 是根据在通道配置 CC1 中指定的规则来管理 排序服务 O4 作为这个网络 N 的一个网络管理员节点，并且使用系统通道。 每个组织都有一个首选的 CA。 创建网络 排序服务 O4 由一个单独的节点组成，是根据一个网络配置 NC4 来进行配置 证书颁发机构 CA4 被用来向管理员和组织 R4 的网络节点分配身份信息。 在定义 网络 N 的时候，第一件事情就是定义一个 排序服务 证书颁发机构CA4，它会被用来给管理者和网络节点颁发证书。 CA 颁发的证书也可以用来为交易提供签名，来表明一个组织对交易的结果进行背书。 每个组织会有一个 CA。 成员服务提供者将证书同成员组织进行匹配。 NC4使用MSP来分配在网络资源上的特殊权利。 个人理解： CA用来证明某一个成员属于那个组织，属于组织层面。 MSP表明某个成员在组织里的定位（如组织内的权限等），属于成员（组织内的成员）层面 X.509 证书被用于客户端应用的交易提案和智能合约的交易响应，来对交易进行数字签名。 添加网络管理员 使组织 R1 也成为了管理员。 R1 和 R4 在网络配置中便具有了相同的权限。 证书颁发机构 CA1 也被添加进来了，他用来标识 R1 组织的用户。 定义联盟 定义联盟 X1 联盟的定义被存储在了网络配置 NC4 为联盟创建通道 联盟 X1 为 R1 和 R2 创建的的通道 C1。 通道通过通道配置 CC1 来进行管理。 通道 C1 为联盟 X1 提供了一个私有的通信机制。 CC1 包含了赋予 R1 和 R2 在通道 C1 上的权利的规则。 被排序服务使用的特殊的系统通道。 节点和账本新增了两个组件，称作 Peer 节点 P1 和账本实例 L1。 物理上 P1 会存储账本 L1 的副本。 P1 和 O4 可以使用通道 C1 来进行通信。 Peer 节点是存储区块链账本副本的网络组件。 L1 会被物理地存储在 P1 上，但是 逻辑上 是存储在通道 C1 上。 CA1 颁发的 X.509 身份信息，它将 P1 和组织 R1 关联了起来。 使用排序 O4将P1 加入通道C1。 通道配置 CC1 来决定 P1 在这个通道中的权限。 个人理解： CA1将P1和R1连接起来。O4将P1和C1连接起来。 CA1：信息验证，CC1权限控制。 app和chaincode 智能合约 S5 被安装在了 P1 上。 组织 R1 中的客户端应用 A1 可以通过 Peer 节点 P1 使用 S5 来访问账本。 应用 A1 能够使用通道 C1 来连接指定的网络资源。 所有的访问都是由一个称为智能合约链码 S5 的特殊程序来管理的。 智能合约被用来帮助生成被分发到网络中每个节点的交易。 智能合约必须被安装，然后在通道中被定义。 作用：智能合约定义了交易逻辑，它控制了在世界状态中包含的一个业务对象的生命周期。 智能合约—&gt;打包—&gt;链码 链码部署到一个区块链网络中。 智能合约：管理交易。 链码：管理着智能合约应该如何被打包部署。 安装链码包组织 R1 中的管理员把S5安装到节点 P1 上。 定义链码链码安装在组织的 Peer 节点上。在一个通道范围内被管理和维护的。 每个组织需要批准一个链码定义，一系列参数来定义在一个通道中链码应该被如何使用。 管理员 R1 必须要批准 S5 的链码定义。 需要有效数量的组织来批准一个链码的定义（默认为大多数）。 R1 的管理员-&gt;提交 S5 的链码定义-&gt;通道 C1 定义提交后,S5 就可以被客户端应用 A1 调用了。 实际上是定义并提交了智能合约的接口到通道，而不是安装了智能合约的实现。 安装智能合约展示了我们是如何将它物理地存储在 Peer 节点上，实例化智能合约展示了我们是如何将它逻辑地存储在通道中。 背书策略链码定义提供的信息中最重要的部分就是背书策略。 它描述了在交易被其他的组织接受并存储在他们的账本副本上之前，哪些组织必须要同意此交易。 只有当 R1 和 R2 对交易进行背书之后，交易才能够被接受并存储到账本 L1 中。 调用智能合约客户端应用是通过发送交易提案给智能合约背书策略所指定的 Peer 的节点方式来调用智能合约的。 交易的提案会作为智能合约的输入 智能合约会使用它来生成一个背书交易响应 Peer 节点返回给客户端应用 完成网络将组织 R2 的基础设施添加到网络中。 生成并接受交易Peer 节点 存储智能合约; 节点只有在安装了智能合约之后才能够运行它 不存; 可以通过连接到通道来获取一个智能合约的接口信息。 带有智能合约的 Peer 节点：帮助生成交易。 所有的 Peer 节点：可以验证并接受或者拒绝交易存入他们的账本 L1 的副本中。 只有安装了智能合约的 Peer 节点才能够参与交易背书的流程。 Peer 节点的类型 提交节点：每个 Peer 节点都是一个提交节点。接收生成的区块，提交到 Peer 节点的账本副本中。 背书节点：安装了智能合约的 Peer 节点都可以作为一个背书节点。智能合约必须要被客户端应用使用，来生成一个被签名的交易响应。 Peer 节点的角色 主节点：负责将交易从排序节点分发到该组织中其他的提交节点。 锚节点：锚节点能够帮助很多不同的跨组织间的通信。 一般都会有一个主节点，至少一个背书节点和一个提交节点。 gossip 协议，可以容纳大量的 Peer 节点来支持这样的拓扑。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://peapod.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"Hyperledger Fabric","slug":"Hyperledger-Fabric","permalink":"http://peapod.top/tags/Hyperledger-Fabric/"}],"author":"taweizhong"},{"title":"Hyperledger Fabric 模型","slug":"Hyperledger-Fabric-模型","date":"2022-09-22T01:59:07.000Z","updated":"2022-09-24T02:21:50.610Z","comments":true,"path":"2022/09/22/Hyperledger-Fabric-模型/","link":"","permalink":"http://peapod.top/2022/09/22/Hyperledger-Fabric-%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"Hyperledger Fabric 模型简介模型： 资产 链码 账本 隐私 成员服务 共识 资产有形（房地产和硬件）到无形资产（合同和知识产权）。 提供使用链码交易来修改资产的功能。 资产在 Hyperledger Fabric 中表示为键值对的集合，状态更改记录为 Channel 账本上的交易。资产可以用二进制或 JSON 格式表示。 链码链码是定义单项或多项资产的软件，和能修改资产的交易指令；换句话说，它是业务逻辑。 强制执行读取或更改键值对或其他状态数据库信息的规则。 账本特点特点： 基于键的查找、范围查询和组合键查询来查询和更新账本； 富查询语言进行只读查询； 查询一个键的账本历史记录（数据溯源）； 交易包括链码读取键&#x2F;值（读集）以及链码写入键&#x2F;值（写集）； 交易包含每个背书节点的签名，并被提交给排序服务； 交易按顺序打包到区块，并被排序服务“分发”到通道上的节点； 节点根据背书策略验证交易并执行策略； 附加一个区块之前，会执行一次版本检查，以确保被读取的资产的状态自链码执行以来未发生更改； 一旦交易被验证并提交，就具有不变性； 一个通道的账本包含一个配置区块，用于定义策略、访问控制列表和其他相关信息； 通道包含MSP的实例，允许从不同的证书颁发机构（CA）生成加密材料 隐私当该通道上的组织子集需要对其交易数据保密时，私有数据集合用于将此数据隔离在私有数据库中，在逻辑上与通道账本分开，只有经授权的组织子集才能访问。 通道在更广泛的网络上保持交易的私密性，而集合则在通道上的组织子集之间保持数据的私密性。 进一步模糊数据：在将交易发送到排序服务并将区块附加到账本之前，可以使用诸如 AES 之类的通用加密算法对链码内的值进行加密（部分或全部）。 成员服务所有参与者都拥有已知的身份。 公钥基础设施（PKI）用于生成与组织、网络组件以及终端用户或客户端应用程序相关联的加密证书。 共识整个交易流程：从提案和背书到排序、验证和提交。 共识被定义为组成区块的一组交易的正确性的闭环验证。 背书策略：规定哪些特定成员必须背书某个交易类别。 系统链码：确保背书策略得到执行和维护。 提交之前，节点通过系统链码确保存在足够的背书，并且来自适当的实体。 共识并不仅仅局限于一批交易的商定顺序；相反，它的首要特征是交易从提案到提交的过程中不断进行核查而附带实现的。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://peapod.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"Hyperledger Fabric","slug":"Hyperledger-Fabric","permalink":"http://peapod.top/tags/Hyperledger-Fabric/"}],"author":"taweizhong"},{"title":"Hyperledger Fabric 简介","slug":"Hyperledger-Fabric-简介","date":"2022-09-22T01:10:34.000Z","updated":"2022-09-22T01:42:54.138Z","comments":true,"path":"2022/09/22/Hyperledger-Fabric-简介/","link":"","permalink":"http://peapod.top/2022/09/22/Hyperledger-Fabric-%E7%AE%80%E4%BB%8B/","excerpt":"","text":"简介比特币和以太坊属于同一类区块链，我们将其归类为公共非许可（Public Permissionless）区块链技术。 Hyperledger Fabric开源的企业级许可分布式账本技术平台。（DLT） Fabric 具有高度模块化和可配置的架构。 支持通用编程语言编写智能合约。 Fabric 平台也是许可的。 支持可插拔的共识协议。 模块化组成： 可插拔的排序服务 排序 广播 可插拔的成员服务提供者 将网络中的实体与加密身份相关联 智能合约（“链码”）隔离运行在容器环境 配置支持多种 DBMS 可插拔的背书和验证策略 许可和非许可非许可：基于“工作量证明（PoW）”的拜占庭容错共识许可： 崩溃容错（CFT）或拜占庭容错（BFT）共识协议 智能合约区块链应用的业务逻辑。关键点： 多个智能合约在网络中同时运行 动态部署 不被信任 执行-排序-验证为了解决顺序执行模型面临的弹性、灵活性、可伸缩性、性能和机密性问题 步骤： 执行交易并背书 共识协议排序 在提交到账本之前，背书策略验证交易 Fabric 在交易顺序达成最终一致前执行交易。 并行执行：每个交易只需要由满足交易的背书策略所必需的节点的子集来执行（背书）。第一阶段消除了任何非确定性。Fabric 是第一个能使用标准编程语言的区块链技术。 隐私和保密零知识证明（Zero Knowledge Proofs，ZKP）。通过其通道架构和私有数据特性实现保密。参与到通道的节点才有权访问智能合约（链码）和交易数据，以此保证了隐私性和保密性。 可插拔共识进行 CFT（崩溃容错）或 BFT（拜占庭容错）的排序。提供了一种基于etcd 库 中 Raft 协议 的 CFT 排序服务的实现。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://peapod.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"Hyperledger Fabric","slug":"Hyperledger-Fabric","permalink":"http://peapod.top/tags/Hyperledger-Fabric/"}],"author":"taweizhong"},{"title":"服务器安装Clash","slug":"服务器安装Clash","date":"2022-09-17T09:58:46.000Z","updated":"2022-09-17T10:30:40.298Z","comments":true,"path":"2022/09/17/服务器安装Clash/","link":"","permalink":"http://peapod.top/2022/09/17/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85Clash/","excerpt":"","text":"Clash安装教程下载地址（https://github.com/Dreamacro/clash） 找到对应的版本复制下载地址. 123456mkdir Clsahwget ‘包的地址’gunzip ‘下载下来的文件’ -d ./Clashcd Clashmv ‘文件名’ clashchmod +x clash 配置订阅信息123cd /Clashsudo wget -O config.yaml [订阅链接]sudo wget -O Country.mmdb https://www.sub-speeder.com/client-download/Country.mmdb 设置系统代理1vim /etc/profile 在最后面添加 12export http_proxy=&quot;http://127.0.0.1:7890&quot;export https_proxy=&quot;http://127.0.0.1:7890&quot; 保存退出后 1source /etc/profile 启动1./clash -d . 实现网络代理的切换首先启动clash 可以看到外部可以访问的端口为9090 记得配置服务器的端口，可以使外部访问9090端口 点击clash.razord.top进行配置 host 设置为服务器的IP，密码可以不用配置。 在代理中切换 在GUI界面中实现配置点击查看配置 clash for linux ，适用于ubuntu 20.04（更新于2021.11.6） - 知乎 (zhihu.com)","categories":[{"name":"实用","slug":"实用","permalink":"http://peapod.top/categories/%E5%AE%9E%E7%94%A8/"}],"tags":[{"name":"clash","slug":"clash","permalink":"http://peapod.top/tags/clash/"}],"author":"taweizhong"},{"title":"BeeGo实现文件的上传与下载","slug":"BeeGo实现文件的上传与下载","date":"2022-09-14T13:41:30.000Z","updated":"2022-09-14T14:11:19.262Z","comments":true,"path":"2022/09/14/BeeGo实现文件的上传与下载/","link":"","permalink":"http://peapod.top/2022/09/14/BeeGo%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/","excerpt":"","text":"beego实现文件的上传和下载文件的上传html的处理 1234&lt;form id=&quot;&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input id=&quot;myfile&quot; name=&quot;myfile&quot; type=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;保存&quot; /&gt;&lt;/form&gt; 控制器处理 123456789type ServiceController struct&#123; beego.Controller&#125;func (c *ServiceController) Post()&#123; f, h, _ := this.GetFile(&quot;myfile&quot;) //获取上传的文件 path := h.Filename //文件目录 f.Close() //关闭上传的文件 this.SaveToFile(&quot;myfile&quot;, path) &#125; 文件的下载123456789type FileOptDownloadController struct &#123; beego.Controller&#125;func (this *FileOptDownloadController) Get() &#123; //第一个参数是文件的地址，第二个参数是下载显示的文件的名称 this.Ctx.Output.Download(&quot;static/img/1.jpg&quot;,&quot;tu1.jpg&quot;)&#125;","categories":[{"name":"Web","slug":"Web","permalink":"http://peapod.top/categories/Web/"}],"tags":[{"name":"beego","slug":"beego","permalink":"http://peapod.top/tags/beego/"}],"author":"taweizhong"},{"title":"BeeGo教程","slug":"BeeGo教程","date":"2022-09-13T08:36:10.000Z","updated":"2022-09-13T12:42:54.924Z","comments":true,"path":"2022/09/13/BeeGo教程/","link":"","permalink":"http://peapod.top/2022/09/13/BeeGo%E6%95%99%E7%A8%8B/","excerpt":"","text":"Beego 框架1.beego框架 工作流程beego框架是一个使用Go语言快速开发API、Web及后端服务等各种应用的MVC框架。beego是一个完整的MVC框架，包括controller、model以及view等MVC必备模板。 HTTP请求从main函数进入框架 解析url路由，确定执行那个控制器 执行前请求过滤器 执行控制器 执行请求后的过滤器 输出结果 2.beego框架 安装 设置代理 12$ go env -w GO111MODULE=on$ go env -w GOPROXY=https://goproxy.cn,direct 安装beego和bee（项目工具） 1$ go get github.com/beego/beego 使用bee创建项目 1bee new 项目名称 项目结构 运行项目 1bee run 3.框架使用使用beego开发go语言项目，需要编写控制器、业务模型以及view等模块。 控制器controller 1234567891011121314// 定义一个控制器结构体// 一般一个模块定义一个控制器type MainController struct &#123; beego.Controller&#125;// 覆盖beego.Controller的Get方法，用于处理 RESTful 请求中的 get 请求// beego.Controller 默认支持多种 RESTful方法，例如：Post、Put、Delete等func (c *MainController) Get() &#123; // Data是继承过来的属性，是 map 类型，可以保存任意类型数据，主要用于保存请求响应数据 c.Data[&quot;Website&quot;] = &quot;&quot; c.Data[&quot;Email&quot;] = &quot;&quot; // 设置需要渲染的模板文件，框架会去 views 目录查找这个模板文件 c.TplName = &quot;index.html&quot;&#125; 设置路由Url 123456func init() &#123; // 使用 beego.Router 函数，注册路由规则。 // 第一个参数是url路由，第二个参数是控制器 // 这里的意思就是将访问 / 这个url的请求，交给controllers.MainController控制器处理。 beego.Router(&quot;/&quot;, &amp;controllers.MainController&#123;&#125;)&#125; 路由规则说明： ​ 只是定义了Url 由哪个控制器执行，但是没有说明 Url 请求由控制器的那个函数执行，一个控制器可以包含多个函数。 编写model业务逻辑 定义表结构 123456CREATE TABLE `users` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;自增ID&#x27;, `username` varchar(30) NOT NULL COMMENT &#x27;账号&#x27;, `password` varchar(100) NOT NULL COMMENT &#x27;密码&#x27;, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 初始化数据库连接 1234567891011121314151617181920212223package mainimport ( _ &quot;codebaoku/routers&quot; &quot;github.com/astaxie/beego&quot; &quot;github.com/astaxie/beego/orm&quot; _ &quot;github.com/go-sql-driver/mysql&quot;)func init() &#123; // 这里注册一个default默认数据库，数据库驱动是mysql. // 第三个参数是数据库dsn, 配置数据库的账号密码，数据库名等参数 // dsn参数说明： // username - mysql账号 // password - mysql密码 // db_name - 数据库名 // 127.0.0.1:3306 - 数据库的地址和端口 orm.RegisterDataBase(&quot;default&quot;, &quot;mysql&quot;, &quot;username:password@tcp(主机IP:端口号)/db_name?charset=utf8&quot;)&#125;func main() &#123; beego.Run()&#125; 创建model 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 定义User模型，绑定users表结构, 其实就是用来保存sql查询结果。type User struct &#123; Id int Username string Password string&#125;// 定义User 模型绑定那个表？func (u *User) TableName() string &#123; // 返回mysql表名 return &quot;users&quot;&#125;//初始化函数，可以用来向orm注册modelfunc init() &#123; // 向orm注册user模型 orm.RegisterModel(&amp;User&#123;&#125;)&#125;//初始化函数，可以用来向orm注册modelfunc init() &#123; // 向orm注册user模型 orm.RegisterModel(&amp;User&#123;&#125;)&#125;// 根据id查询用户信息func GetUserById(id int) *User &#123; if id == 0 &#123; return nil &#125; // 创建orm对象, 后面都是通过orm对象操作数据库 o := orm.NewOrm() // 初始化一个User模型对象 user := User&#123;&#125; // 设置查询参数 user.Id = id // 调用Read方法，根据user设置的参数，查询一条记录，结果保存到user结构体变量中 // 默认是根据主键进行查询 // 等价sql： SELECT `id`, `username`, `password` FROM `users` WHERE `id` = 1 err := o.Read(&amp;user) // 检测查询结果， if err == orm.ErrNoRows &#123; // 找不到记录 return nil &#125; else if err == orm.ErrMissPK &#123; // 找不到住建 return nil &#125; return &amp;user&#125; 控制器调用model 12345678910111213func (c *MainController) Get() &#123; c.Data[&quot;Website&quot;] = &quot;codebaoku.com&quot; c.Data[&quot;Email&quot;] = &quot;go@codebaoku.com&quot; // 调用model，查询用户id为1 的用户信息 user := models.GetUserById(1) // 然后将user数据保存到Data中, 将参数传给后面的 views 视图模板处理 c.Data[&quot;user&quot;] = user // 使用新的视图模板user.tpl c.TplName = &quot;user.tpl&quot;&#125; 编写view视图 项目打包 使用 bee 工具打包，bee 工具可以一键将项目需要的相关文件一起打包成一个压缩包，只需要到线上解压即可。 1bee pack 参数配置beego 默认使用了 INI 格式解析配置文件，通常在项目中会存在很多系统参数、业务参数配置，这些参数通常都是通过配置文件进行配置，而且不是写死在代码里面。 提示：修改配置文件后，需要重启应用，配置才生效，即使使用bee run运行项目也得重启。 系统参数 1234567# 这是注释#应用名称appname = codebaoku#http 服务端口httpport = 8080#运行模式，常用的运行模式有dev, test, prodrunmode = dev 参数名 默认值 说明 AppName beego 应用名 RunMode dev 程序运行模式，常用模式有dev、test、prod，一般用于区分不同的运行环境 RouterCaseSensitive true 是否路由忽略大小写匹配 ServerName beego beego 服务器默认在请求的时候输出 server 头的值。 RecoverPanic true 是否异常恢复，默认值为 true，即当应用出现异常的情况，通过 recover 恢复回来，而不会导致应用异常退出。 EnableGzip false 是否开启 gzip 支持 MaxMemory 64M 文件上传默认内存缓存大小，单位是字节 AutoRender true 是否模板自动渲染，对于 API 类型的应用，应用需要把该选项设置为 false，不需要渲染模板。 StaticDir static 静态文件目录设置 ViewsPath views 模板路径 Graceful false 是否开启热升级，默认是 false，关闭热升级。 ServerTimeOut 0 设置 HTTP 的超时时间，默认是 0，不超时。 HTTPAddr 应用监听地址，默认为空，监听所有的网卡 IP。 HTTPPort 8080 应用监听端口 EnableHTTPS false 是否启用 HTTPS，默认是 false 关闭。当需要启用时，先设置 EnableHTTPS &#x3D; true，并设置 HTTPSCertFile 和 HTTPSKeyFile HTTPSAddr https应用监听地址，默认为空，监听所有的网卡 IP。 HTTPSPort 10443 https应用监听端口 HTTPSCertFile 开启 HTTPS 后，ssl 证书路径 HTTPSKeyFile 开启 HTTPS 之后，SSL 证书 keyfile 的路径。 EnableAdmin false 是否开启进程内监控模块，默认 false 关闭。 AdminAddr localhost 监控程序监听的地址。 AdminPort 8088 监控程序监听的地址。 SessionOn false session 是否开启 SessionProvider memory session 的引擎， 详情参考session章节的教程 SessionName beegosessionID 存在客户端的 cookie 名称。 SessionGCMaxLifetime 3600 session 过期时间, 单位秒。 SessionProviderConfig 配置信息，根据不同的session引擎设置不同的配置信息，详细的配置请参考session章节的教程 SessionCookieLifeTime 3600 session 默认存在客户端的 cookie 的时间, 单位秒。 SessionDomain session cookie 存储域名。 自定义参数 可以自定义配置，然后通过beego.AppConfig对象的函数读取配置。 12345# 下面是关于mysql数据库的配置参数mysql_user = &quot;root&quot;mysql_password = &quot;123456&quot;mysql_host = &quot;127.0.0.1:3306&quot;mysql_dbname = &quot;codebaoku&quot; 读取配置代码: 1234beego.AppConfig.String(&quot;mysql_user&quot;)beego.AppConfig.String(&quot;mysql_password&quot;)beego.AppConfig.String(&quot;mysql_host&quot;)beego.AppConfig.String(&quot;mysql_dbname&quot;)","categories":[{"name":"Web","slug":"Web","permalink":"http://peapod.top/categories/Web/"}],"tags":[{"name":"beego","slug":"beego","permalink":"http://peapod.top/tags/beego/"}],"author":"taweizhong"},{"title":"匿名函数用作回调函数","slug":"匿名函数用作回调函数","date":"2022-09-09T07:32:30.000Z","updated":"2022-09-13T09:11:55.023Z","comments":true,"path":"2022/09/09/匿名函数用作回调函数/","link":"","permalink":"http://peapod.top/2022/09/09/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E7%94%A8%E4%BD%9C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/","excerpt":"","text":"匿名函数用作回调函数123456789101112131415package mainimport &quot;fmt&quot;func fun(list []int, f func(int))&#123; for _, v := range list &#123; f(v) &#125;&#125;func main() &#123; fun([]int&#123;1, 2, 3, 4, 5&#125;, func(n int) &#123; fmt.Printf(&quot;n: %v\\n&quot;, n) &#125;)&#125; 先执行fun()函数 在执行f(v)的时候回调 传值的匿名函数。会将参数v的值传递给匿名函数的形参，在你匿名函数实现打印。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://peapod.top/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://peapod.top/tags/Go/"}],"author":"taweizhong"},{"title":"Go设计模式","slug":"go工厂模式","date":"2022-09-09T00:54:08.000Z","updated":"2022-09-11T00:43:55.928Z","comments":true,"path":"2022/09/09/go工厂模式/","link":"","permalink":"http://peapod.top/2022/09/09/go%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"Go 设计模式工厂设计模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package maintype an interface&#123; eat() call()&#125;type cat struct&#123; name string&#125;type dog struct&#123; name string&#125;func (*cat)eat()&#123; fmt.Println(&quot;cat eat&quot;)&#125;func (*cat)call()&#123; fmt.Println(&quot;cat call&quot;)&#125;func (*dog)eat()&#123; fmt.Println(&quot;dog eat&quot;)&#125;func (*dog)call()&#123; fmt.Println(&quot;dog call&quot;)&#125;func fun(i int) an &#123; if i == 1 &#123; return &amp;cat&#123;&#125; &#125; else &#123; return &amp;dog&#123;&#125; &#125;&#125;// 多态 向上转型func main()&#123; cat := fun(1) cat.eat() cat.call() dog := fun(2) dog.eat() dog.call()&#125;``` &gt; 将实现接口的对象赋值与接口变量### 单例设计模式 一个类只有一个对象实例```gopackage mainimport ( &quot;fmt&quot; &quot;sync&quot;)type Sing interface &#123; do()&#125;type some struct &#123;&#125;func (*some) do() &#123; fmt.Println(&quot;do some&quot;)&#125;var ( once sync.Once s *some)func Fun() Sing &#123; once.Do( func() &#123; s = &amp;some&#123;&#125; &#125;, ) return s&#125;func main() &#123; s1 := Fun() fmt.Printf(&quot;s1: %p\\n&quot;, s1) s2 := Fun() fmt.Printf(&quot;s1: %p\\n&quot;, s2)&#125; 抽象工厂模式构建者模式","categories":[{"name":"笔记","slug":"笔记","permalink":"http://peapod.top/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://peapod.top/tags/Go/"}],"author":"taweizhong"},{"title":"部署测试","slug":"部署测试","date":"2022-09-08T12:21:54.000Z","updated":"2022-09-08T12:46:47.021Z","comments":true,"path":"2022/09/08/部署测试/","link":"","permalink":"http://peapod.top/2022/09/08/%E9%83%A8%E7%BD%B2%E6%B5%8B%E8%AF%95/","excerpt":"","text":"这是一个测试文件","categories":[],"tags":[{"name":"测试","slug":"测试","permalink":"http://peapod.top/tags/%E6%B5%8B%E8%AF%95/"}],"author":"taweizhong"},{"title":"Hello World","slug":"hello-world","date":"2022-09-08T07:58:15.170Z","updated":"2022-09-08T07:27:56.128Z","comments":true,"path":"2022/09/08/hello-world/","link":"","permalink":"http://peapod.top/2022/09/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"说明","slug":"说明","permalink":"http://peapod.top/categories/%E8%AF%B4%E6%98%8E/"}],"tags":[{"name":"说明","slug":"说明","permalink":"http://peapod.top/tags/%E8%AF%B4%E6%98%8E/"}],"author":"taweizhong"},{"title":"Gin访问静态文件和模板文件","slug":"Gin访问静态文件和模板文件","date":"2022-09-05T03:26:27.000Z","updated":"2022-09-07T03:47:52.000Z","comments":true,"path":"2022/09/05/Gin访问静态文件和模板文件/","link":"","permalink":"http://peapod.top/2022/09/05/Gin%E8%AE%BF%E9%97%AE%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E5%92%8C%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6/","excerpt":"","text":"Gin访问静态文件和模板文件1234567891011121314151617181920212223package mainimport ( &quot;github.com/gin-gonic/gin&quot;)func gologin(c *gin.Context)&#123; c.HTML(200, &quot;login.html&quot;, nil)&#125;func login(c *gin.Context)&#123; username := c.PostForm(&quot;username&quot;) password := c.PostForm(&quot;password&quot;) c.HTML(200, &quot;index.html&quot;, gin.H&#123; &quot;username&quot;: username, &quot;password&quot;: password, &#125;)&#125;func main()&#123; e := gin.Default() e.Static(&quot;/assets&quot;, &quot;./assets&quot;) e.LoadHTMLGlob(&quot;tempates/*&quot;) e.GET(&quot;/login&quot;, gologin) e.POST(&quot;/login&quot;, login) e.Run()&#125; e.Static(&quot;/assets&quot;, &quot;./assets&quot;)读取css和js等静态文件 e.LoadHTMLGlob(&quot;tempates/*&quot;)读取html等模板文件","categories":[{"name":"Web","slug":"Web","permalink":"http://peapod.top/categories/Web/"}],"tags":[{"name":"Gin","slug":"Gin","permalink":"http://peapod.top/tags/Gin/"}],"author":"taweizhong"},{"title":"Gin数据绑定","slug":"Gin数据绑定","date":"2022-09-05T03:26:14.000Z","updated":"2022-09-07T03:49:06.000Z","comments":true,"path":"2022/09/05/Gin数据绑定/","link":"","permalink":"http://peapod.top/2022/09/05/Gin%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/","excerpt":"","text":"Gin数据绑定POST和GET参数绑定123456789101112131415161718192021package mainimport &quot;github.com/gin-gonic/gin&quot;type User struct&#123; Uaername string `form:&quot;username&quot;` Password string `form:&quot;password&quot;`&#125;func login(c *gin.Context)&#123; var user User c.ShouldBind(&amp;user) // form表单绑定结构体 c.String(200, &quot;User:%s&quot;, user)&#125;func main() &#123; e := gin.Default() // localhost:8080/login?username=taweizhong&amp;password=111 可以绑定查询参数 e.POST(&quot;/login&quot;, login) e.Run()&#125; 路径绑定123456789101112131415161718192021package mainimport ( &quot;github.com/gin-gonic/gin&quot;)type User struct&#123; Uaername string `uri:&quot;username&quot;` Password string `uri:&quot;password&quot;`&#125;func login(c *gin.Context)&#123; var user User c.ShouldBindUri(&amp;user) c.String(200, &quot;User:%s&quot;, user)&#125;func main()&#123; e := gin.Default() // localhost:8080/login/taweizhong/111 e.GET(&quot;/login/:username/:password&quot;, login) e.Run()&#125;","categories":[{"name":"Web","slug":"Web","permalink":"http://peapod.top/categories/Web/"}],"tags":[{"name":"Gin","slug":"Gin","permalink":"http://peapod.top/tags/Gin/"}],"author":"taweizhong"},{"title":"Gin获取请求参数","slug":"Gin获取请求参数","date":"2022-09-05T03:25:57.000Z","updated":"2022-09-07T03:48:40.000Z","comments":true,"path":"2022/09/05/Gin获取请求参数/","link":"","permalink":"http://peapod.top/2022/09/05/Gin%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0/","excerpt":"","text":"Gin获取请求参数GET请求参数12345678910111213141516package mainimport ( &quot;github.com/gin-gonic/gin&quot;)func login(c *gin.Context)&#123; key := c.Query(&quot;wd&quot;) // value := c.DefaultQuery(&quot;wd&quot;, &quot;世界&quot;) 查询不到用默认值 c.String(200, key)&#125;func main()&#123; e := gin.Default() e.GET(&quot;/login&quot;, login) e.Run()&#125; POST请求参数12345func fun(c *gin.Context)&#123; username := c.PostForm(&quot;username&quot;) password := c.DefaultPostForm(&quot;password&quot;) // 查询不到用默认值 c.String(200, username)&#125; 路径参数12345678910111213141516package mainimport ( &quot;github.com/gin-gonic/gin&quot;)func login(c *gin.Context)&#123; s := c.Param(&quot;username&quot;) c.String(200, s)&#125;func main()&#123; e := gin.Default() // localhost:8080/login/taweizhong e.GET(&quot;/login/:username&quot;, login) e.Run()&#125;","categories":[{"name":"Web","slug":"Web","permalink":"http://peapod.top/categories/Web/"}],"tags":[{"name":"Gin","slug":"Gin","permalink":"http://peapod.top/tags/Gin/"}],"author":"taweizhong"},{"title":"Gin处理form表单","slug":"Gin处理form表单","date":"2022-09-05T03:25:22.000Z","updated":"2022-09-08T11:15:34.784Z","comments":true,"path":"2022/09/05/Gin处理form表单/","link":"","permalink":"http://peapod.top/2022/09/05/Gin%E5%A4%84%E7%90%86form%E8%A1%A8%E5%8D%95/","excerpt":"","text":"Gin处理form表单go程序1234567891011121314151617181920212223package mainimport ( &quot;github.com/gin-gonic/gin&quot;)func gologin(c *gin.Context)&#123; c.HTML(200, &quot;login.html&quot;, nil)&#125;func login(c *gin.Context)&#123; username := c.PostForm(&quot;username&quot;) password := c.PostForm(&quot;password&quot;) c.HTML(200, &quot;index.html&quot;, gin.H&#123; &quot;username&quot;: username, &quot;password&quot;: password, &#125;)&#125;func main()&#123; e := gin.Default() e.Static(&quot;assets&quot;, &quot;./assets&quot;) e.LoadHTMLGlob(&quot;tempates/*&quot;) e.GET(&quot;/login&quot;, gologin) e.POST(&quot;/login&quot;, login) e.Run()&#125; index.html1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;主页&lt;/h1&gt; &#123;&#123;.name&#125;&#125; &#123;&#123;.password&#125;&#125;&lt;/body&gt;&lt;/html&gt; login.html123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./assets/css/login.css&quot;&gt; &lt;title&gt;login&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;form-container&quot;&gt; &lt;div class=&quot;formleft&quot;&gt; &lt;img src=&quot;./assets/img/touxiang.png&quot;&gt; &lt;/div&gt; &lt;div class=&quot;formright&quot;&gt; &lt;h1&gt;欢迎回来&lt;/h1&gt; &lt;p class=&quot;py-1&quot;&gt;请先登录&lt;/p&gt; &lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt; &lt;label&gt; &lt;p&gt;用户名&lt;/p&gt; &lt;input type=&quot;text&quot; name=&quot;user&quot; class=&quot;user-input&quot;&gt; &lt;/label&gt; &lt;label&gt; &lt;p&gt;密码&lt;/p&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; class=&quot;pw-input&quot;&gt; &lt;/label&gt; &lt;button class=&quot;login&quot; type=&quot;submit&quot;&gt;登录&lt;/button&gt; &lt;/form&gt; &lt;a href=&quot;./register&quot;&gt;&lt;button class=&quot;qiehuan&quot; type=&quot;submit&quot;&gt;注册&lt;/button&gt;&lt;/button&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 当有多选框时，使用c.PostFormArray(&quot;name&quot;)函数得到参数数组。","categories":[{"name":"Web","slug":"Web","permalink":"http://peapod.top/categories/Web/"}],"tags":[{"name":"Gin","slug":"Gin","permalink":"http://peapod.top/tags/Gin/"}],"author":"taweizhong"},{"title":"css简介","slug":"css简介","date":"2022-08-27T07:48:03.000Z","updated":"2022-09-08T12:00:56.846Z","comments":true,"path":"2022/08/27/css简介/","link":"","permalink":"http://peapod.top/2022/08/27/css%E7%AE%80%E4%BB%8B/","excerpt":"","text":"css简介CSS 是“Cascading Style Sheet”的缩写，中文意思为“层叠样式表”，它是一种标准的样式表语言，用于描述网页的表现形式（例如网页元素的位置、大小、颜色等）。 CSS 的主要作用是定义网页的样式（美化网页），对网页中元素的位置、字体、颜色、背景等属性进行精确控制。 css特点在网页中实现各式各样的效果，例如： 为任何元素设置不同的边框，以及边框与元素之间的内外间距； 改变文字的大小、颜色、字体，为文字添加修饰（例如下划线、删除线）； 为网页设置背景颜色或者背景图片等等。 可以对同一个 HTML 元素多次定义 CSS 样式，后面定义的样式会覆盖前面定义的样式。 css语法规则CSS 样式规则由三个部分组成，分别是选择器、属性和值： 选择器：由 HTML 元素的 id、class 属性或元素名本身以及一些特殊符号构成，用来指定要为哪个 HTML 元素定义样式，例如选择器p就表示为页面中的所有&lt;p&gt;标签定义样式； 属性：给 HTML 元素设置的样式名称，由一系列关键词组成，例如 color（颜色）、border（边框）、font（字体）等，CSS 中提供了众多属性，您可以通过 W3C 官网查看； 值：由数值和单位或者关键字组成，用来控制某个属性的显示效果，例如 color 属性的值可以是 red 或 #F1F1F1 等。 在 CSS 的语法规则中，属性和值之间需要使用冒号:进行分隔，每个属性和值的组合可以看作一个声明，每个声明的末尾都需要使用分号;作为结尾，属于同一选择器的声明需要使用花括号&#123; &#125;包裹起来。","categories":[{"name":"前端","slug":"前端","permalink":"http://peapod.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"css","slug":"css","permalink":"http://peapod.top/tags/css/"}],"author":"taweizhong"},{"title":"vim常用命令","slug":"vim常用命令","date":"2022-08-27T04:23:00.000Z","updated":"2022-09-07T03:51:28.000Z","comments":true,"path":"2022/08/27/vim常用命令/","link":"","permalink":"http://peapod.top/2022/08/27/vim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"vim常用命令命令模式 快捷键 功能描述 gg 光标移动到文档首行 G 光标移动到文档尾行 ctrl+b或pageUp键 翻屏操作，向上翻 ctrl+f或pageDn键 翻屏操作，向下翻 数字+G 快速将光标移动到指定行 shift+6 光标移动到行首 shift+4 光标移动到行尾 数字+上下方向键 以当前光标为准，向上&#x2F;下移动n行 数字+左右方向键 以当前光标为准，向左&#x2F;右移动n个字符 ctrl+v + 方向键+yy ctrl+v，并按方向键选中区块，按下yy复制 p 将剪贴板中的内容粘贴到光标后 dd 删除光标所在行，删除之后，下一行上移 D 删除光标位置到行尾的内容，删除之后，下一行不上移 :a1,a2d 删除从 a1 行到 a2 行的文本内容 u 撤销 ctrl+r 恢复 末行模式 命令 功能描述 :wq 保存并退出 Vim 编辑器 :wq! 保存并强制退出 Vim 编辑器 :q 不保存就退出 Vim 编辑器 :q! 不保存，且强制退出 Vim 编辑器 &#x2F;abc 从光标所在位置向前查找字符串 abc &#x2F;^abc 查找以 abc 为行首的行 &#x2F;abc$ 查找以 abc 为行尾的行 ?abc 从光标所在位置向后查找字符串 abc : set nu 行号显示 : syntax on&#x2F;off 代码颜色显示 更多点击查看更多","categories":[{"name":"实用","slug":"实用","permalink":"http://peapod.top/categories/%E5%AE%9E%E7%94%A8/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://peapod.top/tags/vim/"}],"author":"taweizhong"},{"title":"HTML标签","slug":"HTML标签","date":"2022-08-27T03:19:09.000Z","updated":"2022-09-08T07:19:28.016Z","comments":true,"path":"2022/08/27/HTML标签/","link":"","permalink":"http://peapod.top/2022/08/27/HTML%E6%A0%87%E7%AD%BE/","excerpt":"","text":"HTML标签标题标签HTML 中提供了从&lt;h1&gt;到&lt;h6&gt;六个级别的标题标签，&lt;h1&gt;标签的级别最高，&lt;h6&gt;标签的级别最低，通过这些标签可以定义网页中的标题（与 word 中的标题类似），合理使用标题可以使网页的层次结构更加清晰。 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;mate charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;h1 标题&lt;/h1&gt; &lt;h2&gt;h2 标题&lt;/h2&gt; &lt;h3&gt;h3 标题&lt;/h3&gt; &lt;h4&gt;h4 标题&lt;/h4&gt; &lt;h5&gt;h5 标题&lt;/h5&gt; &lt;h6&gt;h6 标题&lt;/h6&gt;&lt;/body&gt;&lt;/html&gt; 段落标签HTML 中可以使用段落标签 &lt;p&gt;来将文档中的内容分割为若干个段落。 1&lt;p&gt;段落中的内容。&lt;/p&gt; 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;mate charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;这是一个段落。&lt;a href=&quot;http://43.138.70.17:4000/&quot; target=&quot;_blank&quot;&gt;这是一个链接&lt;/a&gt;&lt;/p&gt; &lt;p&gt;这是第二个标签&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 超链接标签 标签的语法格式如下： 1&lt;a href=&quot;&quot; target=&quot;_blank&quot;&gt;这是一个链接&lt;/a&gt; href 属性指定链接的目标，也就是要跳转到什么位置。 target 是可选属性，用来指明新页面的打开方式。 属性值 说明 _self 默认，在现有窗口中打开新页面，原窗口将被覆盖。 _blank 在新窗口中打开新页面，原窗口将被保留。 _parent 在当前框架的上一层打开新页面。 _top 在顶层框架中打开新页面。 &lt;img标签&gt; 标签的语法格式如下： 1&lt;img src=&quot;url&quot; alt=&quot;text&quot;&gt; src 是必选属性，它是 source 的简称，用来指明图片的地址或者路径。 alt 是可选属性，用来定义图片的文字描述信息。 使用 width 和 height 属性来指定图片的宽度和高度。 12&lt;img src=&quot;./html5.png&quot; alt=&quot;HTML5 Logo&quot; width=&quot;100&quot; height=&quot;100&quot;&gt;&lt;img src=&quot;./html5.png&quot; alt=&quot;HTML5 Logo&quot; style=&quot;width: 150px; height: 150px;&quot;&gt; 表格标签12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;mate charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;table&gt; &lt;caption&gt;这是表格的标题&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;name &lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;taweizhong &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 列表标签有序列表12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;HTML有序列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;煮米饭的步骤：&lt;/p&gt; &lt;ol&gt; &lt;li&gt;将水煮沸&lt;/li&gt; &lt;li&gt;加入一勺米&lt;/li&gt; &lt;li&gt;搅拌均匀&lt;/li&gt; &lt;li&gt;继续煮10分钟&lt;/li&gt; &lt;/ol&gt;&lt;/body&gt;&lt;/html&gt; 无序列表12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;HTML无序列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;早餐的种类：&lt;/p&gt; &lt;ul&gt; &lt;li&gt;鸡蛋&lt;/li&gt; &lt;li&gt;牛奶&lt;/li&gt; &lt;li&gt;面包&lt;/li&gt; &lt;li&gt;生菜&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 定义列表12345678&lt;dl&gt; &lt;dt&gt;标题1&lt;dt&gt; &lt;dd&gt;描述文本2&lt;dd&gt; &lt;dt&gt;标题2&lt;dt&gt; &lt;dd&gt;描述文本2&lt;dd&gt; &lt;dt&gt;标题3&lt;dt&gt; &lt;dd&gt;描述文本3&lt;dd&gt;&lt;/dl&gt; 表单标签表单可以接收用户输入的信息，然后将其发送到后端应用程序。 语法如下所示： 123&lt;form action=&quot;URL&quot; method=&quot;GET|POST&quot;&gt; 表单中的其它标签&lt;/form&gt; action 属性用来指明将表单提交到哪个页面。 method 属性表示使用哪个方式提交数据，包括 GET 和 POST 两种方式。 表单属性 属性 可选值 描述 accept MIME_type HTML5 中不再支持，设置服务器要接收的文件类型 accept-charset character_set 设置表单数据的字符集（默认为 HTML 文档字符集） action URL 设置要将表单提交到何处（默认为当前页面） autocomplete on、off 设置是否启用表单的自动完成功能（默认开启） enctype application&#x2F;x-www-form-urlencoded、 multipart&#x2F;form-data、 text&#x2F;plain 设置在提交表单数据之前如何对数据进行编码（适用于 method&#x3D;”post” 的情况） method get、post 设置使用哪种 HTTP 方法来提交表单数据（默认为 get） name text 设置表单的名称 novalidate novalidate 如果使用该属性，则提交表单时不进行验证 target _blank、_self、_parent、_top 设置在何处打开 action 属性设定的链接（默认为 _self） 表单控件 控件&#x2F;标签 描述 &lt;input&gt; 定义输入框 &lt;textarea&gt; 定义文本域（一个可以输入多行文本的控件） &lt;label&gt; 为表单中的各个控件定义标题 &lt;fieldset&gt; 定义一组相关的表单元素，并使用边框包裹起来 &lt;legend&gt; 定义 &lt;fieldset&gt; 元素的标题 &lt;select&gt; 定义下拉列表 &lt;optgroup&gt; 定义选项组 &lt;option&gt; 定义下拉列表中的选项 &lt;button&gt; 定义一个可以点击的按钮 &lt;datalist&gt; 指定一个预先定义的输入控件选项列表 &lt;keygen&gt; 定义表单的密钥对生成器字段 &lt;output&gt; 定义一个计算结果 &amp;emsp HTML空格 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;HTML form表单演示&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;./userinfo.php&quot; method=&quot;POST&quot;&gt; &lt;!-- 文本输入框控件 --&gt; &lt;label&gt;用户名： &lt;/label&gt;&lt;input name=&quot;username&quot; type=&quot;text&quot;&gt;&lt;br&gt; &lt;!-- 密码框控件 --&gt; &lt;label&gt;密&amp;emsp;码： &lt;/label&gt;&lt;input name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;br&gt; &lt;!-- 下拉菜单控件 --&gt; &lt;label&gt;性&amp;emsp;别：&lt;/label&gt; &lt;select name=&quot;sex&quot;&gt; &lt;option value=&quot;1&quot;&gt;男&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;女&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;未知&lt;/option&gt; &lt;/select&gt; &lt;br&gt; &lt;!-- 复选框控件 --&gt; &lt;label&gt;爱&amp;emsp;好：&lt;/label&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;1&quot;&gt;听音乐 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;2&quot;&gt;看电影 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;3&quot;&gt;打游戏 &lt;br&gt; &lt;!-- 单选按钮控件 --&gt; &lt;label&gt;学&amp;emsp;历：&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;education&quot; value=&quot;1&quot;&gt;小学 &lt;input type=&quot;radio&quot; name=&quot;education&quot; value=&quot;2&quot;&gt;中学 &lt;input type=&quot;radio&quot; name=&quot;education&quot; value=&quot;3&quot;&gt;本科 &lt;input type=&quot;radio&quot; name=&quot;education&quot; value=&quot;4&quot;&gt;硕士 &lt;input type=&quot;radio&quot; name=&quot;education&quot; value=&quot;5&quot;&gt;博士 &lt;br&gt; &lt;!-- 按钮 --&gt; &lt;input type=&quot;submit&quot; value=&quot;提 交&quot;&gt;&amp;emsp;&amp;emsp; &lt;input type=&quot;reset&quot; value=&quot;重 置&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 块级元素和内联元素块级元素块级元素最主要的特点是它们自己独占一行，块级元素中最具代表性的就是&lt;div&gt;，此外还有&lt;p&gt;、&lt;nav&gt;、&lt;aside&gt;、&lt;header&gt;、&lt;footer&gt;、&lt;section&gt;、&lt;article&gt;、&lt;ul&gt;、&lt;address&gt;、&lt;h1&gt;~&#96;&#96;等。 主要特征如下所示： 块级元素总是在新行上开始； 宽度、高度以及外边距和内边距等都可以控制； 省略块级元素的宽度，那么它的宽度默认为当前浏览器窗口的宽度； 包含其它的内联元素和块级元素。 内联元素内联元素也可以称为行内元素，行内元素中最常用的是&lt;span&gt;，此外还有&lt;b&gt;、&lt;i&gt;、&lt;u&gt;。 主要特征如下所示： 和其他元素会在同一行上显示； 宽、高以及外边距和内边距都不可以改变； 宽度就是其中内容的宽度，且不可以改变； 只能容纳文本或者其他内联元素。 可以通过 line-height 来设置行高； 可以设置 margin 外边距，但只对左右外边距有效，上下无效； 设置 padding 内边距时，只有左右 padding 有效，上下则无效 标签&lt;div&gt;&lt;div&gt;是非常重要的块级标记，在网页布局（Layout）方面发挥着重要的作用，使用&lt;div&gt;我们可以定义页面的各个部分，通过与 CSS 相结合可以实现各种各样的效果。 &lt;div&gt; 标签及其包围的内容可以看做网页的一个板块， 标签本身并没有什么特殊的显示效果，需要借助 CSS 样式对外边距、内边距、背景、边框等进行设置，从而达到对板块布局的目的。 &lt;span&gt;标签HTML 中的&lt;span&gt;标签是一个内联元素，可以对 HTML 文档中的内容进行修饰，此标签不会为文档内容提供任何视觉效果，但可以与 CSS 结合使用来美化网页。 布局HTML5 提出了多个专门用于布局的标签，它们用来定义网页的不同部分，语义更加明确。 标签 说明 &lt;header&gt; 用于定义网页的头部，头部中一般包含一些介绍性的内容，例如网站名称、logo 或者作者的信息。 &lt;nav&gt; 用于定义网页中的导航栏。 &lt;section&gt; 用于在网页中定义一个单独的部分，其中可以包含文本、图像、表格等等。 &lt;section&gt; 代表 HTML 文档中的“节”或“段”，“段”可以理解为一篇文章里按照主题的分段，“节”则可以理解为一个页面里的分组。其主要作用就是对页面的内容进行分块或者对文章的内容进行分段。 &lt;article&gt; 用于定义文章或者其它独立的信息，代表一个页面中自成一体的内容，例如论坛的帖子、博客上的文章、一篇用户的评论等。 &lt;aside&gt; 用于定义网页内容以外的部分，例如网页的侧边栏。 &lt;footer&gt; 用于定义网页的底部，例如作者、版权等信息。 &lt;details&gt; 用于定义一些详细信息，并且可以根据需要隐藏或显示这些详细信息。 &lt;summary&gt; 用于为&lt;details&gt;标签定义标题。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://peapod.top/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://peapod.top/tags/HTML/"}],"author":"taweizhong"},{"title":"HTML标签的属性","slug":"HTML标签的属性","date":"2022-08-26T10:59:55.000Z","updated":"2022-09-08T07:20:47.185Z","comments":true,"path":"2022/08/26/HTML标签的属性/","link":"","permalink":"http://peapod.top/2022/08/26/HTML%E6%A0%87%E7%AD%BE%E7%9A%84%E5%B1%9E%E6%80%A7/","excerpt":"","text":"HTML属性属性包含了标签的额外信息，例如： href 属性可以为 标签提供链接地址； src 属性可以为 标签提供图像的路径； style 属性可以为几乎所有标签定义 CSS 样式。 属性需要添加在开始标签中，语法格式为： 12attr=&quot;value&quot;attr 表示属性名，value 表示属性值。属性值必须使用双引号&quot; &quot;或者单引号&#x27; &#x27;包围。 说明： 标签中的 src 属性用来定义图像的路径，alt 属性用来定义图像的描述信息，当图像出现异常无法正常显示时就会显示 alt 中的信息。 标签的 href 属性用来定义链接的地址，target 属性用来定义新页面在浏览器中的打开方式。 通用属性1) idid 属性用来赋予某个标签唯一的名称（标识符），当我们使用 CSS 或者 JavaScript 来操作这个标签时，就可以通过 id 属性来找到这个标签。 2) class与 id 属性类似，class 属性也可以为标签定义名称（标识符），不同的是 class 属性在整个 HTML 文档中不必是唯一的，我们可以为多个标签定义相同的 class 属性值。另外，还可以为一个 HTML 标签定义多个 class 属性值。 3) titletitle 属性用来对标签内容进行描述说明，当鼠标移动到该标签上方时会显示出 title 属性的值。 4) style使用 style 属性我们可以在 HTML 标签内部为标签定义 CSS 样式","categories":[{"name":"笔记","slug":"笔记","permalink":"http://peapod.top/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://peapod.top/tags/HTML/"}],"author":"taweizhong"},{"title":"HTML标签的语法格式","slug":"HTML标签的语法格式","date":"2022-08-26T10:59:38.000Z","updated":"2022-09-08T07:22:20.069Z","comments":true,"path":"2022/08/26/HTML标签的语法格式/","link":"","permalink":"http://peapod.top/2022/08/26/HTML%E6%A0%87%E7%AD%BE%E7%9A%84%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F/","excerpt":"","text":"标签的语法格式一个 HTML 标签由开始标签、属性、内容和结束标签组成，标签的名称不区分大小写。 注意： 所有 HTML 标签都必须放在尖括号&lt; &gt;内； HTML 中不同的标签可以实现不同的效果； 如果使用了某个标签，则必须使用对应的结束标签来结尾（自闭和标签除外）。 自闭和标签12345&lt;img src=&quot;&quot; alt=&quot;&quot; /&gt;&lt;hr /&gt;&lt;br /&gt;&lt;input type=&quot;text&quot; /&gt;&lt;!-- --&gt; 表示 HTML 注释","categories":[{"name":"笔记","slug":"笔记","permalink":"http://peapod.top/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://peapod.top/tags/HTML/"}],"author":"taweizhong"},{"title":"HTML简介","slug":"HTML简介","date":"2022-08-26T10:59:12.000Z","updated":"2022-09-08T07:23:19.300Z","comments":true,"path":"2022/08/26/HTML简介/","link":"","permalink":"http://peapod.top/2022/08/26/HTML%E7%AE%80%E4%BB%8B/","excerpt":"","text":"HTML简介HTML 英文全称是 Hyper Text Markup Language，中文译为“超文本标记语言”，专门用来设计和编辑网页。 1) 超文本也即超越纯文本，这意味着 HTML 文档不仅能包含文本（文字），还能包含图片、音视频、表格、列表、链接、按钮、输入框等高级内容。 2) 标记语言HTML 是一种计算机语言，但它不能编程，只能用来标记网页中的内容。HTML 通过不同的标签来标记不同的内容、格式、布局等。 HTML标签HTML 是一种标记语言，使用各种标签来格式化内容，标签的特点如下所示： HTML 标签由尖括号包围的关键词构成，比如 ； 除了少数标签外，大多数 HTML 标签都是成对出现的； 成对出现的标签中，第一个标签称为开始标签，第二个标签称为结束标签（闭合标签）。 HTML文档结构123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;mate charset=&quot;utf8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;&lt;/p&gt; &lt;h1&gt;&lt;/h1&gt; &lt;input type=&quot;text&quot;/&gt; &lt;/body&gt;&lt;/html&gt; 说明： ：该标签是 HTML 页面的根标签，其他所有的标签都需要在 和 标签之间定义； ：该标签中用来定义 HTML 文档的一些信息，例如标题、编码格式等等； ：用来指明当前网页采用 UTF-8 编码，UTF-8 是全球通用的编码格式，绝大多数网页都采用 UTF-8 编码； ：该标签用来定义网页的标题，网页标题会显示在浏览器的标签栏； ：该标签用来定义网页中我们能通过浏览器看到的所有内容，例如段落、标题、图片、链接等等；","categories":[{"name":"笔记","slug":"笔记","permalink":"http://peapod.top/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://peapod.top/tags/HTML/"}]},{"title":"Go函数","slug":"Go函数","date":"2022-08-26T08:31:43.000Z","updated":"2022-09-08T07:38:42.482Z","comments":true,"path":"2022/08/26/Go函数/","link":"","permalink":"http://peapod.top/2022/08/26/Go%E5%87%BD%E6%95%B0/","excerpt":"","text":"第六章：函数简介函数是基本的代码块。函数编写的顺序是无关紧要的，最好把 main() 函数写在文件的前面。 简单的 return 语句也可以用来结束 for 死循环，或者结束一个协程（goroutine）。 Go里面的函数： 普通函数 匿名函数 方法 除了main()、init()函数外，其它所有类型的函数都可以有参数与返回值。 函数参数、返回值以及它们的类型被统称为函数签名。 函数是一等值（first-class value）：它们可以赋值给变量，就像 add := binOp 一样。 函数不能在其它函数里面声明（不能嵌套），不过我们可以通过使用匿名函数 函数参数与返回值函数定义时，它的形参一般是有名字的，不过我们也可以定义没有形参名的函数，只有相应的形参类型，就像这样：func f(int, int, float64)。 在函数调用时，像切片（slice）、字典（map）、接口（interface）、通道（channel）这样的引用类型都是默认使用引用传递（即使没有显式的指出指针）。 命名返回值 命名返回值作为结果形参（result parameters）被初始化为相应类型的零值，当需要返回的时候，我们只需要一条简单的不带参数的return语句。 123456func getX2AndX3_2(input int) (x2 int, x3 int) &#123; x2 = 2 * input x3 = 3 * input // return x2, x3 return&#125; 改变外部变量 传递指针给函数不但可以节省内存（因为没有复制变量的值），而且赋予了函数直接修改外部变量的能力，所以被修改的变量不再需要使用 return 返回。 1234567891011121314package mainimport ( &quot;fmt&quot;)// this function changes reply:func Multiply(a, b int, reply *int) &#123; *reply = a * b&#125;func main() &#123; n := 0 reply := &amp;n Multiply(10, 5, reply) fmt.Println(&quot;Multiply:&quot;, *reply) // Multiply: 50&#125; 变长参数函数的最后一个参数是采用 ...type 的形式，那么这个函数就可以处理一个变长的参数 123456789101112131415161718192021package mainimport &quot;fmt&quot;func main() &#123; x := min(1, 3, 2, 0) fmt.Printf(&quot;The minimum is: %d\\n&quot;, x) slice := []int&#123;7,9,3,5,1&#125; x = min(slice...) fmt.Printf(&quot;The minimum in the slice is: %d&quot;, x)&#125;func min(s ...int) int &#123; if len(s)==0 &#123; return 0 &#125; min := s[0] for _, v := range s &#123; if v &lt; min &#123; min = v &#125; &#125; return min&#125; 变长参数的类型不相同 使用结构体 使用空接口 使用默认的空接口 interface&#123;&#125;，这样就可以接受任何类型的参数 new 和 make 均是用于分配内存：new 用于值类型和用户定义的类型，如自定义结构，make 用于内置引用类型（切片、map 和管道）。 new(T) 分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针 make(T) 返回类型 T 的初始化之后的值，因此它比 new 进行更多的工作。 defer和追踪关键字 defer 允许我们推迟到函数返回之前（或任意位置执行 return 语句之后）一刻才执行某个语句或函数。 123456789101112package mainimport &quot;fmt&quot;func P()&#123; fmt.Print(&quot;P&quot;)&#125;func main()&#123; fmt.Print(&quot;111&quot;) defer P() fmt.Print(&quot;222&quot;)&#125; 当有多个 defer 行为被注册时，它们会以逆序执行 123456789101112package mianimport ( &quot;file&quot;)func main()&#123; //关闭文件 defer file.close() //解锁 mu.Lock() defer mu.Unlock() //关闭数据库连接 defer disconnectFromDB()&#125; 函数作为参数1234567891011package mainimport &quot;fmt&quot;func add(i,j int) int &#123; return i+j&#125;func b(c int, f func (i,j int) int )&#123; return f(c, 2)&#125;func main()&#123; fmt.Print(b(1, add))&#125; 闭包匿名函数的使用 12345678910package mainimport &quot;fmt&quot;func main ()&#123; // 匿名函数 func(i, j int) int &#123;return i+j&#125; // 将匿名函数赋值给变量 变量使用匿名函数 ter := func(i, j int) int &#123;return i+j&#125; ter(2,3) // 匿名函数直接的调用 func(a, b int) int &#123;return a-b&#125; (3, 2)&#125; 函数作为返回值123456789101112package mainimport &quot;fmt&quot;func add(j int) func (i int) int&#123; return func (i int) int&#123; return j +i &#125;&#125;func main()&#123; add(12)&#125; 12345678910111213141516171819package mainimport &quot;fmt&quot;func add() func(i int) int &#123; var x int fmt.Printf(&quot;x: %v\\n&quot;, x) return func(i int) int &#123; x += i return x &#125;&#125;func main() &#123; f := add() fmt.Printf(&quot;f(1): %v\\n&quot;, f(1)) fmt.Printf(&quot;f(2): %v\\n&quot;, f(20))&#125; 闭包函数保存并积累其中的变量的值，不管外部函数退出与否，它都能够继续操作外部函数中的局部变量。 计算函数的执行时间12345678910111213141516171819package mainimport ( &quot;fmt&quot; &quot;time&quot;)func add() &#123; for i := 0; i &lt; 100; i++ &#123; fmt.Printf(&quot;i: %v\\n&quot;, i) &#125;&#125;func main() &#123; start := time.Now() add() end := time.Now() fmt.Print(end.Sub(start))&#125;","categories":[{"name":"笔记","slug":"笔记","permalink":"http://peapod.top/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://peapod.top/tags/Go/"}],"author":"taweizhong"},{"title":"Go控制结构","slug":"Go控制结构","date":"2022-08-26T08:31:25.000Z","updated":"2022-09-08T07:37:14.074Z","comments":true,"path":"2022/08/26/Go控制结构/","link":"","permalink":"http://peapod.top/2022/08/26/Go%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/","excerpt":"","text":"第五章：控制结构if-else结构12345if condition &#123; //&#125; else &#123; //&#125; 当 if 结构内有 break、continue、goto 或者 return 语句时，Go 代码的常见写法是省略 else 部分 1234if condition &#123; return x&#125;return y 1234if err != nil &#123; fmt.Printf(&quot;Program stopping with error %v&quot;, err) os.Exit(1)&#125; swith结构它可以接受任意形式的表达式： 12345678switch var1 &#123; case val1: ... case val2: ... default: ...&#125; 变量 var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值。 一旦成功地匹配到某个分支，在执行完相应代码后就会退出整个 switch 代码块。 继续执行后续分支的代码，可以使用 fallthrough 关键字 12345switch i &#123; case 0: fallthrough case 1: f() // 当 i == 0 时函数也会被调用&#125; 可选的 default 分支可以出现在任何顺序，但最好将它放在最后。它的作用类似与 if-else 语句中的 else，表示不符合任何已给出条件时，执行相关语句。 switch 语句的第二种形式是不提供任何被判断的值（实际上默认为判断是否为 true），然后在每个 case 分支中进行测试不同的条件。 12345678switch &#123; case i &lt; 0: f1() case i == 0: f2() case i &gt; 0: f3()&#125; for结构基于计数器的迭代 1234567package mainimport &quot;fmt&quot;func main() &#123; for i := 0; i &lt; 5; i++ &#123; fmt.Printf(&quot;This is the %d iteration\\n&quot;, i) &#125;&#125; 基于条件判断的迭代 123456789package mainimport &quot;fmt&quot;func main() &#123; var i int = 5 for i &gt;= 0 &#123; i = i - 1 fmt.Printf(&quot;The variable i is now: %d\\n&quot;, i) &#125;&#125; for-range结构 for ix, val := range coll &#123; &#125;。 val 始终为集合中对应索引的值拷贝，因此它一般只具有只读性质，对它所做的任何修改都不会影响到集合中原有的值 123for pos, char := range str &#123;...&#125; 标签和gotofor、switch 或 select 语句都可以配合标签（label）形式的标识符使用，即某一行第一个以冒号（:） 12345678910111213package mainimport &quot;fmt&quot;func main() &#123;LABEL1: // 一般建议使用全部大写字母 for i := 0; i &lt;= 5; i++ &#123; for j := 0; j &lt;= 5; j++ &#123; if j == 4 &#123; continue LABEL1 &#125; fmt.Printf(&quot;i is: %d, and j is: %d\\n&quot;, i, j) &#125; &#125;&#125;","categories":[{"name":"笔记","slug":"笔记","permalink":"http://peapod.top/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://peapod.top/tags/Go/"}],"author":"taweizhong"},{"title":"Go基本数据类型","slug":"Go基本数据类型","date":"2022-08-26T08:31:00.000Z","updated":"2022-09-08T07:37:50.846Z","comments":true,"path":"2022/08/26/Go基本数据类型/","link":"","permalink":"http://peapod.top/2022/08/26/Go%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"第四章（下）：基本数据类型常量常量使用关键字 const 定义，用于存储不会改变的数据。 存储在常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。 1const Pi = 3.14 常量的值必须是能够在编译时就能够确定的。 因为在编译期间自定义函数均属于未知，因此无法用于常量的赋值，但内置函数可以使用，如：len()。 12const Ln2 = 0.693147180559945309417232121458\\ 176568075500134360255254120680009 反斜杠 \\ 可以在常量表达式中作为多行的连接符使用。 常量并行赋值 1const beef,two,c = &quot;eat&quot;,2,&quot;vag&quot; iota 可以被用作枚举值： 12345const ( a = iota b = iota c = iota) 简单地讲，每遇到一次 const 关键字，iota 就重置为 0。. 变量声明变量的一般形式是使用 var 关键字：var identifier type。 123456789var a intvar b boolvar str stringvar ( a int b bool str string) 变量的命名规则遵循骆驼命名法。 全局变量希望能够被外部包所使用，则需要将首个单词的首字母也大写。 变量可以编译期间就被赋值，赋值给变量使用运算符等号 =，可以在运行时对变量进行赋值操作。 12345var a intvar b boola = 15b = true 声明与赋值（初始化）语句也可以组合起来。 12var a int = 15var b bool = false 自动类型推断 12345678910var a = 15var b = falsevar ( a = 15 b = false str = &quot;Go says hello to the world!&quot; numShips = 50 city string) 在函数体内声明局部变量时，应使用简短声明语法 :=，例如： 1a := 1 实例： 123456789101112package mainimport ( &quot;fmt&quot; &quot;runtime&quot; &quot;os&quot;)func main ()&#123; goos := runtime.GOOS fmt.Printf(&quot;%s\\n&quot;,goos) var path string = os.Getenv(&quot;PATH&quot;) fmt.Printf(&quot;%s\\n&quot;,path)&#125; 值类型和引用类型 int、float、bool 和 string 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值。 数组和结构体这些复合类型是值类型。 指针、切片、映射和通道是引用类型。被引用的变量会存储在堆中，以便进行垃圾回收，且比栈拥有更大的内存空间。 函数 fmt.Sprintf 与 Printf 的作用是完全相同的，不过前者将格式化后的字符串以返回值的形式返回给调用者。 在相同的代码块中，我们不可以再次对于相同名称的变量使用初始化声明，例如：a := 20 就是不被允许的。 1a, b, c := 5, 7, &quot;abc&quot; 交换两个变量的值，则可以简单地使用 a, b = b, a。 init函数 变量除了可以在全局声明中初始化，也可以在 init 函数中初始化。 每个源文件都只能包含一个 init 函数。初始化总是以单线程执行，并且按照包的依赖关系顺序执行。 用途是在开始执行程序之前对数据进行检验或修复，以保证程序状态的正确性。 123456package transimport &quot;math&quot;var Pi float64func init()&#123; Pi = 4*math.Atan(1)&#125; 123456789package mainimport ( &quot;fmt&quot; &quot;./trans&quot;)var twoPi = 2*trams.Pifunc main()&#123; fmt.Printf(twoPi)&#125; init 函数也经常被用在当一个程序开始之前调用后台执行的 goroutine。 1234func init() &#123; // setup preparations go backend()&#125; 基本类型与运算符bool类型只有两个类型相同的值才可以进行比较，如果值的类型是接口，它们也必须都实现了相同的接口。 布尔型的常量和变量也可以通过和逻辑运算符（非 !、和 &amp;&amp;、或 ||）结合来产生另外一个布尔值。 ！非运算符用于取得和布尔值相反的结果。 &amp;&amp;两边的值都为 true 的时候，结果才是 true。 ||两边的值都为 false 的时候，结果才是 false。 在格式化输出时，你可以使用 %t 来表示你要输出的值为布尔型。 数字类型Go 语言支持整型和浮点型数字，并且原生支持复数，其中位的运算采用补码。 Go 也有基于架构的类型，例如：int、uint 和 uintptr。 这些类型的长度都是根据运行程序所在的操作系统类型所决定的： int 和 uint 在 32 位操作系统上，它们均使用 32 位（4 个字节），在 64 位操作系统上，它们均使用 64 位（8 个字节）。 uintptr 的长度被设定为足够存放一个指针即可。 Go 语言中没有 float 类型。（Go语言中只有 float32 和 float64）没有double类型。 int 型是计算最快的一种类型。 float32 精确到小数点后 7 位，float64 精确到小数点后 15 位。 尽可能地使用 float64，因为 math 包中所有有关数学运算的函数都会要求接收这个类型。 前缀 0 来表示 8 进制数（如：077），增加前缀 0x 来表示 16 进制数（如：0xFF），以及使用 e 来表示 10 的连乘（如： 1e3 &#x3D; 1000，或者 6.022e23 &#x3D; 6.022 x 1e23）。 可以使用 a := uint64(0) 来同时完成类型转换和赋值操作，这样 a 的类型就是 uint64。 Go 中不允许不同类型之间的混合使用，但是对于常量的类型限制非常少，因此允许常量之间的混合使用： 12345678package mainfunc main()&#123; var a int var b int32 a = 15 b = a+a //编译错误 b = b+5 //5是常量，可以编译&#125; 格式化说明符 %d 用于格式化整数（%x 和 %X 用于格式化 16 进制表示的数字），%g 用于格式化浮点型（%f 输出浮点数，%e 输出科学计数表示法），%0nd 用于规定输出长度为n的整数，其中开头的数字 0 是必须的。 %n.mg 用于表示数字 n 并精确到小数点后 m 位，除了使用 g 之外，还可以使用 e 或者 f，例如：使用格式化字符串 %5.2e 来输出 3.4 的结果为 3.40e+00。 / 对于整数运算而言，结果依旧为整数，例如：9 / 4 -&gt; 2。 取余运算符只能作用于整数：9 % 4 -&gt; 1。 对于整数和浮点数，你可以使用一元运算符 ++（递增）和 --（递减），但只能用于后缀。 ++ 和 -- 的只能作为语句，而非表达式，因此 n = i++ 这种写法是无效的。 随机数 rand 包实现了伪随机数的生成。 123456789101112131415161718192021package mainimport ( &quot;fmt&quot; &quot;math/rand&quot; &quot;time&quot;)func main()&#123; for i:=0; i&lt;5; i++&#123; a := rand.Int() fmt.Printf(&quot;%d\\n&quot;,r) &#125; for i := 0; i &lt; 5; i++ &#123; r := rand.Intn(8) fmt.Printf(&quot;%d / &quot;, r) &#125; times := int64(time.Now().Nanosecond()) rand.Seed(times) for i := 0; i &lt; 10; i++ &#123; fmt.Printf(&quot;%2.2f / &quot;, 100*rand.Float32()) &#125;&#125; 函数 rand.Intn 返回介于 [0, n) 之间的伪随机数。 类型别名在 type TZ int 中，TZ 就是 int 类型的新名称（用于表示程序中的时区），然后就可以使用 TZ 来操作 int 类型的数据。 新类型不会拥有原类型所附带的方法。 字符类型byte 类型是 uint8 的别名。 Go 同样支持 Unicode（UTF-8），因此字符同样称为 Unicode 代码点或者 runes，并在内存中使用 int 来表示。 rune 也是 Go 当中的一个类型，并且是 int32 的别名。 1var ch byte = 65 或 var ch byte = &#x27;\\x41&#x27; var ch byte = &#39;A&#39;；字符使用单引号括起来。 Unicode 至少占用 2 个字节，所以我们使用 int16 或者 int 类型来表示。如果需要使用到 4 字节，则会加上 \\U 前缀；前缀 \\u 则总是紧跟着长度为 4 的 16 进制数，前缀 \\U 紧跟着长度为 8 的 16 进制数。 123456789101112var ch int = &#x27;\\u0041&#x27;var ch2 int = &#x27;\\u03B2&#x27;var ch3 int = &#x27;\\U00101234&#x27;fmt.Printf(&quot;%d - %d - %d\\n&quot;, ch, ch2, ch3) // integerfmt.Printf(&quot;%c - %c - %c\\n&quot;, ch, ch2, ch3) // characterfmt.Printf(&quot;%X - %X - %X\\n&quot;, ch, ch2, ch3) // UTF-8 bytesfmt.Printf(&quot;%U - %U - %U&quot;, ch, ch2, ch3) // UTF-8 code point65 - 946 - 1053236A - β - r41 - 3B2 - 101234U+0041 - U+03B2 - U+101234 判断是否为字母：unicode.IsLetter(ch) 判断是否为数字：unicode.IsDigit(ch) 判断是否为空白符号：unicode.IsSpace(ch) 包 utf8 拥有更多与 rune 类型相关的函数。 字符串字符串是一种值类型，且值不可变，字符串是字节的定长数组。 Go 中的字符串是根据长度限定，而非特殊字符\\0。 函数 len() 来获取字符串所占的字节长度。 在循环中使用加号 + 拼接字符串并不是最高效的做法，更好的办法是使用函数 strings.Join()。 使用字节缓冲（bytes.Buffer）拼接更加给力。 strings和strconv包Go 中使用 strings 包来完成对字符串的主要操作。 12345678910111213141516171819202122232425262728293031strings.HasPrefix(s, prefix string) bool// 判断字符串 s 是否以 prefix 开头strings.HasSuffix(s, suffix string) bool// 判断字符串 s 是否以 suffix 结尾strings.Contains(s, substr string) bool// 判断字符串 s 是否包含 substrstrings.Index(s, str string) int// Index 返回字符串 str 在字符串 s 中的索引strings.LastIndex(s, str string) int// LastIndex 返回字符串 str 在字符串 s 中最后出现位置的索引strings.IndexRune(s string, r rune) int// 非 ASCII 编码的字符在父字符串中的位置strings.Replace(str, old, new, n) string// Replace 用于将字符串 str 中的前 n 个字符串 old 替换为字符串 new，并返回一个新的字符串，如果 n = -1 则替换所有字符串 old 为字符串 newstrings.Count(s, str string) int// Count 用于计算字符串 str 在字符串 s 中出现的非重叠次数strings.Repeat(s, count int) string// Repeat 用于重复 count 次字符串 s 并返回一个新的字符串strings.TrimSpace(s) 来剔除字符串开头和结尾的空白符号；如果你想要剔除指定字符，则可以使用 strings.Trim(s, &quot;cut&quot;) 来将开头和结尾的 cut 去除掉。strings.Split(s, sep) 用于自定义分割符号来对指定字符串进行分割，同样返回 slice。strings.Join(sl []string, sep string) string// Join 用于将元素类型为 string 的 slice 使用分割符号来拼接组成一个字符串 与字符串相关的类型转换都是通过 strconv 包实现的。 12345678910strconv.Itoa(i int) string// 返回数字 i 所表示的字符串类型的十进制数。strconv.FormatFloat(f float64, fmt byte, prec int, bitSize int) string // 将 64 位浮点型的数字转换为字符串strconv.Atoi(s string) (i int, err error) // 将字符串转换为 int 型。strconv.ParseFloat(s string, bitSize int) (f float64, err error) // 将字符串转换为 float64 型。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://peapod.top/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://peapod.top/tags/Go/"}],"author":"taweizhong"},{"title":"Go基本结构","slug":"Go基本结构","date":"2022-08-26T08:30:29.000Z","updated":"2022-09-08T07:38:26.627Z","comments":true,"path":"2022/08/26/Go基本结构/","link":"","permalink":"http://peapod.top/2022/08/26/Go%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/","excerpt":"","text":"第四章（上）：基本结构文件名、关键字与标识符文件名均由小写字母组成，如 scanner.go 。如果文件名由多个部分组成，则使用下划线 _ 对它们进行分隔，scanner_test.go 。 有效的标识符必须以字母（可以使用任何 UTF-8 编码的字符或 _）开头。 _ 本身就是一个特殊的标识符，被称为空白标识符。 程序一般由关键字、常量、变量、运算符、类型和函数组成。 程序的基本结构和要素包、导入与可见性包是结构化代码的一种方式：每个程序都由包（通常简称为 pkg）的概念组成，可以使用自身的包或者从其它包中导入内容。 每个 Go 文件都属于且仅属于一个包。一个包可以由许多以 .go 为扩展名的源文件组成，因此文件名和包名一般来说都是不相同的。 package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。 所有的包名都应该使用小写字母。 属于同一个包的源文件必须全部被一起编译，一个包即是编译时的一个单元，因此根据惯例，每个目录都只包含一个包。 每一段代码只会被编译一次 导入包的方式 1234567891011import &quot;fmt&quot;import &quot;os&quot;import &quot;fmt&quot;;import &quot;os&quot;import ( &quot;fmt&quot; &quot;os&quot;)import (&quot;fmt&quot;;&quot;os&quot;) 可见性规则 当标识符以一个大写字母开头，就可以被外部包的代码所使用，这被称为导出；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用。 可以像面向对象语言那样使用点标记来调用：pack1.Thing 函数1func functionname() main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。 函数简短 1func Sum(a,b int) int &#123;return a+b&#125; 只有当某个函数需要被外部包调用的时候才使用大写字母开头。 注释注释不会被编译，但可以通过 godoc 来使用。 以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾 每一个包应该有相关注释，在 package 语句之前的块注释将被默认认为是这个包的文档说明。 几乎所有全局作用域的类型、常量、变量、函数和被导出的对象都应该有一个合理的注释。如果这种注释（称为文档注释）出现在函数前面，例如函数 Abcd，则要以 &quot;Abcd...&quot; 作为开头。 12345// enterOrbit causes Superman to fly into low Earth orbit, a position// that presents several possibilities for planet salvation.func enterOrbit() error &#123; ...&#125; 类型类型可以是基本类型，如：int、float、bool、string；结构化的（复合的），如：struct、array、slice、map、channel；只描述类型的行为的，如：interface。 结构化的类型没有真正的值，它使用 nil 作为默认值。Go 语言中不存在类型继承。 函数也可以是一个确定的类型，就是以函数作为返回类型。 一个函数可以拥有多返回值，返回类型之间需要使用逗号分割，并使用小括号 () 将它们括起来，如： 1func Functionname (a int,b int) (c int,d int) type 关键字可以定义你自己的类型，你可能想要定义一个结构体，但是也可以定义一个已经存在的类型的别名，如： 1type IZ int 并不是真正意义上的别名，使用这种方法定义之后的类型可以拥有更多的特性，且在类型转换时必须显式转换。 多个类型定义： 12345type ( IZ int FZ float64 STR string) 程序的一般结构 在完成包的 import 之后，开始对常量、变量和类型的定义或声明。 如果存在 init 函数的话，则对该函数进行定义。 如果当前包是 main 包，则定义 main 函数。 然后定义其余的函数，首先是类型的方法，接着是按照 main 函数中先后调用的顺序来定义相关函数。 123456789101112131415161718192021package mainimport ( &quot;fmt&quot;)const PI = 3.14var h float32 = 4type Yuan struct&#123; r float32&#125;func init()&#123;&#125;func main()&#123; y :=&amp;Yuan&#123;9&#125; Fun(y.mianji() * h)&#125;func (y Yuan) mianji() float32&#123; return PI * y.r * y.r&#125;func Fun(v float32)&#123; fmt.Printf(&quot;mianji%f&quot;,v)&#125; 类型转换 Go 语言不存在隐式类型转换，因此所有的转换都必须显式说明。 类型 B 的值 &#x3D; 类型 B(类型 A 的值) 12a := 5.0b := int(5.0)","categories":[{"name":"笔记","slug":"笔记","permalink":"http://peapod.top/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://peapod.top/tags/Go/"}],"author":"taweizhong"},{"title":"Go编辑于调试","slug":"Go编辑于调试","date":"2022-08-26T08:29:58.000Z","updated":"2022-09-08T07:39:04.343Z","comments":true,"path":"2022/08/26/Go编辑于调试/","link":"","permalink":"http://peapod.top/2022/08/26/Go%E7%BC%96%E8%BE%91%E4%BA%8E%E8%B0%83%E8%AF%95/","excerpt":"","text":"第三章：编辑与调试编辑器与调试器编辑器：**Sublime Text、LiteIDE、GoClipse** 调试器：可用的调试器是 gdb。 基本调试： 在合适的位置使用打印语句输出相关变量的值。 在 fmt.Printf 中使用下面的说明符 %+v 打印包括字段在内的实例的完整信息 %#v 打印包括字段和限定类型名称在内的实例的完整信息。 %T 打印某个类型的完整说明 构建格式化工具 gofmt 并保存格式化后的源文件。 构建应用程序： go build 编译自身包和依赖包。 go install 编译并安装自身包和依赖包。 格式化代码go fmt（gofmt）。这个工具可以将你的源代码格式化成符合官方统一标准的风格，属于语法风格层面上的小型重构。 gofmt –w program.go 会格式化该源文件的代码然后将格式化后的代码覆盖原始内容。 gofmt -w *.go 会格式化并重写所有 Go 源文件。 gofmt map1 会格式化并重写 map1 目录及其子目录下的所有 Go 源文件。。 gofmt 也可以通过在参数 -r 后面加入用双引号括起来的替换规则实现代码的简单重构，规则的格式：&lt;原始内容&gt; -&gt; &lt;替换内容&gt;。 1gofmt -r &#x27;(a) -&gt; a&#x27; -w *.go 生成代码文档go doc 工具会从 Go 程序和包文件中提取顶级声明的首行注释以及每个对象的相关注释，并生成相关文档。 一般用法 go doc package获取包的文档注释 go doc package/subpackage 获取子包的文档注释 go doc package function 获取某个函数在某个包中的文档注释","categories":[{"name":"笔记","slug":"笔记","permalink":"http://peapod.top/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://peapod.top/tags/Go/"}],"author":"taweizhong"},{"title":"Go安装与运行","slug":"Go安装与运行","date":"2022-08-26T08:29:40.000Z","updated":"2022-09-08T07:39:31.034Z","comments":true,"path":"2022/08/26/Go安装与运行/","link":"","permalink":"http://peapod.top/2022/08/26/Go%E5%AE%89%E8%A3%85%E4%B8%8E%E8%BF%90%E8%A1%8C/","excerpt":"","text":"第二章：安装与运行环境架构2个版本的编译器：Go 原生编译器 gc 和非原生编译器 gccgo，这两款编译器都是在类 Unix 系统下工作 。 Go从1.5版本开始已经实现自举。 Go 语言源文件的扩展名很显然就是 .go。 创建目录时，文件夹名称永远不应该包含空格，而应该使用下划线 “_” 或者其它一般符号代替。 环境变量 $GOROOT 表示 Go 在你的电脑上的安装位置 $GOARCH 表示目标机器的处理器架构 $GOBIN 表示编译器和链接器的安装位置 $GOPATH三个规定的目录：src、pkg 和 bin，这三个目录分别用于存放源码文件、包文件和可执行文件。 Go 编译器支持交叉编译，可以使用 $GOHOSTOS 和 $GOHOSTARCH 设置本地机器的操作系统名称和编译体系结构。 安装目录 /bin：包含可执行文件 /doc：包含示例程序，代码工具，本地文档等 /lib：包含文档模版 /src：包含源代码构建脚本和标准库的包的完整源代码 Go运行时（runtime）代码仍旧运行在 Go 的 runtime当中。似 Java 和 .NET 语言所用到的虚拟机，它负责管理包括内存分配、垃圾回收）、栈处理、goroutine、channel、切片（slice）、map 和反射（reflection）等等。 垃圾回收器Go 拥有简单却高效的标记-清除回收器。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://peapod.top/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://peapod.top/tags/Go/"}],"author":"taweizhong"},{"title":"Go起源与发展","slug":"Go起源与发展","date":"2022-08-26T08:29:16.000Z","updated":"2022-09-08T07:36:42.205Z","comments":true,"path":"2022/08/26/Go起源与发展/","link":"","permalink":"http://peapod.top/2022/08/26/Go%E8%B5%B7%E6%BA%90%E4%B8%8E%E5%8F%91%E5%B1%95/","excerpt":"","text":"第一章：起源于发展起源与发展Go 语言起源 2007 年，并于 2009 年正式对外发布。 时间轴： 2007 年 9 月 21 日：雏形设计 2009 年 11 月 10日：首次公开发布 2010 年 1 月 8 日：当选 2009 年年度语言 2010 年 5 月：谷歌投入使用 2011 年 5 月 5 日：Google App Engine 支持 Go 语言 主要特性发展目标：将静态语言的安全性和高效性与动态语言的易开发性进行有机结合。是对于网络通信、并发和并行编程的极佳支持，从而更好地利用大量的分布式和多核的计算机。 Go 语言是一门类型安全和内存安全的编程语言。虽然 Go 语言中仍有指针的存在，但并不允许进行指针运算。 重要的特性： 构建速度（编译和链接到机器代码的速度）快。 使用包模式的依赖管理更加的清晰。 执行速度快。 没有类和继承的概念，通过接口（interface）的概念来实现多态性。 使用静态类型，所以它是类型安全的一门语言。 强类型语言，隐式的类型转换是不被允许。 动态语言的特性（通过关键字 var）。 支持交叉编译。 LALR 是 Go 语言的语法标准。 Go语言的用途： 应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。 实现所谓的复杂事件处理（CEP）。 Go 语言不适合用来开发对实时性要求很高的软件。 通过 recover 和 panic 来替代异常机制","categories":[{"name":"笔记","slug":"笔记","permalink":"http://peapod.top/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://peapod.top/tags/Go/"}],"author":"taweizhong"},{"title":"Git入门指南","slug":"Git入门指南","date":"2022-08-25T14:06:50.000Z","updated":"2022-09-08T07:39:58.095Z","comments":true,"path":"2022/08/25/Git入门指南/","link":"","permalink":"http://peapod.top/2022/08/25/Git%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/","excerpt":"","text":"Git入门指南创建仓库1git init 添加12git add *git add &lt;file&gt; 提交1git commit -m &quot;提交信息&quot; 推送1git push origin master","categories":[{"name":"笔记","slug":"笔记","permalink":"http://peapod.top/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://peapod.top/tags/Git/"}],"author":"taweizhong"},{"title":"服务器部署","slug":"服务器部署","date":"2022-08-25T12:10:38.000Z","updated":"2022-09-06T13:39:44.000Z","comments":true,"path":"2022/08/25/服务器部署/","link":"","permalink":"http://peapod.top/2022/08/25/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"使用指南","slug":"使用指南","date":"2022-08-25T10:11:34.000Z","updated":"2022-09-08T07:35:41.782Z","comments":true,"path":"2022/08/25/使用指南/","link":"","permalink":"http://peapod.top/2022/08/25/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","excerpt":"","text":"说明front-matter配置 Key Type Description cover string 封面 layout stirng 页面类型(只有在page页面下生效) subtitle string 小标题&#x2F;描述(只有在page页面生效) toc boolean 是否开启TOC功能(只有在post页面下生效) aplayer boolean 是否启用aplayer播放器(只有在post,page页面下生效) dplayer boolean 是否启用dplayer播放器(只有在post,page页面下生效) tags string 标签（不适用于分页） categories string 分类（不适用于分页） 媒体使用方法image1234&#123;% image url=&quot;https://qiniu.sukoshi.xyz/src/images/68686407_p0.jpg&quot; title=&quot;带描述带图片&quot;%&#125; aplayer 12345678&#123;% aplayer url=&quot;https://qiniu.sukoshi.xyz/public/music/鹿乃 - アイロニ.mp3&quot; name=&quot;アイロニ&quot; artist=&quot;鹿乃&quot; cover=&quot;https://qiniu.sukoshi.xyz/public/music/鹿乃 - アイロニ.jpg&quot; lrc=&quot;https://qiniu.sukoshi.xyz/public/music/鹿乃 - アイロニ.lrc&quot; lrcType=&quot;3&quot;%&#125; dplayer 1234&#123;% dplayer url=&quot;https://qiniu.sukoshi.xyz/video/%E7%BE%8E.mp4&quot; pic=&quot;https://qiniu.sukoshi.xyz/video/%E7%BE%8E.mp4?vframe/jpg/offset/10&quot;%&#125;","categories":[],"tags":[{"name":"说明","slug":"说明","permalink":"http://peapod.top/tags/%E8%AF%B4%E6%98%8E/"}],"author":"taweizhong"}],"categories":[{"name":"区块链","slug":"区块链","permalink":"http://peapod.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"实用","slug":"实用","permalink":"http://peapod.top/categories/%E5%AE%9E%E7%94%A8/"},{"name":"Web","slug":"Web","permalink":"http://peapod.top/categories/Web/"},{"name":"笔记","slug":"笔记","permalink":"http://peapod.top/categories/%E7%AC%94%E8%AE%B0/"},{"name":"说明","slug":"说明","permalink":"http://peapod.top/categories/%E8%AF%B4%E6%98%8E/"},{"name":"前端","slug":"前端","permalink":"http://peapod.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Hyperledger Fabric","slug":"Hyperledger-Fabric","permalink":"http://peapod.top/tags/Hyperledger-Fabric/"},{"name":"clash","slug":"clash","permalink":"http://peapod.top/tags/clash/"},{"name":"beego","slug":"beego","permalink":"http://peapod.top/tags/beego/"},{"name":"Go","slug":"Go","permalink":"http://peapod.top/tags/Go/"},{"name":"测试","slug":"测试","permalink":"http://peapod.top/tags/%E6%B5%8B%E8%AF%95/"},{"name":"说明","slug":"说明","permalink":"http://peapod.top/tags/%E8%AF%B4%E6%98%8E/"},{"name":"Gin","slug":"Gin","permalink":"http://peapod.top/tags/Gin/"},{"name":"css","slug":"css","permalink":"http://peapod.top/tags/css/"},{"name":"vim","slug":"vim","permalink":"http://peapod.top/tags/vim/"},{"name":"HTML","slug":"HTML","permalink":"http://peapod.top/tags/HTML/"},{"name":"Git","slug":"Git","permalink":"http://peapod.top/tags/Git/"}]}