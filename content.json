{"meta":{"title":"秋季的blog","subtitle":"everyday","description":"","author":"他维忠","url":"http://peapod.top","root":"/"},"pages":[{"title":"所有分类","date":"2022-09-08T11:04:02.000Z","updated":"2022-09-08T11:13:16.000Z","comments":true,"path":"categories/index.html","permalink":"http://peapod.top/categories/index.html","excerpt":"","text":""},{"title":"文档","date":"2023-06-08T11:08:04.000Z","updated":"2023-06-10T09:07:50.000Z","comments":true,"path":"doc/index.html","permalink":"http://peapod.top/doc/index.html","excerpt":"","text":"Web 框架Ginhttps://gin-gonic.com/zh-cn/docs/Irishttps://www.iris-go.com/docs/#/Goframehttps://goframe.org/pages/viewpage.action?pageId=1114119gofiberhttps://docs.gofiber.io/数据读写Gormhttps://gorm.io/zh_CN/docs/Xormhttps://xorm.io/docs/chapter-13/readme/Inihttps://ini.unknwon.io/docsRedishttps://redis.uptrace.dev/zh/微服务Protocol Buffershttps://protobuf.dev/Grpchttps://grpc.io/docs/Microhttps://doc.rpcx.io/Go-zerohttps://go-zero.dev/来自 GitHub 的朋友以下友链通过 GitHub Issue 提交，按 issue 最后更新时间排序："},{"title":"examples","date":"2022-09-08T11:08:04.000Z","updated":"2023-06-10T07:12:02.000Z","comments":true,"path":"examples/index.html","permalink":"http://peapod.top/examples/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2022-09-08T11:04:53.000Z","updated":"2023-06-10T08:27:49.000Z","comments":true,"path":"friends/index.html","permalink":"http://peapod.top/friends/index.html","excerpt":"","text":"这里写友链上方的内容。"},{"title":"about","date":"2022-09-08T11:03:19.000Z","updated":"2022-09-08T11:13:18.000Z","comments":true,"path":"about/index.html","permalink":"http://peapod.top/about/index.html","excerpt":"","text":"人的一生"},{"title":"文档","date":"2023-06-08T11:08:04.000Z","updated":"2023-06-23T09:05:23.000Z","comments":true,"path":"learning/index.html","permalink":"http://peapod.top/learning/index.html","excerpt":"","text":"Go 语言学习路线 Go 语言入门 Go语言基础知识学习，主要包括：基本结构、基本数据类型、复杂类型（数组、切片、Map、结构体）、函数和方法、接口、异常、并发、反射机制。视频课程包括Go语言基础视频、原理视频等。 入门视频： 点击查看 郭宏志-老郭 Go语言基础语法和标准库的简单使用。码神之路 Go语言标准库，包含Context、io、fmt等 参考书籍包括Go语言基础知识、三方库的使用等。 入门书籍： 点击查看 Go语言入门指南 Go语言基础语法和标准库的简单使用。Go语言中文文档 Go语言基础知识及导航。 Linux 基础知识学习，文件操作、系统管理、权限管理。Shell 编程学习，基本命令的使用、函数的使用。Makefile学习。Web编程原理，各种网络协议、session和cookie原理及实现。 GO 语言进阶 Go语言框架的使用及各种中间件的学习，主要包括：Web框架的使用，中间件jwt、参数验证、数据库的调用等。Go Web框架 视频： 点击查看 郭宏志-老郭 Go语言基础语法和标准库的简单使用。码神之路 Go语言标准库，包含Context、io、fmt等 Go ORM 视频： 点击查看 Go语言入门指南 Go语言基础语法和标准库的简单使用。Go语言中文文档 Go语言基础知识及导航。 Mysql学习。Redis学习。Docker、docker-compose。Web常用中间件。 Go语言高级 Go语言微服务架构，主要包括：GRPC的使用、微服务的理解、微服务框架的使用。Go Grpc 视频： 点击查看 郭宏志-老郭 Go语言基础语法和标准库的简单使用。码神之路 Go语言标准库，包含Context、io、fmt等 Go-zero 视频： 点击查看 Go语言入门指南 Go语言基础语法和标准库的简单使用。Go语言中文文档 Go语言基础知识及导航。 Mysql学习。Redis学习。Docker、docker-compose。Web常用中间件。"},{"title":"mylist","date":"2022-09-08T11:04:41.000Z","updated":"2022-09-08T11:14:30.000Z","comments":true,"path":"mylist/index.html","permalink":"http://peapod.top/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2022-09-08T11:04:28.000Z","updated":"2022-09-08T11:13:14.000Z","comments":true,"path":"tags/index.html","permalink":"http://peapod.top/tags/index.html","excerpt":"","text":""},{"title":"项目","date":"2023-06-08T11:08:04.000Z","updated":"2023-06-10T07:44:36.000Z","comments":true,"path":"project/index.html","permalink":"http://peapod.top/project/index.html","excerpt":"","text":""}],"posts":[{"title":"blog标准化","slug":"blog标准化","date":"2024-03-17T07:43:56.000Z","updated":"2024-03-17T07:52:06.152Z","comments":true,"path":"2024/03/17/blog标准化/","link":"","permalink":"http://peapod.top/2024/03/17/blog%E6%A0%87%E5%87%86%E5%8C%96/","excerpt":"","text":"blog标准化标签标签使用已经生成的标签，每种相关框架作为单独标签使用。标签名字使用英文标识，简单、可以快速检索。 分类分类使用中文标识，分类应该精简，可以代表大部分的文章，不超过10种。","categories":[],"tags":[{"name":"blog","slug":"blog","permalink":"http://peapod.top/tags/blog/"}]},{"title":"io多路复用","slug":"io多路复用","date":"2024-03-17T06:44:15.000Z","updated":"2024-03-17T07:16:11.425Z","comments":true,"path":"2024/03/17/io多路复用/","link":"","permalink":"http://peapod.top/2024/03/17/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/","excerpt":"","text":"I&#x2F;O 多路复用：select&#x2F;poll&#x2F;epollSocket 模型(基于 TCP 的 Socket 编程)服务端：服务端首先调用 socket() 函数，创建网络协议为 IPv4，以及传输协议为 TCP 的 Socket ，接着调用 bind() 函数，给这个 Socket 绑定一个 IP 地址和端口，绑定完 IP 地址和端口后，就可以调用 listen() 函数进行监听，进入了监听状态后，通过调用 accept() 函数，来从内核获取客户端的连接，如果没有客户端连接，则会阻塞等待客户端连接的到来。 客户端：客户端在创建好 Socket 后，调用 connect() 函数发起连接，该函数的参数要指明服务端的 IP 地址和端口号，开始TCP 三次握手建立连接。 服务端的 accept() 函数，从内核中的 TCP 全连接队列里拿出一个已经完成连接的 Socket 返回应用程序，后续数据传输都用这个 Socket。 在内核中 Socket 是以「文件」的形式存在的，有对应的文件描述符。内核可以通过文件描述符找到对应打开的文件。在 Linux 下，单个进程打开的文件描述符数是有限制的，没有经过修改的值一般都是 1024 TCP Socket 调用流程是最简单、最基本的，它基本只能一对一通信，因为使用的是同步阻塞的方式，当服务端在还没处理完一个客户端的网络 I&#x2F;O 时，或者读写操作发生阻塞时，其他客户端是无法与服务端连接的。 TCP 连接是由四元组唯一确认的，这个四元组就是：本机IP, 本机端口, 对端IP, 对端端口。 多进程模型服务器的主进程负责监听客户的连接，一旦与客户端连接完成，accept() 函数就会返回一个「已连接 Socket」，这时就通过 fork() 函数创建一个子进程，实际上就把父进程所有相关的东西都复制一份，包括文件描述符、内存地址空间、程序计数器、执行的代码等。 根据返回值来区分是父进程还是子进程，如果返回值是 0，则是子进程；如果返回值是其他的整数，就是父进程。 有两种方式可以在子进程退出后回收资源，分别是调用 wait() 和 waitpid() 函数。进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。 多线程模型线程是运行在进程中的一个“逻辑流”，单进程中可以运行多个线程，同进程里的线程可以共享进程的部分资源，比如文件描述符列表、进程空间、代码、全局数据、堆、共享库等，这些共享些资源在上下文切换时不需要切换，而只需要切换线程的私有数据、寄存器等不共享的数据，因此同一个进程下的线程上下文切换的开销要比进程小得多。 当服务器与客户端 TCP 完成连接后，通过 pthread_create() 函数创建线程，然后将「已连接 Socket」的文件描述符传递给线程函数，接着在线程里和客户端进行通信，从而达到并发处理的目的。 使用线程池的方式来避免线程的频繁创建和销毁，所谓的线程池，就是提前创建若干个线程，这样当由新连接建立时，将这个已连接的 Socket 放入到一个队列里，然后线程池里的线程负责从队列中取出「已连接 Socket 」进行处理。 了避免多线程竞争，线程在操作这个队列前要加锁。 I&#x2F;O 多路复用多个请求复用了一个进程，这就是多路复用，这种思想很类似一个 CPU 并发多个进程，所以也叫做时分多路复用。 select&#x2F;poll&#x2F;epoll 这是三个多路复用接口。 select&#x2F;poll&#x2F;epoll 内核提供给用户态的多路复用系统调用，进程可以通过一个系统调用函数从内核中获取多个事件。 select&#x2F;poll&#x2F;epoll 获取网络事件：在获取事件时，先把所有连接（文件描述符）传给内核，再由内核返回产生了事件的连接，然后在用户态中再处理这些连接对应的请求即可。 select&#x2F;pollselect 实现多路复用的方式是，将已连接的 Socket 都放到一个文件描述符集合，然后调用 select 函数将文件描述符集合拷贝到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过遍历文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合拷贝回用户态里，然后用户态还需要再通过遍历的方法找到可读或可写的 Socket，然后再对其处理。 需要进行 2 次「遍历」文件描述符集合，一次是在内核态里，一个次是在用户态里 ，而且还会发生 2 次「拷贝」文件描述符集合，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。 select 使用固定长度的 BitsMap，表示文件描述符集合。poll 不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制。 都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合。 epoll先用epoll_create 创建一个 epoll对象 epfd，再通过 epoll_ctl 将需要监视的 socket 添加到epfd中，最后调用 epoll_wait 等待数据。 12345678910111213int s = socket(AF_INET, SOCK_STREAM, 0);bind(s, ...);listen(s, ...)int epfd = epoll_create(...);epoll_ctl(epfd, ...); //将所有需要监听的socket添加到epfd中while(1) &#123; int n = epoll_wait(...); for(接收到数据的socket)&#123; //处理 &#125;&#125; 第一点，epoll 在内核里使用红黑树来跟踪进程所有待检测的文件描述字，把需要监控的 socket 通过 epoll_ctl() 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删改一般时间复杂度是 O(logn)。减少了内核和用户空间大量的数据拷贝和内存分配。 第二点， epoll 使用事件驱动的机制，内核里维护了一个链表来记录就绪事件，当某个 socket 有事件发生时，通过回调函数内核会将其加入到这个就绪事件列表中，当用户调用 epoll_wait() 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select&#x2F;poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。 边缘触发和水平触发epoll 支持两种事件触发模式，分别是**边缘触发（*edge-triggered，ET*）**和**水平触发（*level-triggered，LT*）**。 水平触发:只要满足事件的条件，比如内核中有数据需要读，就一直不断地把这个事件传递给用户。边缘触发:只有第一次满足条件的时候才触发，之后就不会再传递同样的事件了。 原文：https://www.xiaolincoding.com/os/8_network_system/selete_poll_epoll.html#%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84-socket-%E6%A8%A1%E5%9E%8B","categories":[{"name":"笔记","slug":"笔记","permalink":"http://peapod.top/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://peapod.top/tags/%E7%AC%94%E8%AE%B0/"}],"author":"taweizhong"},{"title":"GO缓存","slug":"GO缓存","date":"2024-03-16T02:49:46.000Z","updated":"2024-03-16T02:50:53.081Z","comments":true,"path":"2024/03/16/GO缓存/","link":"","permalink":"http://peapod.top/2024/03/16/GO%E7%BC%93%E5%AD%98/","excerpt":"","text":"本地缓存实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150package mainimport ( &quot;fmt&quot; &quot;strconv&quot; &quot;sync&quot; &quot;time&quot;)type Cache interface &#123;// 添加缓存项，并设置过期时间Set(key string, val interface&#123;&#125;, expire time.Duration) // 获取缓存项Get(key string) (interface&#123;&#125;, bool)// 删除缓存项Del(key string) bool// 判断是否存在Exists(key string) bool// 刷新缓存Flush() bool// 获取键Keys() int64&#125;type CacheItem struct &#123; value interface&#123;&#125; expAt time.Time creAt time.Time&#125;func (c CacheItem) Size() int64 &#123; // 计算存储的数据所占用的内存大小 var dataSize int64switch v := c.value.(type) &#123; case string: dataSize = int64(len(v)) case int: dataSize = int64(8) case bool: dataSize = int64(1) default: dataSize = 1024 &#125; return dataSize + int64(2*24)&#125;type MCache struct &#123; CItems map[string]CacheItem MaxM int64 CurM int64 mutex sync.Mutex&#125;func NewCache() *MCache &#123; return &amp;MCache&#123; CItems: make(map[string]CacheItem), &#125;&#125;func (m *MCache) Set(key string, value interface&#123;&#125;) &#123; m.SetDefault(key, value, 10*time.Minute)&#125;func (m *MCache) SetDefault(key string, value interface&#123;&#125;, exp time.Duration) &#123; m.mutex.Lock() defer m.mutex.Unlock() if _, ok := m.CItems[key]; ok &#123; m.CurM -= int64(len(key)) + m.CItems[key].Size() &#125; m.CItems[key] = CacheItem&#123; value: value, expAt: time.Now().Add(exp), creAt: time.Now(), &#125; m.CurM += int64(len(key)) + m.CItems[key].Size() m.overCache()&#125;func (m *MCache) Get(key string) (interface&#123;&#125;, bool) &#123; m.mutex.Lock() defer m.mutex.Unlock() item, ok := m.CItems[key] if !ok || time.Now().After(item.expAt) &#123; return nil, false &#125; return item.value, true&#125;func (m *MCache) Del(key string) bool &#123; m.mutex.Lock() defer m.mutex.Unlock() _, ok := m.CItems[key] if !ok &#123; return false &#125; m.CurM -= int64(len(key)) + m.CItems[key].Size() delete(m.CItems, key) return true&#125;func (m *MCache) Exists(key string) bool &#123; m.mutex.Lock() defer m.mutex.Unlock() _, ok := m.CItems[key]return ok &#125;func (m *MCache) Flush() bool &#123; m.mutex.Lock() defer m.mutex.Unlock() m.CItems = make(map[string]CacheItem) m.CurM = 0 return true&#125;func (m *MCache) Keys() int64 &#123; m.mutex.Lock() defer m.mutex.Unlock() return int64(len(m.CItems))&#125;// 100KB 1MB 2MB 1GBfunc (m *MCache) SetMaxMemory(size string) bool &#123; s1 := size[:2] num, _ := strconv.Atoi(s1) unit := size[len(size)-2:] switch unit &#123; case &quot;KB&quot;: m.MaxM = 1024 * int64(num) return true case &quot;MB&quot;: m.MaxM = 1024 * 1024 * int64(num) return true case &quot;GB&quot;: m.MaxM = 1024 * 1024 * 1024 * int64(num) return true default: return false &#125;&#125;func (m *MCache) overCache() &#123; for m.CurM &gt; m.MaxM &#123; oldKey := &quot;&quot; oldTime := time.Time&#123;&#125; for key, cacheItem := range m.CItems &#123; if cacheItem.creAt.Before(oldTime) &#123; oldKey = key oldTime = cacheItem.creAt&#125; &#125; m.CurM -= int64(len(oldKey)) + m.CItems[oldKey].Size() delete(m.CItems, oldKey) &#125;&#125; func main() &#123; cache := NewCache() cache.SetMaxMemory(&quot;100MB&quot;) cache.Set(&quot;int&quot;, 1) cache.Set(&quot;bool&quot;, false) cache.Set(&quot;data&quot;, map[string]interface&#123;&#125;&#123;&quot;a&quot;: 1&#125;) if val, ok := cache.Get(&quot;int&quot;); ok &#123; fmt.Printf(&quot;key:%s, value:%d \\n&quot;, &quot;int&quot;, val) &#125; cache.Del(&quot;int&quot;) fmt.Print(cache.Keys()) //cache.Flush()&#125;","categories":[],"tags":[]},{"title":"ECS框架","slug":"ECS框架","date":"2024-03-16T02:48:46.000Z","updated":"2024-03-16T02:52:00.714Z","comments":true,"path":"2024/03/16/ECS框架/","link":"","permalink":"http://peapod.top/2024/03/16/ECS%E6%A1%86%E6%9E%B6/","excerpt":"","text":"ECS框架简介ECS stands for Entity Component System，为“实体组件系统”。ECS是一种以数据为导向的编程方式。 提供给开发者一种方便的写出高性能代码的方式，同时代码的逻辑架构足够清晰，模块之间的耦合性足够小。 它的基本思想是： 将数据与行为分离，让数据在内存中紧凑排列，提高cpu的缓存命中率； 同时不使用引用类型，不使用继承，让多线程代码的编写更为简单，使各种batch技术的应用成为可能； ECS将数据和行为分离，在Component中仅储存数据，System中仅储存行为，System通过依赖注入的方式访问Component，这可以很大程度上解耦； 详细介绍https://johnyoung404.github.io/2019/06/27/ECS%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/ Entitas简介Entitas 是最流行的开源实体组件系统框架 (ECS)，专为 C# 和 Unity 打造。","categories":[],"tags":[]},{"title":"查找表","slug":"查找表","date":"2024-03-10T05:59:22.000Z","updated":"2024-03-16T06:55:28.805Z","comments":true,"path":"2024/03/10/查找表/","link":"","permalink":"http://peapod.top/2024/03/10/%E6%9F%A5%E6%89%BE%E8%A1%A8/","excerpt":"","text":"查找表一般对于查找表有以下几种操作： 在查找表中查找某个具体的数据元素； 在查找表中插入数据元素； 从查找表中删除数据元素； 在查找表中只做查找操作，而不改动表中数据元素，称此类查找表为静态查找表；反之，在查找表中做查找操作的同时进行插入数据或者删除数据的操作，称此类表为动态查找表。 二分查找使用的前提是静态查找表中的数据必须是有序的。 折半查找的运行过程可以用二叉树来描述，这棵树通常称为“判定树”。 折半查找的平均查找长度为：ASL = log2(n+1) – 1。 折半查找算法只适用于有序表，同时仅限于查找表用顺序存储结构表示。 二叉排序树（二叉查找树）动态查找表中做查找操作时，若查找成功可以对其进行删除；如果查找失败，即表中无该关键字，可以将该关键字插入到表中。 具有如下特点： 二叉排序树中，如果其根结点有左子树，那么左子树上所有结点的值都小于根结点的值； 二叉排序树中，如果其根结点有右子树，那么右子树上所有结点的值都大小根结点的值； 二叉排序树的左右子树也要求都是二叉排序树； 一个无序序列可以通过构建一棵二叉排序树，从而变成一个有序序列。当使用中序遍历算法遍历二叉排序树时，得到的序列为有序序列。 使用二叉排序树实现动态查找操作的过程，实际上就是从二叉排序树的根结点到查找元素结点的过程，所以时间复杂度同被查找元素所在的树的深度（层次数）有关。 平衡二叉树（AVL树）遵循以下两个特点的二叉树： 每棵子树中的左子树和右子树的深度差不能超过 1； 二叉树中每棵子树都要求是平衡二叉树； 平衡因子：每个结点都有其各自的平衡因子，表示的就是其左子树深度同右子树深度的差。取值只可能是：0、1 和 -1。 使用平衡二叉树进行查找操作的时间复杂度为 O(logn)。 红黑树两个要求： 树中的每个结点增加了一个用于存储颜色的标志域； 树中没有一条路径比其他任何路径长出两倍，整棵树要接近于“平衡”的状态。 满足以下性质的二叉查找树才是红黑树： 树中的每个结点颜色不是红的，就是黑的； 根结点的颜色是黑的； 所有为 nil 的叶子结点的颜色是黑的；（注意：叶子结点说的只是为空（nil 或 NULL）的叶子结点！） 如果此结点是红的，那么它的两个孩子结点全部都是黑的； 对于每个结点，从该结点到到该结点的所有子孙结点的所有路径上包含有相同数目的黑结点； 每个结点附带一个整形数值，表示的是此结点的黑高度（从该结点到其子孙结点中包含的黑结点数，用 bh(x) 表示（x 表示此结点）），nil 的黑高度为 0，颜色为黑色。 整棵树也有自己的黑高度，即为根结点的黑高度。对于一棵具有 n 个结点的红黑树，树的高度至多为：2lg(n+1)。 红黑树进行查找操作时的时间复杂度为O(lgn) B-树一颗 m 阶的 B-树，或者本身是空树，否则必须满足以下特性： 树中每个结点至多有 m 棵子树； 若根结点不是叶子结点，则至少有两棵子树； 除根之外的所有非终端结点至少有 ⌈m&#x2F;2⌉ 棵子树； 所有的非终端结点中包含下列信息数据：（n，A0，K1，A1，K2，A2，…，Kn，An）； n 表示结点中包含的关键字的个数，取值范围是：⌈m/2⌉-1≤ n ≤m-1。Ki （i 从 1 到 n）为关键字，且 Ki &lt; Ki+1 ；Ai 代表指向子树根结点的指针，且指针 Ai-1 所指的子树中所有结点的关键字都小于 Ki，An 所指子树中所有的结点的关键字都大于 Kn。 对于 m 阶的 B-树来说，在定义中规定所有的非终端结点（终端结点即叶子结点，其关键字个数为 0）中包含关键字的个数的范围是[⌈m/2⌉-1,m-1]，所以在插入新的数据元素时，首先向最底层的某个非终端结点中添加，如果该结点中的关键字个数没有超过 m-1，则直接插入成功，否则还需要继续对该结点进行处理。 B+树B-树的变型树——B+树。 一颗 m 阶的 B+树和 m 阶的 B-树的差异在于： 有 n 棵子树的结点中含有 n 个关键字； 所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。 所有的非终端结点（非叶子结点）可以看成是索引部分，结点中仅含有其子树（根结点）中的最大（或最小）关键字。 可以进行两种查找运算：一种是利用 sqt 链表做顺序查找，另一种是从树的根结点开始，进行类似于二分查找的查找方式。 无论查找成功与否，每次查找操作都是走了一条从根结点到叶子结点的路径。 哈希表（散列表）哈希表可以通过关键字直接找到数据的存储位置，不需要进行任何的比较，其查找的效率相较于前面所介绍的查找算法是更高的。 哈希地址只是表示在查找表中的存储位置，而不是实际的物理存储位置。f（）是一个函数，通过这个函数可以快速求出该关键字对应的的数据的哈希地址，称之为“哈希函数”。 对于哈希表而言，冲突只能尽可能地少，无法完全避免。常用的哈希函数的构造方法有 6 种：直接定址法、数字分析法、平方取中法、折叠法、除留余数法和随机数法。 直接定址法：其哈希函数为一次函数，即以下两种形式： 1H（key）= key 或者 H（key）=a * key + b 对于无法避免的冲突，需要采取适当的措施去处理。 开放定址法 H（key）&#x3D;（H（key）+ d）MOD m（其中 m 为哈希表的表长，d 为一个增量） 当得出的哈希地址产生冲突时，选取以下 3 种方法中的一种获取 d 的值，然后继续计算，直到计算出的哈希地址不在冲突为止。 线性探测法：d&#x3D;1，2，3，…，m-1 哈希表的装填因子：在一般情况下，当处理冲突的方式相同的情况下，其平均查找长度取决于哈希表的装满程度：装的越满，插入数据时越有可能发生冲突；反之则越小。 装填因子&#x3D;哈希表中数据的个数&#x2F;哈希表的长度，用字符 α 表示（是数学符号，而不是字符 a）。装填因子越小，表示哈希表中空闲的位置就越多。 在假设查找表中的所有数据的查找概率相等的情况下，对于表长为 m，数据个数为 n 的哈希表： 其查找成功的平均查找长度约为：-1&#x2F;α * ln⁡(1-α) 其查找不成功的平均查找长度约为：1&#x2F;(1-α) 通过公式可以看到，哈希表的查找效率只同装填因子有关，而同哈希表中的数据的个数无关","categories":[],"tags":[]},{"title":"STL 容器简介","slug":"STL-容器简介","date":"2024-03-07T13:05:29.000Z","updated":"2024-03-10T05:58:24.646Z","comments":true,"path":"2024/03/07/STL-容器简介/","link":"","permalink":"http://peapod.top/2024/03/07/STL-%E5%AE%B9%E5%99%A8%E7%AE%80%E4%BB%8B/","excerpt":"","text":"STL 容器 简介STL 容器是一些模板类的集合，容器中封装的是组织数据的方法（也就是数据结构）。STL 提供有 3 类标准容器，分别是序列容器、排序容器和哈希容器，其中后两类容器有时也统称为关联容器。 vector 的底层为顺序表（数组），list 的底层为双向链表，deque 的底层为循环队列，set 的底层为红黑树，hash_set 的底层为哈希表。 容器种类 功能 序列容器 主要包括 vector 向量容器、list 列表容器以及 deque 双端队列容器。之所以被称为序列容器，是因为元素在容器中的位置同元素的值无关，即容器不是排序的。将元素插入容器时，指定在什么位置，元素就会位于什么位置。 排序容器 包括 set 集合容器、multiset多重集合容器、map映射容器以及 multimap 多重映射容器。排序容器中的元素默认是由小到大排序好的，即便是插入元素，元素也会插入到适当位置。所以关联容器在查找时具有非常好的性能。 哈希容器 C++11 新加入 4 种关联式容器，分别是 unordered_set 哈希集合、unordered_multiset 哈希多重集合、unordered_map 哈希映射以及 unordered_multimap 哈希多重映射。和排序容器不同，哈希容器中的元素是未排序的，元素的位置由哈希函数确定。 序列式容器序列式容器，其共同的特点是不会对存储的元素进行排序，元素排列的顺序取决于存储它们的顺序。以线性排列（类似普通数组的存储方式）来存储某一指定类型（例如 int、double 等）的数据，需要特殊说明的是，该类容器并不会自动对存储的元素按照值的大小进行排序。 序列容器大致包含以下几类容器： array&lt;T,N&gt;（数组容器）：表示可以存储 N 个 T 类型的元素，是 C++ 本身提供的一种容器。此类容器一旦建立，其长度就是固定不变的，这意味着不能增加或删除元素，只能改变某个元素的值； vector（向量容器）：用来存放 T 类型的元素，是一个长度可变的序列容器，即在存储空间不足时，会自动申请更多的内存。使用此容器，在尾部增加或删除元素的效率最高（时间复杂度为 O(1) 常数阶），在其它位置插入或删除元素效率较差（时间复杂度为 O(n) 线性阶，其中 n 为容器中元素的个数）； deque（双端队列容器）：和 vector 非常相似，区别在于使用该容器不仅尾部插入和删除元素高效，在头部插入或删除元素也同样高效，时间复杂度都是 O(1) 常数阶，但是在容器中某一位置处插入或删除元素，时间复杂度为 O(n) 线性阶； list（链表容器）：是一个长度可变的、由 T 类型元素组成的序列，它以双向链表的形式组织元素，在这个序列的任何地方都可以高效地增加或删除元素（时间复杂度都为常数阶 O(1)），但访问容器中任意元素的速度要比前三种容器慢，这是因为 list 必须从第一个元素或最后一个元素开始访问，需要沿着链表移动，直到到达想要的元素。 forward_list（正向链表容器）：和 list 容器非常类似，只不过它以单链表的形式组织元素，它内部的元素只能从第一个元素开始访问，是一类比链表容器快、更节省内存的容器。 关联式容器关联式容器在存储元素时还会为每个元素在配备一个键，整体以键值对的方式存储到容器中。相比前者，关联式容器可以通过键值直接找到对应的元素，而无需遍历整个容器。另外，关联式容器在存储元素，默认会根据各元素键值的大小做升序排序。 相比其它类型容器，关联式容器查找、访问、插入和删除指定元素的效率更高。 关联式容器所具备的这些特性，归咎于 STL 标准库在实现该类型容器时，底层选用了 「红黑树」。 关联式容器名称 特点 map 定义在 头文件中，使用该容器存储的数据，其各个元素的键必须是唯一的（即不能重复），该容器会根据各元素键的大小，默认进行升序排序（调用 std::less）。 set 定义在 头文件中，使用该容器存储的数据，各个元素键和值完全相同，且各个元素的值不能重复（保证了各元素键的唯一性）。该容器会自动根据各个元素的键（其实也就是元素值）的大小进行升序排序（调用 std::less）。 multimap 定义在 头文件中，和 map 容器唯一的不同在于，multimap 容器中存储元素的键可以重复。 multiset 定义在 头文件中，和 set 容器唯一的不同在于，multiset 容器中存储元素的值可以重复（一旦值重复，则意味着键也是重复的）。 C++ 11 还新增了 4 种哈希容器，即 unordered_map、unordered_multimap 以及 unordered_set、unordered_multiset。严格来说，它们也属于关联式容器，但由于哈希容器底层采用的是哈希表。 容器适配器容器适配器是一个封装了序列容器的类模板，它在一般序列容器的基础上提供了一些不同的功能。 stack、queue、priority_queue： stack：是一个封装了 deque 容器的适配器类模板，默认实现的是一个后入先出（Last-In-First-Out，LIFO）的压入栈。stack 模板定义在头文件 stack 中。 queue：是一个封装了 deque 容器的适配器类模板，默认实现的是一个先入先出（First-In-First-Out，LIFO）的队列。可以为它指定一个符合确定条件的基础容器。queue 模板定义在头文件 queue 中。 priority_queue：是一个封装了 vector 容器的适配器类模板，默认实现的是一个会对元素排序，从而保证最大元素总在队列最前面的队列。priority_queue 模板定义在头文件 queue 中。","categories":[],"tags":[]},{"title":"Go并发-下","slug":"Go并发-下","date":"2024-02-27T10:47:35.000Z","updated":"2024-02-27T11:00:39.697Z","comments":true,"path":"2024/02/27/Go并发-下/","link":"","permalink":"http://peapod.top/2024/02/27/Go%E5%B9%B6%E5%8F%91-%E4%B8%8B/","excerpt":"","text":"Go并发-下基础知识并发和并行之间的区别。 并发（concurrency）：把任务在不同的时间点交给处理器进行处理。在同一时间点，任务并不会同时运行。 并行（parallelism）：把每一个任务分配给每一个处理器独立完成。在同一时间点，任务一定是同时运行。 Go 语言的并发通过 goroutine 特性完成，由 Go 语言的运行时调度完成。 提供 channel 在多个 goroutine 间进行通信。goroutine 和 channel 是 Go 语言秉承的 CSP（Communicating Sequential Process）并发模式的重要实现基础。 goroutine使用 go 关键字就可以创建 goroutine，将 go 声明放到一个需调用的函数之前。 所有 goroutine 在 main() 函数结束时会一同结束。 channelGo语言在语言级别提供的 goroutine 间的通信方式。使用 channel 在两个或多个 goroutine 之间传递消息。 一个 channel 只能传递一种类型的值，类型需要在声明 channel 时指定。 死锁、活锁和饥饿死锁是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。 活锁是另一种形式的活跃性问题，该问题尽管不会阻塞线程，但也不能继续执行，因为线程将不断重复同样的操作，而且总会失败。 饥饿是指一个可运行的进程尽管能继续执行，但被调度器无限期地忽视，而不能被调度执行的情况。 并发通信最常见的并发通信模型：共享数据和消息。 传统的同步 goroutine 的机制，对共享资源加锁。atomic 和 sync 包可以对共享的资源进行加锁操作。 原子函数以底层的加锁机制来同步访问整型变量和指针。 12345678910111213141516171819202122232425package mainimport ( &quot;fmt&quot; &quot;runtime&quot; &quot;sync&quot; &quot;sync/atomic&quot;)var ( counter int64 wg sync.WaitGroup)func main() &#123; wg.Add(2) go incCounter(1) go incCounter(2) wg.Wait() //等待goroutine结束 fmt.Println(counter)&#125;func incCounter(id int) &#123; defer wg.Done() for count := 0; count &lt; 2; count++ &#123; atomic.AddInt64(&amp;counter, 1) //安全的对counter加1 runtime.Gosched() &#125;&#125; 互斥锁和读写锁sync 包提供了两种锁类型：sync.Mutex 和 sync.RWMutex。RWMutex 相对友好些，是经典的单写多读模型。 用于在代码上创建一个临界区，保证同一时间只有一个 goroutine 可以执行这个临界代码。 1234567891011121314151617181920212223242526272829303132package mainimport ( &quot;fmt&quot; &quot;runtime&quot; &quot;sync&quot;)var ( counter int64 wg sync.WaitGroup mutex sync.Mutex)func main() &#123; wg.Add(2) go incCounter(1) go incCounter(2) wg.Wait() fmt.Println(counter)&#125;func incCounter(id int) &#123; defer wg.Done() for count := 0; count &lt; 2; count++ &#123; //同一时刻只允许一个goroutine进入这个临界区 mutex.Lock() &#123; value := counter runtime.Gosched() value++ counter = value &#125; mutex.Unlock() //释放锁，允许其他正在等待的goroutine进入临界区 &#125;&#125; 12345678910111213var ( // 逻辑中使用的某个变量 count int // 与变量对应的使用互斥锁 countGuard sync.RWMutex)func GetCount() int &#123; // 锁定 countGuard.RLock() // 在函数退出时解除锁定 defer countGuard.RUnlock() return count&#125; 等待组使用等待组进行多个任务的同步，等待组可以保证在并发环境中完成指定数量的任务。 方法名 功能 (wg * WaitGroup) Add(delta int) 等待组的计数器 +1 (wg * WaitGroup) Done() 等待组的计数器 -1 (wg * WaitGroup) Wait() 当等待组计数器不等于 0 时阻塞直到变 0。 12345678910111213141516171819202122232425262728293031323334package mainimport ( &quot;fmt&quot; &quot;net/http&quot; &quot;sync&quot;)func main() &#123; // 声明一个等待组 var wg sync.WaitGroup // 准备一系列的网站地址 var urls = []string&#123; &quot;http://www.github.com/&quot;, &quot;https://www.qiniu.com/&quot;, &quot;https://www.golangtc.com/&quot;, &#125; // 遍历这些地址 for _, url := range urls &#123; // 每一个任务开始时, 将等待组增加1 wg.Add(1) // 开启一个并发 go func(url string) &#123; // 使用defer, 表示函数完成时将等待组值减1 defer wg.Done() // 使用http访问提供的地址 _, err := http.Get(url) // 访问完成后, 打印地址和可能发生的错误 fmt.Println(url, err) // 通过参数传递url地址 &#125;(url) &#125; // 等待所有的任务完成 wg.Wait() fmt.Println(&quot;over&quot;)&#125; 通道（chan）可以让一个 goroutine 通过它给另一个 goroutine 发送值信息。 提倡使用通信的方法代替共享内存，当一个资源需要在 goroutine 之间共享时，通道在 goroutine 之间架起了一个管道，并提供了确保同步交换数据的机制。 在任何时候，同时只能有一个 goroutine 访问通道进行发送和获取数据。goroutine 间通过通道就可以通信。 通道声明1var 通道变量 chan 通道类型 通道创建1通道实例 := make(chan 数据类型) 发送数据1234567// 通道变量 &lt;- 值// 创建一个空接口通道ch := make(chan interface&#123;&#125;)// 将0放入通道中ch &lt;- 0// 将hello字符串放入通道中ch &lt;- &quot;hello&quot; 接受数据123456789// 阻塞接收数据data := &lt;-ch// 非阻塞接收数据data, ok := &lt;-ch// 忽略接收的数据&lt;-ch// 循环接收for data := range ch &#123;&#125; 单向通道只能写入数据的通道类型为chan&lt;-，只能读取数据的通道类型为&lt;-chan 1234567ch := make(chan int)// 声明一个只能写入数据的通道类型, 并赋值为chvar chSendOnly chan&lt;- int = ch// 声明一个只能读取数据的通道类型, 并赋值为chvar chRecvOnly &lt;-chan int = ch// make 创建通道时，也可以创建一个只写入或只读取的通道ch := make(&lt;-chan int) 带缓冲的通道创建缓冲通道12// 创建一个3个元素缓冲大小的整型通道 ch := make(chan int, 3) 阻塞条件 带缓冲通道被填满时，尝试再次发送数据时发生阻塞。 带缓冲通道为空时，尝试接收数据时发生阻塞。 超时机制Go语言中提供了 select 关键字，可以同时响应多个通道的操作。每个 case 语句里必须是一个 IO 操作。 在一个 select 语句中，Go语言会按顺序从头至尾评估每一个发送和接收的语句。 如果其中的任意一语句可以继续执行（即没有被阻塞），那么就从那些可以执行的语句中任意选择一条来使用。 没有任意一条语句可以执行： 如果给出了 default 语句，那么就会执行 default 语句，同时程序的执行会从 select 语句后的语句中恢复； 如果没有 default 语句，那么 select 语句将被阻塞，直到至少有一个通信可以进行下去。 select 做的就是：选择处理列出的多个通信情况中的一个。 如果都阻塞了，会等待直到其中一个可以处理 如果多个可以处理，随机选择一个 如果没有通道操作可以处理并且写了 default 语句，它就会执行：default 永远是可运行的（这就是准备好了，可以执行）。 select 语句实现了一种监听模式，通常用在（无限）循环中；在某种情况下，通过 break 语句使循环退出。 123456789select&#123; case 操作1: 响应操作1 case 操作2: 响应操作2 … default: 没有操作情况&#125; 操 作 语句示例 接收任意数据 case &lt;- ch; 接收变量 case d :&#x3D; &lt;- ch; 发送数据 case ch &lt;- 100; 123456789101112131415161718192021222324252627package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() &#123; ch := make(chan int) quit := make(chan bool) //新开一个协程 go func() &#123; for &#123; select &#123; case num := &lt;-ch: fmt.Println(&quot;num = &quot;, num) case &lt;-time.After(3 * time.Second): fmt.Println(&quot;超时&quot;) quit &lt;- true &#125; &#125; &#125;() //别忘了() for i := 0; i &lt; 5; i++ &#123; ch &lt;- i time.Sleep(time.Second) &#125; &lt;-quit fmt.Println(&quot;程序结束&quot;)&#125; 从已经关闭的通道接收数据或者正在接收数据时，将会接收到通道类型的零值，然后停止阻塞并返回。 多核并行化通过设置环境变量 GOMAXPROCS 的值来控制使用多少个 CPU 核心。 12345678910package mainimport ( &quot;fmt&quot; &quot;runtime&quot;)func main() &#123; cpuNum := runtime.NumCPU() //获得当前设备的cpu核心数 fmt.Println(&quot;cpu核心数:&quot;, cpuNum) runtime.GOMAXPROCS(cpuNum) //设置需要用到的cpu数量&#125; CSP：通信顺序进程CSP（communicating sequential processes）并发模型。 Go语言并没有完全实现了 CSP 并发模型的所有理论，仅仅是实现了 process 和 channel 这两个概念。 process 就是Go语言中的 goroutine，每个 goroutine 之间是通过 channel 通讯来实现数据共享。 通道（channel）和 map、切片一样，也是由 Go 源码编写而成。为了保证两个 goroutine 并发访问的安全性，通道也需要做一些锁操作，因此通道其实并不比锁高效。","categories":[{"name":"golang标准库","slug":"golang标准库","permalink":"http://peapod.top/categories/golang%E6%A0%87%E5%87%86%E5%BA%93/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://peapod.top/tags/Go/"}],"author":"taweizhong"},{"title":"python对象","slug":"python对象","date":"2023-12-21T11:44:27.000Z","updated":"2023-12-21T13:00:46.000Z","comments":true,"path":"2023/12/21/python对象/","link":"","permalink":"http://peapod.top/2023/12/21/python%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"python对象class123class 类名： 多个（≥0）类属性... 多个（≥0）类方法... 类属性指的就是包含在类中的变量；而类方法指的是包含类中的函数。 1234567class TheFirstDemo: &#x27;&#x27;&#x27;这是一个学习Python定义的第一个类&#x27;&#x27;&#x27; # 下面定义了一个类属性 add = &#x27;http://c.biancheng.net&#x27; # 下面定义了一个say方法 def say(self, content): print(content) 构造方法构造方法用于创建对象时使用，创建一个类的实例对象时，解释器都会自动调用它。 12def __init__(self,...): 代码块 必须包含一个名为 self 的参数，且必须作为第一个参数。 12345678910class TheFirstDemo: &#x27;&#x27;&#x27;这是一个学习Python定义的第一个类&#x27;&#x27;&#x27; #构造方法 def __init__(self): print(&quot;调用构造方法&quot;) # 下面定义了一个类属性 add = &#x27;http://c.biancheng.net&#x27; # 下面定义了一个say方法 def say(self, content): print(content) 即便不手动为类添加任何构造方法，会自动为类添加一个仅包含 self 参数的构造方法。 在 __init__() 构造方法中，除了 self 参数外，还可以自定义一些参数，参数之间使用逗号“,”进行分割。 123456class CLanguage: &#x27;&#x27;&#x27;这是一个学习Python定义的一个类&#x27;&#x27;&#x27; def __init__(self,name,add): print(name,&quot;的网址为:&quot;,add)#创建 add 对象，并传递参数给构造函数add = CLanguage(&quot;C语言中文网&quot;,&quot;http://c.biancheng.net&quot;) 对象定义的类只有进行实例化，也就是使用该类创建对象之后，才能得到利用。 访问或修改类对象具有的实例变量，甚至可以添加新的实例变量或者删除已有的实例变量； 调用类对象的方法，包括调用现有的方法，以及给类对象动态添加方法。 给类对象动态添加方法为 对象动态增加的方法，不会自动将调用者自动绑定到第一个参数。 12345678# 先定义一个函数def info(self): print(&quot;---info函数---&quot;, self)# 使用info对clanguage的foo方法赋值（动态绑定方法）clanguage.foo = info# Python不会自动将调用者绑定到第一个参数，# 因此程序需要手动将调用者绑定为第一个参数clanguage.foo(clanguage) self 所表示的都是实际调用该方法的对象。","categories":[],"tags":[]},{"title":"python函数","slug":"python函数","date":"2023-12-21T10:43:51.000Z","updated":"2023-12-21T11:43:57.000Z","comments":true,"path":"2023/12/21/python函数/","link":"","permalink":"http://peapod.top/2023/12/21/python%E5%87%BD%E6%95%B0/","excerpt":"","text":"python函数函数简介将常用的代码以固定的格式封装（包装）成一个独立的模块，可以重复使用，这个模块就叫做函数（Function）。 定义函数。 1234567#定义个空函数，没有实际意义def pass_dis(): pass#定义一个比较字符串大小的函数def str_max(str1,str2): str = str1 if str1 &gt; str2 else str2 return str 调用函数。 123pass_dis()strmax = str_max(&quot;http://c.biancheng.net/python&quot;,&quot;http://c.biancheng.net/shell&quot;);print(strmax) 函数说明文档。 函数的说明文档通常位于函数内部、所有代码的最前面。 12345678910#定义一个比较字符串大小的函数def str_max(str1,str2): &#x27;&#x27;&#x27; 比较 2 个字符串的大小 &#x27;&#x27;&#x27; str = str1 if str1 &gt; str2 else str2 return strhelp(str_max)#__doc__ 属性来获取 str_max() 函数的说明文档print(str_max.__doc__) 值传递和引用传递形式参数：在定义函数时，函数名后面括号中的参数就是形式参数。 实际参数：在调用函数时，函数名后面括号中的参数称为实际参数。 值传递：适用于实参类型为不可变类型（字符串、数字、元组）； 引用（地址）传递：适用于实参类型为可变类型（列表，字典）； 函数参数进行值传递后，若形参的值发生改变，不会影响实参的值；而函数参数继续引用传递后，改变形参的值，实参的值也会一同改变。 值传递，其本质就是将实际参数值复制一份，将其副本传给形参。这意味着，采用值传递方式的函数中，无论其内部对参数值进行如何修改，都不会影响函数外部的实参。 传参解包当传入列表或元组时，其名称前要带一个 * 号，当传入字典时，其名称前要带有 2 个 * 号。 123456def dis_str(name,add) : print(&quot;name:&quot;,name) print(&quot;add&quot;,add)data = [&quot;Python教程&quot;,&quot;http://c.biancheng.net/python/&quot;]#使用逆向参数收集方式传值dis_str(*data) 函数返回多值2 种方式： 在函数中，提前将要返回的多个值存储到一个列表或元组中，然后函数返回该列表或元组； 函数直接返回多个值，之间用逗号（ , ）分隔，Python 会自动将多个值封装到一个元组中，其返回值仍是一个元组。 序列解包，使用对应数量的变量，直接接收函数返回列表或元组中的多个值。 123456def retu_list() : add = [&quot;http://c.biancheng.net/python/&quot;,\\ &quot;http://c.biancheng.net/shell/&quot;,\\ &quot;http://c.biancheng.net/golang/&quot;] return addpythonadd,shelladd,golangadd = retu_list() 变量作用域局部变量仅限于函数内部，出了函数就不能使用。 在函数执行完毕后，这块临时存储空间随即会被释放并回收，该空间中存储的变量无法再被使用。 全局变量在所有函数的外部定义变量，这样的变量称为全局变量（Global Variable）。 全局变量的默认作用域是整个程序，即全局变量既可以在各个函数的外部使用，也可以在各函数内部使用。 在函数体外定义的变量。 在函数体内使用 global 关键字对变量进行修饰。 函数高级赋值、作为其他函数的参数以及作为其他函数的返回值。 将函数赋值给其它变量。 123456def my_def (): print(&quot;正在执行 my_def 函数&quot;)#将函数赋值给其他变量 other = my_def#间接调用 my_def() 函数other() 将函数以参数的形式传入其他函数中。 123456789def multi(a,b): return a*bdef my_def(a,b,dis): return dis(a,b) #求 2 个数的和print(my_def(3,4,add))#求 2 个数的乘积print(my_def(3,4,multi)) 返回值为函数。 123456789def my_def (): #局部函数 def indef(): print(&quot;调用局部函数&quot;) #调用局部函数 return indefother_def = my_def()#调用局部的 indef() 函数other_def() 闭包外部函数返回的不是一个具体的值，而是一个函数。一般情况下，返回的函数会赋值给一个变量，这个变量可以在后面被继续执行调用。 123456789#闭包函数，其中 exponent 称为自由变量def nth_power(exponent): def exponent_of(base): return base ** exponent return exponent_of # 返回值是 exponent_of 函数square = nth_power(2) # 计算一个数的平方cube = nth_power(3) # 计算一个数的立方print(square(2)) # 计算 2 的平方print(cube(2)) # 计算 2 的立方 闭包比普通的函数多了一个 closure 属性，该属性记录着自由变量的地址。 匿名函数lambda 表达式，又称匿名函数，常用来表示内部仅包含 1 行表达式的函数。 对于单行函数，使用 lambda 表达式可以省去定义函数的过程，让代码更加简洁； 对于不需要多次复用的函数，使用 lambda 表达式可以在用完之后立即释放，提高程序执行的性能 12add = lambda x,y:x+yprint(add(3,4))","categories":[],"tags":[]},{"title":"python复杂类型详解","slug":"python复杂类型详解","date":"2023-12-18T03:07:22.000Z","updated":"2023-12-18T03:40:40.000Z","comments":true,"path":"2023/12/18/python复杂类型详解/","link":"","permalink":"http://peapod.top/2023/12/18/python%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"复杂类型详解list列表实现栈和队列二者的区别在于对数据的存取顺序： 队列是，先存入的数据最先取出，即“先进先出”。 栈是，最后存入的数据最先取出，即“后进先出”。 list实现队列存入数据时使用 insert() 方法，设置其第一个参数为 0，即表示每次都从最前面插入数据； 读取数据时，使用 pop() 方法，即将队列的最后一个元素弹出。 12345678910#定义一个空列表，当做队列queue = []#向列表中插入元素queue.insert(0,1)queue.insert(0,2)queue.insert(0,&quot;hello&quot;)print(queue)print(&quot;取一个元素：&quot;,queue.pop())print(&quot;取一个元素：&quot;,queue.pop())print(&quot;取一个元素：&quot;,queue.pop()) list实现栈append() 方法存入数据；使用 pop() 方法读取数据。 123456789#定义一个空 list 当做栈stack = []stack.append(1)stack.append(2)stack.append(&quot;hello&quot;)print(stack)print(&quot;取一个元素：&quot;,stack.pop())print(&quot;取一个元素：&quot;,stack.pop())print(&quot;取一个元素：&quot;,stack.pop()) collections模块实现栈和队列标准库的 collections 模块中的 deque 结构体，它被设计成在两端存入和读取都很快的特殊 list，可以用来实现栈和队列的功能。 123456789101112import collectionsqueueAndStack = collections.deque()queueAndStack.append(1)queueAndStack.append(2)queueAndStack.append(&quot;hello&quot;)print(list(queueAndStack))#实现队列功能，从队列中取一个元素，根据先进先出原则，这里应输出 1print(queueAndStack.popleft())#实现栈功能，从栈里取一个元素，根据后进先出原则，这里应输出 helloprint(queueAndStack.pop())#再次打印列表print(list(queueAndStack)) 列表和元组的底层实现list 列表123456789101112131415161718typedef struct &#123; PyObject_VAR_HEAD /* Vector of pointers to list elements. list[0] is ob_item[0], etc. */ PyObject **ob_item; /* ob_item contains space for &#x27;allocated&#x27; elements. The number * currently in use is ob_size. * Invariants: * 0 &lt;= ob_size &lt;= allocated * len(list) == ob_size * ob_item == NULL implies ob_size == allocated == 0 * list.sort() temporarily sets allocated to -1 to detect mutations. * * Items must normally not be NULL, except during construction when * the list is not yet visible outside the function that builds it. */ Py_ssize_t allocated;&#125; PyListObject; 本质上是一个长度可变的连续数组。其中 ob_item 是一个指针列表，里边的每一个指针都指向列表中的元素，而 allocated 则用于存储该列表目前已被分配的空间大小。 当前列表分配的空间已满（即 allocated &#x3D;&#x3D; len(list)），则会向系统请求更大的内存空间，并把原来的元素全部拷贝过去。 tuple元组12345678typedef struct &#123; PyObject_VAR_HEAD PyObject *ob_item[1]; /* ob_item contains space for &#x27;ob_size&#x27; elements. * Items must normally not be NULL, except during construction when * the tuple is not yet visible outside the function that builds it. */&#125; PyTupleObject; 本质也是一个数组，但是空间大小固定。 字典和集合的底层实现字典和集合是进行过性能高度优化的数据结构，特别是对于查找、添加和删除操作。 原理字典和集合的内部结构都是一张哈希表： 对于字典而言，这张表存储了哈希值（hash）、键和值这 3 个元素。 而对集合来说，哈希表内只存储单一的元素。 为了提高存储空间的利用率，现在的哈希表除了字典本身的结构，会把索引和哈希值、键、值单独分开。 平均情况下，仍能保证插入、查找和删除的时间复杂度为 O(1)。 哈希表插入数据当向字典中插入数据时，Python 会首先根据键（key）计算出对应的哈希值（通过 hash(key) 函数），而向集合中插入数据时，Python会根据该元素本身计算对应的哈希值（通过 hash(valuse) 函数）。 得到哈希值（例如为 hash）之后，再结合字典或集合要存储数据的个数（例如 n），就可以得到该元素应该插入到哈希表中的位置（比如，可以用 hash%n 的方式）。 哈希表查找数据根据哈希值，找到该元素应该存储到哈希表中的位置，然后和该位置的元素比较其哈希值和键（集合直接比较元素值）： 如果相等，则证明找到； 反之，则证明当初存储该元素时，遇到了哈希冲突，需要继续使用当初解决哈希冲突的方法进行查找，直到找到该元素或者找到空位为止。 哈希表删除元素对这个位置的元素赋于一个特殊的值，等到重新调整哈希表的大小时，再将其删除。 哈希冲突的发生往往会降低字典和集合操作的速度。因此，为了保证其高效性，字典和集合内的哈希表，通常会保证其至少留有 1&#x2F;3 的剩余空间。随着元素的不停插入，当剩余空间小于 1&#x2F;3 时，Python 会重新获取更大的内存空间，扩充哈希表，与此同时，表内所有的元素位置都会被重新排放。 深拷贝和浅拷贝浅拷贝指的是重新分配一块内存，创建一个新的对象，但里面的元素是原对象中各个子对象的引用。 常见的浅拷贝的方法，是使用数据类型本身的构造器。 123list1 = [1, 2, 3]list2 = list(list1)print(list2) 对于可变的序列，还可以通过切片操作符“：”来完成浅拷贝 123list1 = [1, 2, 3]list2 = list1[:]print(list2) 函数 copy.copy() 函数，适用于任何数据类型。 1234import copylist1 = [1, 2, 3]list2 = copy.copy(list1)print(list2) 深拷贝是指重新分配一块内存，创建一个新的对象，并且将原对象中的元素，以递归的方式，通过创建新的子对象拷贝到新对象中。因此，新对象和原对象没有任何关联。 copy.deepcopy() 来实现对象的深度拷贝。 123import copylist1 = [[1, 2], (30, 40)]list2 = copy.deepcopy(list1) 拷贝对象中存在指向自身的引用，那么程序很容易陷入无限循环。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://peapod.top/tags/python/"}]},{"title":"python复杂类型","slug":"python复杂类型","date":"2023-12-17T11:25:41.000Z","updated":"2023-12-18T03:42:29.000Z","comments":true,"path":"2023/12/17/python复杂类型/","link":"","permalink":"http://peapod.top/2023/12/17/python%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"python 复杂类型list列表列表可以存储整数、小数、字符串、列表、元组等任何类型的数据，并且同一个列表中元素的类型也可以不同。 同一列表中只放入同一类型的数据，这样可以提高程序的可读性。 创建列表使用[ ]创建列表后，一般使用=将它赋值给某个变量。 12num = [1, 2, 3, 4, 5, 6, 7]emptylist = [ ] # 空列表 内置的函数 list()，使用它可以将其它数据类型转换为列表类型。 123456789# 将字符串转换成列表list1 = list(&quot;hello&quot;)print(list1)#将区间转换成列表range1 = range(1, 6)list4 = list(range1)print(list4)#创建空列表print(list()) 遍历列表使用索引（Index）访问列表中的某个元素（得到的是一个元素的值），也可以使用切片访问列表中的一组元素（得到的是一个新的子列表）。 12listname[start : end : step]# listname 表示列表名字，start 表示起始索引，end 表示结束索引，step 表示步长。 删除列表对于已经创建的列表，如果不再使用，可以使用del关键字将其删除。 1del listname 添加元素列表可以使用+进行连接，相当于在第一个列表的末尾添加了另一个列表。 使用+会生成一个新的列表，原有的列表不会被改变。 append() 方法用于在列表的末尾追加元素。 123456l = [&#x27;Python&#x27;, &#x27;C++&#x27;, &#x27;Java&#x27;]# 追加元素l.append(&#x27;PHP&#x27;)print(l)# 追加列表，整个列表也被当成一个元素l.append([&#x27;Ruby&#x27;, &#x27;SQL&#x27;]) extend()方法把包含的元素逐个添加到列表中。 123# 追加列表，列表也被拆分成多个元素l.extend([&#x27;Ruby&#x27;, &#x27;SQL&#x27;])print(l) insert()方法在列表中间某个位置插入元素。 123l = [&#x27;Python&#x27;, &#x27;C++&#x27;, &#x27;Java&#x27;]#插入元素l.insert(1, &#x27;C&#x27;) 删除元素del根据索引值删除元素。 123lang = [&quot;Python&quot;, &quot;C++&quot;, &quot;Java&quot;, &quot;PHP&quot;, &quot;Ruby&quot;, &quot;MATLAB&quot;]#使用正数索引del lang[2] pop()方法pop() 方法用来删除列表中指定索引处的元素。默认会删除列表中的最后一个元素。 12nums = [40, 36, 89, 2, 36, 100, 7]nums.pop(3) remove()方法根据元素本身的值来进行删除操作。 删除第一个和指定值相同的元素，而且必须保证该元素是存在的，否则会引发 ValueError 错误。 1234nums = [40, 36, 89, 2, 36, 100, 7]#第一次删除36nums.remove(36)print(nums) clear()删除列表的所有元素，也即清空列表。 12url = list(&quot;http://c.biancheng.net/python/&quot;)url.clear() 修改元素直接对元素赋值 1nums[2] = -26 #使用正数索引 通过切片语法给一组元素赋值。既可以为列表添加元素，也可以为列表删除元素。 123nums = [40, 36, 89, 2, 36, 100, 7]#修改第 1~4 个元素的值（不包括第4个元素）nums[1: 4] = [45.25, -77, -52.5] 查找元素index() 方法用来查找某个元素在列表中出现的位置。 12345listname.index(obj, start, end)nums = [40, 36, 89, 2, 36, 100, 7, -20.5, -999]#检索列表中的所有元素print( nums.index(2) ) count()方法统计某个元素在列表中出现的次数。count() 返回 0，就表示列表中不存在该元素。 123nums = [40, 36, 89, 2, 36, 100, 7, -20.5, 36]#统计元素出现的次数print(&quot;36出现了%d次&quot; % nums.count(36)) tuple元组元组和列表（list）的不同之处在于： 列表的元素是可以更改的，包括修改元素值，删除和插入元素，所以列表是可变序列； 而元组一旦被创建，它的元素就不可更改了，所以元组是不可变序列。 元组的所有元素都放在一对小括号( )中，相邻元素之间用逗号,分隔。元组可以存储整数、实数、字符串、列表、元组等任何类型的数据，并且在同一个元组中，元素的类型可以不同。 1(&quot;c.biancheng.net&quot;, 1, [2,&#x27;a&#x27;], (&quot;abc&quot;,3.0)) 元组作为很多内置函数和序列类型方法的返回值存在，使用某些函数或者方法时，它的返回值是元组类型。 元组比列表的访问和处理速度更快，对指定元素进行访问，且不涉及修改元素的操作时，使用元组。 元组可以在映射（和集合的成员）中当做“键”使用，而列表不行。 创建元祖通过( )创建元组后，一般使用=将它赋值给某个变量。 1num = (7, 14, 21, 28, 35) tuple()，用来将其它数据类型转换为元组类型。 123#将字符串转换成元组tup1 = tuple(&quot;hello&quot;)print(tup1) 访问元素使用索引访问元组元素，使用切片访问元组元素。 12345#使用索引访问元组中的某个元素print(url[3]) #使用正数索引#使用切片访问元组中的一组元素print(url[9: 18]) #使用正数切片 修改元组只能创建一个新的元组去替代旧的元组。 1234tup = (100, 0.5, -36, 73)print(tup)#对元组进行重新赋值tup = (&#x27;Shell脚本&#x27;,&quot;http://c.biancheng.net/shell/&quot;) 删除元组通过 del 关键字将其删除。 123tup = (&#x27;Java教程&#x27;,&quot;http://c.biancheng.net/java/&quot;)print(tup)del tup dict字典字典（dict）是一种无序的、可变的序列，它的元素以“键值对（key-value）”的形式存储。 字典中的键必须唯一，必须不可变，只能使用数字、字符串或者元组，不能使用列表。 创建字典使用 { } 创建字典。 12345#使用字符串作为keyscores = &#123;&#x27;数学&#x27;: 95, &#x27;英语&#x27;: 92, &#x27;语文&#x27;: 84&#125;#使用元组和数字作为keydict1 = &#123;(20, 30): &#x27;great&#x27;, 30: [1,2,3]&#125; fromkeys() 方法创建字典。带有默认值的字典。 12knowledge = [&#x27;语文&#x27;, &#x27;数学&#x27;, &#x27;英语&#x27;]scores = dict.fromkeys(knowledge, 60) dict() 映射函数创建字典。应用 dict() 函数和 zip() 函数，可将两个列表转换为对应的字典。 123456keys = [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;] values = [1, 2, 3]a = dict( zip(keys, values) )# 创建空的字典d = dict() 访问字典通过键访问值。键必须是存在的，否则会抛出异常。 1dictname[key] get() 方法来获取指定键对应的值。当指定的键不存在时，get() 方法不会抛出异常。 1dictname.get(key[,default]) 当键不存在时，get() 返回空值 None，明确地提示该键不存在，设置 get() 的第二个参数。 12a = dict(two=0.65, one=88, three=100, four=-59)print( a.get(&#x27;five&#x27;, &#x27;该键不存在&#x27;) ) 删除字典使用 del 关键字。 123a = dict(two=0.65, one=88, three=100, four=-59)print(a)del a 判断字典中是否存在指定键值对可以使用 in 或 not in 运算符。in 或 not in 运算符都是基于 key 来判断的。 12345a = &#123;&#x27;数学&#x27;: 95, &#x27;语文&#x27;: 89, &#x27;英语&#x27;: 90&#125;# 判断 a 中是否包含名为&#x27;数学&#x27;的keyprint(&#x27;数学&#x27; in a) # True# 判断 a 是否包含名为&#x27;物理&#x27;的keyprint(&#x27;物理&#x27; in a) # False keys()、values() 和 items() 方法获取字典中的特定数据： keys() 方法用于返回字典中的所有键（key）； values() 方法用于返回字典中所有键对应的值（value）； items() 用于返回字典中所有的键值对（key-value）。 keys()、values() 和 items() 返回值的类型分别为 dict_keys、dict_values 和 dict_items。 list() 函数，将它们返回的数据转换成列表。 使用 for in 循环遍历它们的返回值。 12345678a = &#123;&#x27;数学&#x27;: 95, &#x27;语文&#x27;: 89, &#x27;英语&#x27;: 90&#125;b = list(a.keys())for k in a.keys(): print(k,end=&#x27; &#x27;) for k,v in a.items(): print(&quot;key:&quot;,k,&quot; value:&quot;,v) copy() 方法返回一个字典的拷贝，返回一个具有相同键值对的新字典。 copy() 方法所遵循的拷贝原理，既有深拷贝，也有浅拷贝。对最表层的键值对进行深拷贝，对于某些列表类型的值来说，此方法对其做的是浅拷贝。 123a = &#123;&#x27;one&#x27;: 1, &#x27;two&#x27;: 2, &#x27;three&#x27;: [1,2,3]&#125;b = a.copy()print(b) set集合用来保存不重复的元素，即集合中的元素都是唯一的。集合会将所有元素放在一对大括号 {} 。 同一集合中，只能存储不可变的数据类型，包括整形、浮点型、字符串、元组，无法存储列表、字典、集合这些可变的数据类型。set 集合是无序的，所以每次输出时元素的排序顺序可能都不相同。 创建集合使用 {} 创建。 12a = &#123;1,&#x27;c&#x27;,1,(1,2,3),&#x27;c&#x27;&#125;print(a) set()函数创建集合。 123set1 = set(&quot;c.biancheng.net&quot;)set2 = set([1,2,3,4,5])set3 = set((1,2,3,4,5)) 空集合，只能使用 set() 函数实现。因为直接使用一对 {}，Python 解释器会将其视为一个空字典。 访问元素使用循环结构，将集合中的数据逐一读取出来。 123a = &#123;1,&#x27;c&#x27;,1,(1,2,3),&#x27;c&#x27;&#125;for ele in a: print(ele,end=&#x27; &#x27;) 删除set集合使用 del() 语句。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://peapod.top/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"python","slug":"python","permalink":"http://peapod.top/tags/python/"}],"author":"taweizhong"},{"title":"python入门","slug":"python入门","date":"2023-12-16T08:09:55.000Z","updated":"2023-12-16T08:44:08.000Z","comments":true,"path":"2023/12/16/python入门/","link":"","permalink":"http://peapod.top/2023/12/16/python%E5%85%A5%E9%97%A8/","excerpt":"","text":"编程基础编译型语言和解释型语言对于编译型语言来说，在执行之前先要经过编译器将源码转换成 CPU 可识别的机器码文件（比如 Windows 下的 .exe 文件）；解释型语言无需预先编译，而是由解释器逐行对源码进行解释，一边解释一边执行。 编译型语言 可执行程序不能跨平台 源代码不能跨平台 解释型语言 一次编写，到处运行 解释型语言的执行效率天生就低于编译型语言 字符集和字符编码Unicode 字符集又称万国码、国际码、统一码等。从名字就可以看出来，它是以统一符号为目标的字符集。 字符集定义了字符和二进制的对应关系，为每个字符分配了唯一的编号。可以将字符集理解成一个很大的表格，它列出了所有字符和二进制的对应关系，计算机显示文字或者存储文字，就是一个查表的过程； 字符编码规定了如何将字符的编号存储到计算机中，为了区分一个字符到底使用了几个字节，就不能将字符的编号直接存储到计算机中，字符编号在存储之前必须要经过转换，在读取时还要再逆向转换一次，这套转换方案就叫做字符编码。 UTF-8 是目前使用最广的一种 Unicode字符集的实现方式。Python 默认采用 UTF-8 编码。 注释解释器在执行代码时会忽略注释，不做任何处理，就好像它不存在一样。 在调试（Debug）程序的过程中，注释还可以用来临时移除无用的代码。 一般情况下，合理的代码注释应该占源代码的 1&#x2F;3 左右。 单行注释Python 使用井号#作为单行注释的符号 123# 注释# 说明单行代码的功能时一般将注释放在代码的右侧print( 100 % 7 ) # 输出余数 多行注释Python 使用三个连续的单引号’’’或者三个连续的双引号”””注释多行内容 12345&#x27;&#x27;&#x27;使用 3 个单引号分别作为注释的开头和结尾可以一次性注释多行内容这里面的内容全部是注释内容&#x27;&#x27;&#x27; 当注释符作为字符串的一部分出现时，就不能再将它们视为注释标记，而应该看做正常代码的一部分 缩进规则通常情况下都是采用 4 个空格长度作为一个缩进量（默认情况下，一个 Tab 键就表示 4 个空格）。 通过设置多行代码的缩进量，可以使用 Ctrl+] 和 Ctrl+[ 快捷键，此快捷键可以使所选中代码快速缩进（或反缩进）。 编码规范Python 采用 PEP 8 作为编码规范，其中 PEP 是 Python Enhancement Proposal（Python 增强建议书）的缩写，8 代表的是 Python 代码的样式指南。 每个 import 语句只导入一个模块，尽量避免一次导入多个模块 不要在行尾添加分号，也不要用分号将两条命令放在同一行 建议每行不超过 80 个字符，如果超过，建议使用小括号将多行内容隐式的连接起来，而不推荐使用反斜杠 \\ 进行连接。 使用必要的空行可以增加代码的可读性 在运算符两侧、函数参数之间以及逗号两侧，都建议使用空格进行分隔。 标识符命名规范 标识符是由字符（AZ 和 az）、下划线和数字组成，但第一个字符不能是数字。 标识符不能和 Python 中的保留字相同。有关保留字，后续章节会详细介绍。 Python中的标识符中，不能包含空格、@、% 以及 $ 等特殊字符。 字母是严格区分大小写 以下划线开头的标识符有特殊含义 当标识符用作模块名时，应尽量短小，并且全部使用小写字母，可以使用下划线分割多个字母，例如 game_mian、game_register 等。 当标识符用作包的名称时，应尽量短小，也全部使用小写字母，不推荐使用下划线，例如 com.mr、com.mr.book 等。 当标识符用作类名时，应采用单词首字母大写的形式。 模块内部的类名，可以采用 “下划线+首字母大写” 的形式。 函数名、类中的属性名和方法名，应全部使用小写字母，多个单词之间可以用下划线分割。 常量命名应全部使用大写字母，单词之间可以用下划线分割。 变量类型变量定义与使用将数据放入变量的过程叫做赋值。 1name = value Python 是弱类型的语言 弱类型语言两个特点： 变量无须声明就可以直接赋值，对一个不存在的变量赋值就相当于定义了一个新变量。 变量的数据类型可以随时改变，比如，同一个变量可以一会儿被赋值为整数，一会儿被赋值为字符串。 弱类型是说在书写代码时不用刻意关注类型，但是在编程语言的内部仍然是有类型的。 int整数就是没有小数部分的数字，Python 中的整数包括正整数、0 和负整数。 Python 整数的取值范围是无限的，不管多大或者多小的数字。 float小数通常以浮点数的形式存储。 print 在输出浮点数时，会根据浮点数的长度和大小适当的舍去一部分数字，或者采用科学计数法。 string若干个字符的集合就是一个字符串（String）。必须由双引号&quot; &quot;或者单引号&#39; &#39;包围。 字符串的内容可以包含字母、标点、特殊符号、中文、日文等全世界的所有文字。 要想换行书写一个比较长的字符串，必须在行尾添加反斜杠\\。 123s2 = &#x27;It took me six months to write this Python tutorial. \\ Please give me more support. \\ I will keep it updated.&#x27; 也支持表达式的换行。 123num = 20 + 3 / 4 + \\ 2 * 3print(num) 长字符串中的换行、空格、缩进等空白符都会原样输出。 1234longstr = &#x27;&#x27;&#x27;It took me 6 months to write this Python tutorial.Please give me a to &#x27;thumb&#x27; to keep it updated.The Python tutorial is available at http://c.biancheng.net/python/.&#x27;&#x27;&#x27;print(longstr) 在普通字符串或者长字符串的开头加上r前缀，就变成了原始字符串。 12str1 = r&#x27;原始字符串内容&#x27;str2 = r&quot;&quot;&quot;原始字符串内容&quot;&quot;&quot; bytesbytes 类型用来表示一个字节串。 字节串（bytes）和字符串（string）的对比： 字符串由若干个字符组成，以字符为单位进行操作；字节串由若干个字节组成，以字节为单位进行操作。 字节串和字符串除了操作的数据单元不同之外，它们支持的所有方法都基本相同。 字节串和字符串都是不可变序列，不能随意增加和删除数据。 bytes 只是简单地记录内存中的原始数据。 字符串的内容都是 ASCII 字符，直接在字符串前面添加b前缀就可以转换成 bytes。 调用构造方法 bytes()，可以将字符串按照指定的字符集转换成 bytes；如果不指定字符集，那么默认采用 UTF-8。 字符串 encode() 方法，该方法专门用来将字符串按照指定的字符集转换成对应的字节串；如果不指定字符集，那么默认采用 UTF-8。 使用不同方式创建 bytes 对象。 1234567b1 = bytes()b2 = b&quot;&quot;#为 bytes() 方法指定字符集b4 = bytes(&#x27;C语言中文网8岁了&#x27;, encoding=&#x27;UTF-8&#x27;)print(&quot;b4: &quot;, b4)#通过 encode() 方法将字符串转换成 bytesb5 = &quot;C语言中文网8岁了&quot;.encode(&#x27;UTF-8&#x27;) bytes decode() 方法，通过该方法可以将 bytes 对象转换为字符串。 123#通过 decode() 方法将 bytes 转换成字符串str1 = b5.decode(&#x27;UTF-8&#x27;)print(&quot;str1: &quot;, str1) 对于非 ASCII 字符，print 输出的是它的字符编码值（十六进制形式），而不是字符本身。 bool布尔类型可以当做整数来对待，即 True 相当于整数值 1，False 相当于整数值 0。 类型转换 函 数 作 用 int(x) 将 x 转换成整数类型 float(x) 将 x 转换成浮点数类型 complex(real，[,imag]) 创建一个复数 str(x) 将 x 转换为字符串 repr(x) 将 x 转换为表达式字符串 eval(str) 计算在字符串中的有效 Python 表达式，并返回一个对象 chr(x) 将整数 x 转换为一个字符 ord(x) 将一个字符 x 转换为它对应的整数值 hex(x) 将一个整数 x 转换为一个十六进制字符串 oct(x) 将一个整数 x 转换为一个八进制的字符串","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://peapod.top/tags/python/"}]},{"title":"go-zero使用","slug":"go-zero使用","date":"2023-10-25T01:44:21.000Z","updated":"2023-10-25T02:06:21.000Z","comments":true,"path":"2023/10/25/go-zero使用/","link":"","permalink":"http://peapod.top/2023/10/25/go-zero%E4%BD%BF%E7%94%A8/","excerpt":"","text":"go-zero使用api domo使用 go-zero 创建一个简单的 HTTP 服务。 1goctl api new demo ~/workspace/api/demo/internal/logic/demologic.go 文件，编辑该文件，在 27 至 28 行添加如下代码： 12resp = new(types.Response)resp.Message = req.Name 启动服务 12go mod tidygo run demo.go grpc dome生成最小化的 gRPC 服务 1goctl rpc new gdemo ~/workspace/rpc/demo/internal/logic/pinglogic.go 文件，编辑该文件，将 29 行替换为如下代码： 123return &amp;demo.Response&#123; Pong:&quot;pong&quot;,&#125;, nil ~/workspace/rpc/demo/etc/demo.yaml，删除 3 至 7 行内容，然后在追加内容 Mode: dev 至末尾，使配置文件内容为： 123Name: demo.rpcListenOn: 0.0.0.0:8080Mode: dev 启动服务 12go mod tidygo run gdome.go","categories":[],"tags":[]},{"title":"go-zero入门","slug":"go-zero入门","date":"2023-10-25T01:32:56.000Z","updated":"2023-10-25T02:33:40.000Z","comments":true,"path":"2023/10/25/go-zero入门/","link":"","permalink":"http://peapod.top/2023/10/25/go-zero%E5%85%A5%E9%97%A8/","excerpt":"","text":"go-zero简介go-zero 是一个集成了各种工程实践的 web 和 rpc 框架。 保持简单，第一原则 弹性设计，面向故障编程 工具大于约定和文档 高可用 高并发 易扩展 对业务开发友好，封装复杂度 约束做一件事只有一种方式 有如下主要特点： 强大的工具支持，尽可能少的代码编写 极简的接口 完全兼容 net&#x2F;http 支持中间件，方便扩展 高性能 面向故障编程，弹性设计 内建服务发现、负载均衡 内建限流、熔断、降载，且自动触发，自动恢复 API 参数自动校验 超时级联控制 自动缓存控制 链路跟踪、统计报警等 高并发支撑，稳定保障了疫情期间每天的流量洪峰 使用1.安装go-zero 12GO111MODULE=on GOPROXY=https://goproxy.cn/,direct go get -u github.com/zeromicro/go-zero 2.安装go-ctl工具 12GOPROXY=https://goproxy.cn/,direct go install github.com/zeromicro/go-zero/tools/goctl@latest","categories":[],"tags":[{"name":"微服务框架","slug":"微服务框架","permalink":"http://peapod.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/"}]},{"title":"fmt库","slug":"fmt库","date":"2023-10-07T03:14:16.000Z","updated":"2023-10-07T07:51:10.000Z","comments":true,"path":"2023/10/07/fmt库/","link":"","permalink":"http://peapod.top/2023/10/07/fmt%E5%BA%93/","excerpt":"","text":"fmt库使用Print、Printf、PrintlnPrint函数直接输出内容，Printf函数支持格式化输出字符串，Println函数会在输出内容的结尾添加一个换行符。 Fprint将内容输出到一个io.Writer接口类型的变量w中，通常用这个函数往文件中写入内容。 12345678910fmt.Fprintln(os.Stdout, &quot;向标准输出写入内容&quot;)fileObj, err := os.OpenFile(&quot;./xx.txt&quot;, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)if err != nil &#123; fmt.Println(&quot;打开文件出错，err:&quot;, err) return&#125;name := &quot;枯藤&quot;// 向打开的文件句柄中写入内容fmt.Fprintf(fileObj, &quot;往文件中写如信息：%s&quot;, name) SprintSprint系列函数会把传入的数据生成并返回一个字符串。 Errorf根据format参数生成格式化字符串并返回一个包含该字符串的错误。 1func Errorf(format string, a ...interface&#123;&#125;) error 格式化占位符 占位符 说明 %v 值的默认格式表示 %+v 类似%v，但输出结构体时会添加字段名 %#v 值的Go语法表示 %T 打印值的类型 %% 百分号 %t true或false %b 表示为二进制 %c 该值对应的unicode码值 %d 表示为十进制 %o 表示为八进制 %x 表示为十六进制，使用a-f %X 表示为十六进制，使用A-F %U 表示为Unicode格式：U+1234，等价于”U+%04X” %q 该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示 %b 无小数部分、二进制指数的科学计数法，如-123456p-78 %e 科学计数法，如-1234.456e+78 %E 科学计数法，如-1234.456E+78 %f 有小数部分但无指数部分，如123.456 %F 等价于%f %g 根据实际情况采用%e或%f格式（以获得更简洁、准确的输出） %G 根据实际情况采用%E或%F格式（以获得更简洁、准确的输出） %s 直接输出字符串或者[]byte %q 该值对应的双引号括起来的go语法字符串字面值，必要时会采用安全的转义表示 %x 每个字节用两字符十六进制数表示（使用a-f %X 每个字节用两字符十六进制数表示（使用A-F） %f 默认宽度，默认精度 %9f 宽度9，默认精度 %.2f 默认宽度，精度2 %9.2f 宽度9，精度2 ’+’ 总是输出数值的正负号；对%q（%+q）会生成全部是ASCII字符的输出（通过转义）； ’ ‘ 对数值，正数前加空格而负数前加负号；对字符串采用%x或%X时（% x或% X）会给各打印的字节之间加空格 ’-’ 在输出右边填充空白而不是默认的左边（即从默认的右对齐切换为左对齐）； ’#’ 八进制数前加0（%#o），十六进制数前加0x（%#x）或0X（%#X），指针去掉前面的0x（%#p）对%q（%#q），对%U（%#U）会输出空格和单引号括起来的go字面值； ‘0’ 使用0而不是空格填充，对于数值类型会把填充的0放在正负号后面； 输入一行bufio.NewReader完整获取输入的内容，而输入的内容可能包含空格，这种情况下可以使用bufio包来实现. 1234567func bufioDemo() &#123; reader := bufio.NewReader(os.Stdin) // 从标准输入生成读对象 fmt.Print(&quot;请输入内容：&quot;) text, _ := reader.ReadString(&#x27;\\n&#x27;) // 读到换行 text = strings.TrimSpace(text) fmt.Printf(&quot;%#v\\n&quot;, text)&#125;","categories":[{"name":"每日一库","slug":"每日一库","permalink":"http://peapod.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%BA%93/"}],"tags":[{"name":"标准库","slug":"标准库","permalink":"http://peapod.top/tags/%E6%A0%87%E5%87%86%E5%BA%93/"}],"author":"taweizhong"},{"title":"终端使用代理","slug":"终端使用代理","date":"2023-10-06T12:00:44.000Z","updated":"2024-02-28T02:21:36.673Z","comments":true,"path":"2023/10/06/终端使用代理/","link":"","permalink":"http://peapod.top/2023/10/06/%E7%BB%88%E7%AB%AF%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86/","excerpt":"","text":"终端使用代理命令12export http_proxy=http://127.0.0.1:7890export https_proxy=$http_proxy shell脚本12345678910function proxy_on() &#123; export http_proxy=http://127.0.0.1:7890 export https_proxy=\\$http_proxy echo -e &quot;终端代理已开启。&quot;&#125;function proxy_off()&#123; unset http_proxy https_proxy echo -e &quot;终端代理已关闭。&quot;&#125; 通过 proxy_on 启动代理，proxy_off 关闭代理。 1234# ~/.zprofilevim ~/.zshrc# 在文件后添加上面的脚本source ~/.zshrc 查看使用的是哪个shell123echo $SHELL# 安装了哪些shellcat /etc/shells bash和zsh的区别zsh能基本完美兼容bash的命令，并且使用起来更加优雅。由于bash或zsh本质上都是解释器，他们所共同服务的是shell语言，因此在命令语法上基本相同。 二者切换： 切换bash： chsh -s /bin/bash 切换zsh： chsh -s /bin/zsh 在终端app的系统偏好设置里手动设置。 配置文件： bash读取的配置文件：~/.bash_profile文件 zsh读取的配置文件：~/.zshrc文件 当从bash切换为zsh时，如果不想重新配置一遍.zshrc文件，可以__在.zshrc文件中加上source ~/.bash_profile。","categories":[],"tags":[]},{"title":"etcd集群搭建","slug":"etcd集群搭建","date":"2023-10-06T11:55:02.000Z","updated":"2023-10-06T11:56:09.000Z","comments":true,"path":"2023/10/06/etcd集群搭建/","link":"","permalink":"http://peapod.top/2023/10/06/etcd%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/","excerpt":"","text":"etcd集群搭建1234567etcd --name infra0 --initial-advertise-peer-urls http://127.0.0.1:12380 \\ --listen-peer-urls http://127.0.0.1:12380 \\ --listen-client-urls http://127.0.0.1:12379,http://127.0.0.1:12379 \\ --advertise-client-urls http://127.0.0.1:12379 \\ --initial-cluster-token etcd-cluster-1 \\ --initial-cluster infra0=http://127.0.0.1:12380,infra1=http://127.0.0.1:22380,infra2=http://127.0.0.1:32380 \\ --initial-cluster-state new 1234567etcd --name infra1 --initial-advertise-peer-urls http://127.0.0.1:22380 \\ --listen-peer-urls http://127.0.0.1:22380 \\ --listen-client-urls http://127.0.0.1:22379,http://127.0.0.1:22379 \\ --advertise-client-urls http://127.0.0.1:22379 \\ --initial-cluster-token etcd-cluster-1 \\ --initial-cluster infra0=http://127.0.0.1:12380,infra1=http://127.0.0.1:22380,infra2=http://127.0.0.1:32380 \\ --initial-cluster-state new 1234567etcd --name infra2 --initial-advertise-peer-urls http://127.0.0.1:32380 \\ --listen-peer-urls http://127.0.0.1:32380 \\ --listen-client-urls http://127.0.0.1:32379,http://127.0.0.1:32379 \\ --advertise-client-urls http://127.0.0.1:32379 \\ --initial-cluster-token etcd-cluster-1 \\ --initial-cluster infra0=http://127.0.0.1:12380,infra1=http://127.0.0.1:22380,infra2=http://127.0.0.1:32380 \\ --initial-cluster-state new","categories":[],"tags":[]},{"title":"Go并发-上","slug":"Go并发-上","date":"2023-10-02T12:53:23.000Z","updated":"2024-03-17T06:44:47.826Z","comments":true,"path":"2023/10/02/Go并发-上/","link":"","permalink":"http://peapod.top/2023/10/02/Go%E5%B9%B6%E5%8F%91-%E4%B8%8A/","excerpt":"","text":"Go并发-上基本概念123进程是程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位。线程是进程的一个执行实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。一个进程可以创建和撤销多个线程;同一个进程中的多个线程之间可以并发执行。 123456多线程程序在一个核的cpu上运行，就是并发。多线程程序在多个核的cpu上运行，就是并行。 协程：独立的栈空间，共享堆空间，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级线程的调度也是自己实现的。线程：一个线程上可以跑多个协程，协程是轻量级的线程。并发主要由切换时间片来实现”同时”运行，并行则是直接利用多核实现多线程的运行，go可以设置使用核数，以发挥多核计算机的能力。 Goroutine goroutine是由Go的运行时（runtime）调度和管理的。Go程序会智能地将 goroutine 中的任务合理地分配给每个CPU。Go语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。 一个goroutine必定对应一个函数，可以创建多个goroutine去执行相同的函数。 在程序启动时，Go程序就会为main()函数创建一个默认的goroutine。 goroutine与线程OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个goroutine的栈在其生命周期开始时只有很小的栈（典型情况下2KB）。 GPM goroutine，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。 P管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。 M（machine）是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系， 一个groutine最终是要放到M上执行的； P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G 挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。 其一大特点是goroutine的调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。 一个操作系统线程对应用户态多个goroutine。 go程序可以同时使用多个操作系统线程。 goroutine和OS线程是多对多的关系，即m:n。 channel函数与函数间需要交换数据才能体现并发执行函数的意义。 为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。 Go语言的并发模型是CSP（Communicating Sequential Processes），提倡通过通信共享内存而不是通过共享内存而实现通信。 channel是可以让一个goroutine发送特定值到另一个goroutine的通信机制。 channel是一种类型，一种引用类型。声明通道类型的格式如下： 1var 变量类型 chan 元素类型 只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。 无缓冲的通道只有在有人接收值的时候才能发送值。无缓冲的通道必须有接收才能发送。使用无缓冲通道进行通信将导致发送和接收的goroutine同步化。因此，无缓冲通道也被称为同步通道。 只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。","categories":[{"name":"golang标准库","slug":"golang标准库","permalink":"http://peapod.top/categories/golang%E6%A0%87%E5%87%86%E5%BA%93/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://peapod.top/tags/Go/"}],"author":"taweizhong"},{"title":"Go反射","slug":"Go反射","date":"2023-10-02T11:53:59.000Z","updated":"2023-10-02T12:53:12.000Z","comments":true,"path":"2023/10/02/Go反射/","link":"","permalink":"http://peapod.top/2023/10/02/Go%E5%8F%8D%E5%B0%84/","excerpt":"","text":"Go反射在运行时更新和检查变量的值、调用变量的方法和变量支持的内在操作，但是在编译时并不知道这些变量的具体类型，这种机制被称为反射。 reflect 包来访问程序的反射信息。 定义了两个重要的类型 Type 和 Value 任意接口值在反射中都可以理解为由 reflect.Type 和 reflect.Value 两部分组成， reflect 包提供了 reflect.TypeOf 和 reflect.ValueOf 两个函数来获取任意对象的 Value 和 Type。 反射的类型对象（reflect.Type）12345678910package mainimport ( &quot;fmt&quot; &quot;reflect&quot;)func main() &#123; var a int typeOfA := reflect.TypeOf(a) fmt.Println(typeOfA.Name(), typeOfA.Kind())&#125; Go语言中的类型名称对应的反射获取方法是 reflect.Type 中的 Name() 方法，返回表示类型名称的字符串；类型归属的种类（Kind）使用的是 reflect.Type 中的 Kind() 方法，返回 reflect.Kind 类型的常量。 Go语言程序中对指针获取反射对象时，可以通过 reflect.Elem() 方法获取这个指针指向的元素类型，这个获取过程被称为取元素，等效于对指针类型变量做了一个*操作","categories":[],"tags":[]},{"title":"Go对象","slug":"Go对象","date":"2023-10-02T10:45:28.000Z","updated":"2024-02-27T10:46:38.765Z","comments":true,"path":"2023/10/02/Go对象/","link":"","permalink":"http://peapod.top/2023/10/02/Go%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"第8章：对象匿名字段提供类型而不写字段名的方式，也就是匿名字段，也称为嵌入字段 12345678910111213141516171819202122232425262728package mainimport &quot;fmt&quot;//go支持只提供类型而不写字段名的方式，也就是匿名字段，也称为嵌入字段type Person struct &#123; name string sex string age int&#125;type Student struct &#123; Person id int addr string&#125;func main() &#123; // 初始化 s1 := Student&#123;Person&#123;&quot;5lmh&quot;, &quot;man&quot;, 20&#125;, 1, &quot;bj&quot;&#125; fmt.Println(s1) s2 := Student&#123;Person: Person&#123;&quot;5lmh&quot;, &quot;man&quot;, 20&#125;&#125; fmt.Println(s2) s3 := Student&#123;Person: Person&#123;name: &quot;5lmh&quot;&#125;&#125; fmt.Println(s3)&#125; 所有的内置类型和自定义类型都是可以作为匿名字段去使用 接口接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节。 在Go语言中接口（interface）是一种类型，一种抽象的类型。 接口定义123456接口是一个或多个方法签名的集合。任何类型的方法集中只要拥有该接口&#x27;对应的全部方法&#x27;签名。就表示它 &quot;实现&quot; 了该接口，无须在该类型上显式声明实现了哪个接口。接口可以匿名嵌入其他接口，或嵌入到结构中。只有当接口存储的类型和对象都为nil时，接口才等于nil。空接口可以作为任何类型数据的容器。 12345type 接口类型名 interface&#123; 方法名1( 参数列表1 ) 返回值列表1 方法名2( 参数列表2 ) 返回值列表2 … &#125; 一个对象只要全部实现了接口中的方法，那么就实现了这个接口。 接口类型变量能够存储所有实现了该接口的实例。 使用值接收者实现接口之后，不管是dog结构体还是结构体指针*dog类型的变量都可以赋值给该接口变量。因为Go语言中有对指针类型变量求值的语法糖. 指针接收者实现接口 12345678910func (d *dog) move() &#123; fmt.Println(&quot;狗会动&quot;)&#125;func main() &#123; var x Mover var wangcai = dog&#123;&#125; // 旺财是dog类型 x = wangcai // x不可以接收dog类型 var fugui = &amp;dog&#123;&#125; // 富贵是*dog类型 x = fugui // x可以接收*dog类型&#125; 此时实现Mover接口的是*dog类型，所以不能给x传入dog类型的wangcai，此时x只能存储*dog类型的值。 一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。 Go语言中不同的类型还可以实现同一接口. 一个接口的方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。 接口与接口间可以通过嵌套创造出新的接口。 空接口空接口是指没有定义任何方法的接口。因此任何类型都实现了空接口。 空接口类型的变量可以存储任意类型的变量。 空接口作为函数的参数 空接口作为map的值 类型断言一个接口的值（简称接口值）是由一个具体类型和具体类型的值两部分组成的。这两部分分别称为接口的动态类型和动态值。 判断空接口中的值这个时候就可以使用类型断言，其语法格式： 123 x.(T) x：表示类型为interface&#123;&#125;的变量T：表示断言x可能是的类型。 返回两个参数，第一个参数是x转化为T类型后的变量，第二个值是一个布尔值，若为true则表示断言成功，为false则表示断言失败。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://peapod.top/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://peapod.top/tags/Go/"}],"author":"taweizhong"},{"title":"Go方法","slug":"Go方法","date":"2023-10-02T10:21:35.000Z","updated":"2023-10-02T10:45:17.000Z","comments":true,"path":"2023/10/02/Go方法/","link":"","permalink":"http://peapod.top/2023/10/02/Go%E6%96%B9%E6%B3%95/","excerpt":"","text":"第7章：方法方法定义方法总是绑定对象实例，并隐式将实例作为第一实参 (receiver)。 一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。 123func (recevier type) methodName(参数列表)(返回值列表)&#123;&#125; 参数和返回值可以省略 匿名字段可以像字段成员那样访问匿名字段方法，编译器负责查找。 通过匿名字段，可获得和继承类似的复用能力。依据编译器查找次序，只需在外层定义同名方法，就可以实现 “override”。 1234567891011121314151617181920212223242526272829package mainimport &quot;fmt&quot;type User struct &#123; id int name string&#125;type Manager struct &#123; User title string&#125;func (self *User) ToString() string &#123; return fmt.Sprintf(&quot;User: %p, %v&quot;, self, self)&#125;func (self *Manager) ToString() string &#123; return fmt.Sprintf(&quot;Manager: %p, %v&quot;, self, self)&#125;func main() &#123; m := Manager&#123;User&#123;1, &quot;Tom&quot;&#125;, &quot;Administrator&quot;&#125; fmt.Println(m.ToString()) fmt.Println(m.User.ToString())&#125;","categories":[],"tags":[]},{"title":"Validator 参数验证","slug":"Validator参数验证","date":"2023-06-24T02:18:58.000Z","updated":"2023-06-24T02:49:14.000Z","comments":true,"path":"2023/06/24/Validator参数验证/","link":"","permalink":"http://peapod.top/2023/06/24/Validator%E5%8F%82%E6%95%B0%E9%AA%8C%E8%AF%81/","excerpt":"","text":"Validator 参数验证Validator 简介Validator 是基于 tag（标记）实现结构体和单个字段的值验证库，它包含以下功能： 使用验证 tag（标记）或自定义验证器进行跨字段和跨结构体验证。 关于 slice、数组和 map，允许验证多维字段的任何或所有级别。 能够深入 map 键和值进行验证。 通过在验证之前确定接口的基础类型来处理类型接口。 处理自定义字段类型（如 sql 驱动程序 Valuer）。 别名验证标记，它允许将多个验证映射到单个标记，以便更轻松地定义结构体上的验证。 提取自定义的字段名称，例如，可以指定在验证时提取 JSON 名称，并在生成的 FieldError 中使用该名称。 可自定义 i18n 错误消息。 Web 框架 gin 的默认验证器。 安装1go get github.com/go-playground/validator/v10 使用单个变量验证1234567891011func main() &#123; validate := validator.New() // 验证变量 email := &quot;admin#admin.com&quot; err := validate.Var(email, &quot;required,email&quot;) if err != nil &#123; validationErrors := err.(validator.ValidationErrors) fmt.Println(validationErrors) return &#125;&#125; 结构体1234567891011121314151617181920212223func main() &#123; validate = validator.New() type User struct &#123; ID int64 `json:&quot;id&quot; validate:&quot;gt=0&quot;` Name string `json:&quot;name&quot; validate:&quot;required&quot;` Gender string `json:&quot;gender&quot; validate:&quot;required,oneof=man woman&quot;` Age uint8 `json:&quot;age&quot; validate:&quot;required,gte=0,lte=130&quot;` Email string `json:&quot;email&quot; validate:&quot;required,email&quot;` &#125; user := &amp;User&#123; ID: 1, Name: &quot;frank&quot;, Gender: &quot;boy&quot;, Age: 180, Email: &quot;gopher@88.com&quot;, &#125; err = validate.Struct(user) if err != nil &#123; validationErrors := err.(validator.ValidationErrors) fmt.Println(validationErrors) return &#125;&#125; 错误信息翻译为中文安装翻译包12go get -u github.com/go-playground/localesgo get -u github.com/go-playground/universal-translator 导入1234&quot;github.com/go-playground/locales/zh&quot;ut &quot;github.com/go-playground/universal-translator&quot;&quot;github.com/go-playground/validator/v10&quot;zh_translations &quot;github.com/go-playground/validator/v10/translations/zh&quot; 使用12345678910111213141516171819202122232425262728293031323334353637383940func main() &#123; // 实例化验证器 validate := validator.New() type User struct &#123; ID int64 `json:&quot;id&quot; validate:&quot;gt=0&quot;` Name string `json:&quot;name&quot; validate:&quot;required&quot;` Gender string `json:&quot;gender&quot; validate:&quot;required,oneof=man woman&quot;` Age uint8 `json:&quot;age&quot; validate:&quot;required,gte=0,lte=130&quot;` Email string `json:&quot;email&quot; validate:&quot;required,email&quot;` &#125; user := &amp;User&#123; ID: 1, Name: &quot;frank&quot;, Gender: &quot;boy&quot;, Age: 180, Email: &quot;gopher@88.com&quot;, &#125; // 注册一个函数，获取结构体字段的备用名称 validate.RegisterTagNameFunc(func(fld reflect.StructField) string &#123; name := strings.SplitN(fld.Tag.Get(&quot;json&quot;), &quot;,&quot;, 2)[0] if name == &quot;-&quot; &#123; return &quot;j&quot; &#125; return name &#125;) // 中文翻译器 uni := ut.New(zh.New()) trans, _ := uni.GetTranslator(&quot;zh&quot;) // 注册翻译器到校验器 _ = zh_translations.RegisterDefaultTranslations(validate, trans) err := validate.Struct(user) if err != nil &#123; for _, err := range err.(validator.ValidationErrors) &#123; // 错误翻译 fmt.Println(err.Translate(trans)) &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"GRPC流的使用","slug":"GRPC流的使用","date":"2023-06-22T11:38:45.000Z","updated":"2023-06-22T12:19:42.000Z","comments":true,"path":"2023/06/22/GRPC流的使用/","link":"","permalink":"http://peapod.top/2023/06/22/GRPC%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"GRPC流的使用流传输方式简介客户端流客户端发送多次，服务端响应一次（关闭时响应）。 服务端流客户端先发送一次，服务端响应多次。 双向流客户端发送，服务端响应。 客户端流服务定义1rpc ClientStreamPing(stream PingRequest) returns (PingReply); 客户端123456789101112131415161718192021stream, err := client.SayStream(context.Background()) err = stream.Send(&amp;pd.HelloReq&#123; Name: &quot;111&quot;, Age: 3, &#125;) if err != nil &#123; fmt.Printf(err.Error()) &#125; stream.Send(&amp;pd.HelloReq&#123; Name: &quot;111&quot;, Age: 4, &#125;) stream.Send(&amp;pd.HelloReq&#123; Name: &quot;111&quot;, Age: 5, &#125;) recv, err := stream.CloseAndRecv() if err != nil &#123; return &#125; fmt.Printf(&quot;接受：%s&quot;, recv.Say) 创建客户端之后，调用服务生成流 使用流发送消息 关闭流并接受服务端的响应 服务端123456789101112131415func (s *Server) SayStream(stream pd.HelloServer_SayStreamServer) error &#123; for &#123; //源源不断的去接收客户端发来的信息 recv, err := stream.Recv() if err != nil &#123; if err == io.EOF &#123; break &#125; return err &#125; fmt.Println(&quot;服务端接收到的流&quot;, recv.Name, recv.Age) &#125; return stream.SendAndClose(&amp;pd.HelloRep&#123;Say: &quot;结束&quot;&#125;)&#125; 实现流的接口 接受客户端发送的消息 正常关闭时发送响应消息 服务端流服务定义1rpc ServerStreamPing(PingRequest) returns (stream PingReply); 客户端12345678910111213141516171819stream, err := client.SayStreamServer(context.Background(), &amp;pd.HelloReq&#123; Name: &quot;111&quot;, Age: 0, &#125;) for &#123; recv, err := stream.Recv() if err != nil &#123; if err == io.EOF &#123; fmt.Println(&quot;客户端数据接收完成&quot;) err := stream.CloseSend() if err != nil &#123; log.Fatal(err) &#125; break &#125; log.Fatal(err) &#125; fmt.Println(&quot;客户端收到的流&quot;, recv.Say) &#125; 服务端12345678910111213141516func (s *Server) SayStreamServer(req *pd.HelloReq, stream pd.HelloServer_SayStreamServerServer) error &#123; count := 0 fmt.Printf(req.Name, req.Age) for &#123; rsp := &amp;pd.HelloRep&#123;Say: &quot;server send&quot;&#125; err := stream.Send(rsp) if err != nil &#123; return err &#125; time.Sleep(time.Second) count++ if count &gt; 10 &#123; return nil &#125; &#125;&#125; 双向流服务定义1rpc SayDoubleStream(stream helloReq) returns (stream helloRep) &#123;&#125;; 客户端1234567891011121314151617181920stream, err := client.SayDoubleStream(context.Background()) var count int32 = 22 for &#123; request := &amp;pd.HelloReq&#123; Name: &quot;zzz&quot;, Age: count, &#125; err = stream.Send(request) count++ if err != nil &#123; log.Fatal(err) &#125; time.Sleep(time.Second) recv, err := stream.Recv() if err != nil &#123; log.Fatal(err) &#125; //websocket fmt.Println(&quot;客户端收到的流信息&quot;, recv.Say) &#125; 服务端123456789101112131415func (s *Server) SayDoubleStream(stream pd.HelloServer_SayDoubleStreamServer) error &#123; for &#123; recv, err := stream.Recv() if err != nil &#123; return nil &#125; fmt.Println(&quot;服务端收到客户端的消息&quot;, recv.Name, recv.Age) time.Sleep(time.Second) rsp := &amp;pd.HelloRep&#123;Say: fmt.Sprintf(&quot;%s的年龄：%d&quot;, recv.Name, recv.Age)&#125; err = stream.Send(rsp) if err != nil &#123; return nil &#125; &#125;&#125;","categories":[],"tags":[{"name":"微服务","slug":"微服务","permalink":"http://peapod.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}]},{"title":"GRPC使用openssl","slug":"GRPC使用openssl","date":"2023-06-22T03:08:18.000Z","updated":"2023-06-22T03:09:06.000Z","comments":true,"path":"2023/06/22/GRPC使用openssl/","link":"","permalink":"http://peapod.top/2023/06/22/GRPC%E4%BD%BF%E7%94%A8openssl/","excerpt":"","text":"GRPC使用openssl证书加密数据传输过程，保证调用的安全性。 证书生成自签证书（root CA）命令解析：https://blog.csdn.net/adminstate/article/details/128662641 生成私钥文件 1openssl genrsa -des3 -out private.key 2048 创建证书请求 1openssl req -new -key private.key -out ca.csr 生成ca.crt 1openssl x509 -req -days 365 -in ca.csr -signkey private.key -out ca.crt SAN证书参考：https://blog.csdn.net/a145127/article/details/126311442 SAN证书需要上述生成的根证书。 设置配置文件 终端openssl version -d可以查找配置文件 修改配置文件 生成服务器密钥和证书 12345678# 生成服务器私钥，密码输入123456$ openssl genpkey -algorithm RSA -out ../server/server.key # 使用私钥来签名证书$ openssl req -new -nodes -key ../server/server.key -out ../server/server.csr -config openssl.cnf -extensions &#x27;v3_req&#x27; # 生成SAN证书$ openssl x509 -req -in ../server/server.csr -out ../server/server.pem -CA ca.crt -CAkey private.key -CAcreateserial -extfile ./openssl.cnf -extensions &#x27;v3_req&#x27; 生成客户端密钥和证书 12345678# 生成客户端私钥，密码输入123456$ openssl genpkey -algorithm RSA -out ../client/client.key # 使用私钥来签名证书$ openssl req -new -nodes -key ../client/client.key -out ../client/client.csr -config openssl.cnf -extensions &#x27;v3_req&#x27; # 生成SAN证书$ openssl x509 -req -in ../client/client.csr -out ../client/client.pem -CA ca.crt -CAkey private.key -CAcreateserial -extfile ./openssl.cnf -extensions &#x27;v3_req&#x27; 目录结构 单项认证 服务端使用证书和私钥 1234567891011121314151617181920212223242526272829303132333435package mainimport ( &quot;context&quot; &quot;fmt&quot; &quot;google.golang.org/grpc&quot; &quot;google.golang.org/grpc/credentials&quot; pd &quot;grpc_helloworld/server/proto&quot; &quot;log&quot; &quot;net&quot;)type Server struct &#123; pd.UnimplementedHelloServerServer&#125;func (s *Server) Say(ctx context.Context, q *pd.HelloReq) (*pd.HelloRep, error) &#123; return &amp;pd.HelloRep&#123; Say: fmt.Sprintf(&quot;%s已经%d岁了&quot;, q.Name, q.Age), &#125;, nil&#125;func main() &#123; // 读取证书 file, _ := credentials.NewServerTLSFromFile(&quot;./server.pem&quot;, &quot;./server.key&quot;) listen, _ := net.Listen(&quot;tcp&quot;, &quot;:8080&quot;) // 创建服务并添加证书 newServer := grpc.NewServer(grpc.Creds(file)) pd.RegisterHelloServerServer(newServer, new(Server)) err := newServer.Serve(listen) if err != nil &#123; log.Print(&quot;err:&quot;, err) &#125;&#125; 客户端使用公钥(证书中有公钥) 123456789101112131415161718192021222324252627282930313233package mainimport ( &quot;context&quot; &quot;fmt&quot; &quot;google.golang.org/grpc&quot; &quot;google.golang.org/grpc/credentials&quot; pd &quot;grpc_helloworld/client/proto&quot; &quot;log&quot;)func main() &#123; // 添加证书 file, err2 := credentials.NewClientTLSFromFile(&quot;../server/server.pem&quot;, &quot;*.test.example.com&quot;) if err2 != nil &#123; log.Fatal(&quot;证书错误&quot;, err2) &#125; conn, err := grpc.Dial(&quot;:8080&quot;, grpc.WithTransportCredentials(file)) if err != nil &#123; fmt.Print(err) &#125; defer conn.Close() client := pd.NewHelloServerClient(conn) feature, err := client.Say(context.Background(), &amp;pd.HelloReq&#123; Name: &quot;hello&quot;, Age: 22, &#125;) if err != nil &#123; log.Print(err) &#125; fmt.Print(feature)&#125; 双向认证服务端1234567891011121314151617181920212223242526272829303132func main() &#123; cert, err := tls.LoadX509KeyPair(&quot;./server.pem&quot;, &quot;./server.key&quot;) if err != nil &#123; log.Fatal(&quot;证书读取错误&quot;, err) &#125; // 创建一个新的、空的 CertPool certPool := x509.NewCertPool() ca, err := ioutil.ReadFile(&quot;../encryption/ca.crt&quot;) if err != nil &#123; log.Fatal(&quot;ca证书读取错误&quot;, err) &#125; // 尝试解析所传入的 PEM 编码的证书。如果解析成功会将其加到 CertPool 中，便于后面的使用 certPool.AppendCertsFromPEM(ca) // 构建基于 TLS 的 TransportCredentials 选项 creds := credentials.NewTLS(&amp;tls.Config&#123; // 设置证书链，允许包含一个或多个 Certificates: []tls.Certificate&#123;cert&#125;, // 要求必须校验客户端的证书。可以根据实际情况选用以下参数 ClientAuth: tls.RequireAndVerifyClientCert, // 设置根证书的集合，校验方式使用 ClientAuth 中设定的模式 ClientCAs: certPool, &#125;) listen, _ := net.Listen(&quot;tcp&quot;, &quot;:8080&quot;) // 创建服务并添加证书 newServer := grpc.NewServer(grpc.Creds(creds)) pd.RegisterHelloServerServer(newServer, new(Server)) err = newServer.Serve(listen) if err != nil &#123; log.Print(&quot;err:&quot;, err) &#125;&#125; 客户端1234567891011121314151617181920212223242526272829303132func main() &#123; // 添加证书 cert, _ := tls.LoadX509KeyPair(&quot;./client.pem&quot;, &quot;./client.key&quot;) // 创建一个新的、空的 CertPool certPool := x509.NewCertPool() ca, _ := ioutil.ReadFile(&quot;../encryption/ca.crt&quot;) // 尝试解析所传入的 PEM 编码的证书。如果解析成功会将其加到 CertPool 中，便于后面的使用 certPool.AppendCertsFromPEM(ca) // 构建基于 TLS 的 TransportCredentials 选项 creds := credentials.NewTLS(&amp;tls.Config&#123; // 设置证书链，允许包含一个或多个 Certificates: []tls.Certificate&#123;cert&#125;, // 要求必须校验客户端的证书。可以根据实际情况选用以下参数 ServerName: &quot;*.test.example.com&quot;, RootCAs: certPool, &#125;) conn, err := grpc.Dial(&quot;:8080&quot;, grpc.WithTransportCredentials(creds)) if err != nil &#123; fmt.Print(err) &#125; defer conn.Close() client := pd.NewHelloServerClient(conn) feature, err := client.Say(context.Background(), &amp;pd.HelloReq&#123; Name: &quot;hello&quot;, Age: 22, &#125;) if err != nil &#123; log.Print(err) &#125; fmt.Print(feature)&#125; token认证服务端校验12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package mainimport ( &quot;context&quot; &quot;fmt&quot; &quot;google.golang.org/grpc&quot; &quot;google.golang.org/grpc/codes&quot; &quot;google.golang.org/grpc/metadata&quot; &quot;google.golang.org/grpc/status&quot; pd &quot;grpc_helloworld/server/proto&quot; &quot;log&quot; &quot;net&quot;)type Server struct &#123; pd.UnimplementedHelloServerServer&#125;func (s *Server) Say(ctx context.Context, q *pd.HelloReq) (*pd.HelloRep, error) &#123; return &amp;pd.HelloRep&#123; Say: fmt.Sprintf(&quot;%s已经%d岁了&quot;, q.Name, q.Age), &#125;, nil&#125;func main() &#123; var authInterceptor grpc.UnaryServerInterceptor authInterceptor = func( ctx context.Context, req interface&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler, ) (resp interface&#123;&#125;, err error) &#123; //拦截普通方法请求，验证 Token err = Auth(ctx) if err != nil &#123; return &#125; // 继续处理请求 return handler(ctx, req) &#125; listen, _ := net.Listen(&quot;tcp&quot;, &quot;:8080&quot;) // 创建服务并添加证书 newServer := grpc.NewServer(grpc.UnaryInterceptor(authInterceptor)) pd.RegisterHelloServerServer(newServer, new(Server)) err := newServer.Serve(listen) if err != nil &#123; log.Print(&quot;err:&quot;, err) &#125;&#125;func Auth(ctx context.Context) error &#123; md, ok := metadata.FromIncomingContext(ctx) if !ok &#123; return fmt.Errorf(&quot;missing credentials&quot;) &#125; var user string var password string if val, ok := md[&quot;user&quot;]; ok &#123; user = val[0] &#125; if val, ok := md[&quot;password&quot;]; ok &#123; password = val[0] &#125; if user != &quot;admin&quot; || password != &quot;123456&quot; &#123; return status.Errorf(codes.Unauthenticated, &quot;token不合法&quot;) &#125; return nil&#125; 客户端12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport ( &quot;context&quot; &quot;fmt&quot; &quot;google.golang.org/grpc&quot; &quot;google.golang.org/grpc/credentials/insecure&quot; pd &quot;grpc_helloworld/client/proto&quot; &quot;log&quot;)type Authentication struct &#123; User string Password string&#125;func (a *Authentication) GetRequestMetadata(context.Context, ...string) ( map[string]string, error,) &#123; return map[string]string&#123;&quot;user&quot;: a.User, &quot;password&quot;: a.Password&#125;, nil&#125;func (a *Authentication) RequireTransportSecurity() bool &#123; return false&#125;func main() &#123; user := &amp;Authentication&#123; User: &quot;admin&quot;, Password: &quot;123456&quot;, &#125; conn, err := grpc.Dial(&quot;:8080&quot;, grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithPerRPCCredentials(user)) if err != nil &#123; fmt.Print(err) &#125; defer conn.Close() client := pd.NewHelloServerClient(conn) feature, err := client.Say(context.Background(), &amp;pd.HelloReq&#123; Name: &quot;hello&quot;, Age: 22, &#125;) if err != nil &#123; log.Print(err) &#125; fmt.Print(feature)&#125;","categories":[],"tags":[{"name":"微服务","slug":"微服务","permalink":"http://peapod.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}]},{"title":"","slug":"openssl使用","date":"2023-06-22T02:57:27.000Z","updated":"2023-06-22T02:57:27.000Z","comments":true,"path":"2023/06/22/openssl使用/","link":"","permalink":"http://peapod.top/2023/06/22/openssl%E4%BD%BF%E7%94%A8/","excerpt":"","text":"GRPC使用openssl证书加密数据传输过程，保证调用的安全性。 证书生成自签证书（root CA）命令解析：https://blog.csdn.net/adminstate/article/details/128662641 生成私钥文件 1openssl genrsa -des3 -out private.key 2048 创建证书请求 1openssl req -new -key private.key -out ca.csr 生成ca.crt 1openssl x509 -req -days 365 -in ca.csr -signkey private.key -out ca.crt SAN证书参考：https://blog.csdn.net/a145127/article/details/126311442 SAN证书需要上述生成的根证书。 设置配置文件 终端openssl version -d可以查找配置文件 修改配置文件 生成服务器密钥和证书 12345678# 生成服务器私钥，密码输入123456$ openssl genpkey -algorithm RSA -out ../server/server.key # 使用私钥来签名证书$ openssl req -new -nodes -key ../server/server.key -out ../server/server.csr -config openssl.cnf -extensions &#x27;v3_req&#x27; # 生成SAN证书$ openssl x509 -req -in ../server/server.csr -out ../server/server.pem -CA ca.crt -CAkey private.key -CAcreateserial -extfile ./openssl.cnf -extensions &#x27;v3_req&#x27; 生成客户端密钥和证书 12345678# 生成客户端私钥，密码输入123456$ openssl genpkey -algorithm RSA -out ../client/client.key # 使用私钥来签名证书$ openssl req -new -nodes -key ../client/client.key -out ../client/client.csr -config openssl.cnf -extensions &#x27;v3_req&#x27; # 生成SAN证书$ openssl x509 -req -in ../client/client.csr -out ../client/client.pem -CA ca.crt -CAkey private.key -CAcreateserial -extfile ./openssl.cnf -extensions &#x27;v3_req&#x27; 目录结构 单项认证 服务端使用证书和私钥 1234567891011121314151617181920212223242526272829303132333435package mainimport ( &quot;context&quot; &quot;fmt&quot; &quot;google.golang.org/grpc&quot; &quot;google.golang.org/grpc/credentials&quot; pd &quot;grpc_helloworld/server/proto&quot; &quot;log&quot; &quot;net&quot;)type Server struct &#123; pd.UnimplementedHelloServerServer&#125;func (s *Server) Say(ctx context.Context, q *pd.HelloReq) (*pd.HelloRep, error) &#123; return &amp;pd.HelloRep&#123; Say: fmt.Sprintf(&quot;%s已经%d岁了&quot;, q.Name, q.Age), &#125;, nil&#125;func main() &#123; // 读取证书 file, _ := credentials.NewServerTLSFromFile(&quot;./server.pem&quot;, &quot;./server.key&quot;) listen, _ := net.Listen(&quot;tcp&quot;, &quot;:8080&quot;) // 创建服务并添加证书 newServer := grpc.NewServer(grpc.Creds(file)) pd.RegisterHelloServerServer(newServer, new(Server)) err := newServer.Serve(listen) if err != nil &#123; log.Print(&quot;err:&quot;, err) &#125;&#125; 客户端使用公钥(证书中有公钥) 123456789101112131415161718192021222324252627282930313233package mainimport ( &quot;context&quot; &quot;fmt&quot; &quot;google.golang.org/grpc&quot; &quot;google.golang.org/grpc/credentials&quot; pd &quot;grpc_helloworld/client/proto&quot; &quot;log&quot;)func main() &#123; // 添加证书 file, err2 := credentials.NewClientTLSFromFile(&quot;../server/server.pem&quot;, &quot;*.test.example.com&quot;) if err2 != nil &#123; log.Fatal(&quot;证书错误&quot;, err2) &#125; conn, err := grpc.Dial(&quot;:8080&quot;, grpc.WithTransportCredentials(file)) if err != nil &#123; fmt.Print(err) &#125; defer conn.Close() client := pd.NewHelloServerClient(conn) feature, err := client.Say(context.Background(), &amp;pd.HelloReq&#123; Name: &quot;hello&quot;, Age: 22, &#125;) if err != nil &#123; log.Print(err) &#125; fmt.Print(feature)&#125; 双向认证服务端1234567891011121314151617181920212223242526272829303132func main() &#123; cert, err := tls.LoadX509KeyPair(&quot;./server.pem&quot;, &quot;./server.key&quot;) if err != nil &#123; log.Fatal(&quot;证书读取错误&quot;, err) &#125; // 创建一个新的、空的 CertPool certPool := x509.NewCertPool() ca, err := ioutil.ReadFile(&quot;../encryption/ca.crt&quot;) if err != nil &#123; log.Fatal(&quot;ca证书读取错误&quot;, err) &#125; // 尝试解析所传入的 PEM 编码的证书。如果解析成功会将其加到 CertPool 中，便于后面的使用 certPool.AppendCertsFromPEM(ca) // 构建基于 TLS 的 TransportCredentials 选项 creds := credentials.NewTLS(&amp;tls.Config&#123; // 设置证书链，允许包含一个或多个 Certificates: []tls.Certificate&#123;cert&#125;, // 要求必须校验客户端的证书。可以根据实际情况选用以下参数 ClientAuth: tls.RequireAndVerifyClientCert, // 设置根证书的集合，校验方式使用 ClientAuth 中设定的模式 ClientCAs: certPool, &#125;) listen, _ := net.Listen(&quot;tcp&quot;, &quot;:8080&quot;) // 创建服务并添加证书 newServer := grpc.NewServer(grpc.Creds(creds)) pd.RegisterHelloServerServer(newServer, new(Server)) err = newServer.Serve(listen) if err != nil &#123; log.Print(&quot;err:&quot;, err) &#125;&#125; 客户端1234567891011121314151617181920212223242526272829303132func main() &#123; // 添加证书 cert, _ := tls.LoadX509KeyPair(&quot;./client.pem&quot;, &quot;./client.key&quot;) // 创建一个新的、空的 CertPool certPool := x509.NewCertPool() ca, _ := ioutil.ReadFile(&quot;../encryption/ca.crt&quot;) // 尝试解析所传入的 PEM 编码的证书。如果解析成功会将其加到 CertPool 中，便于后面的使用 certPool.AppendCertsFromPEM(ca) // 构建基于 TLS 的 TransportCredentials 选项 creds := credentials.NewTLS(&amp;tls.Config&#123; // 设置证书链，允许包含一个或多个 Certificates: []tls.Certificate&#123;cert&#125;, // 要求必须校验客户端的证书。可以根据实际情况选用以下参数 ServerName: &quot;*.test.example.com&quot;, RootCAs: certPool, &#125;) conn, err := grpc.Dial(&quot;:8080&quot;, grpc.WithTransportCredentials(creds)) if err != nil &#123; fmt.Print(err) &#125; defer conn.Close() client := pd.NewHelloServerClient(conn) feature, err := client.Say(context.Background(), &amp;pd.HelloReq&#123; Name: &quot;hello&quot;, Age: 22, &#125;) if err != nil &#123; log.Print(err) &#125; fmt.Print(feature)&#125; token认证服务端校验12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package mainimport ( &quot;context&quot; &quot;fmt&quot; &quot;google.golang.org/grpc&quot; &quot;google.golang.org/grpc/codes&quot; &quot;google.golang.org/grpc/metadata&quot; &quot;google.golang.org/grpc/status&quot; pd &quot;grpc_helloworld/server/proto&quot; &quot;log&quot; &quot;net&quot;)type Server struct &#123; pd.UnimplementedHelloServerServer&#125;func (s *Server) Say(ctx context.Context, q *pd.HelloReq) (*pd.HelloRep, error) &#123; return &amp;pd.HelloRep&#123; Say: fmt.Sprintf(&quot;%s已经%d岁了&quot;, q.Name, q.Age), &#125;, nil&#125;func main() &#123; var authInterceptor grpc.UnaryServerInterceptor authInterceptor = func( ctx context.Context, req interface&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler, ) (resp interface&#123;&#125;, err error) &#123; //拦截普通方法请求，验证 Token err = Auth(ctx) if err != nil &#123; return &#125; // 继续处理请求 return handler(ctx, req) &#125; listen, _ := net.Listen(&quot;tcp&quot;, &quot;:8080&quot;) // 创建服务并添加证书 newServer := grpc.NewServer(grpc.UnaryInterceptor(authInterceptor)) pd.RegisterHelloServerServer(newServer, new(Server)) err := newServer.Serve(listen) if err != nil &#123; log.Print(&quot;err:&quot;, err) &#125;&#125;func Auth(ctx context.Context) error &#123; md, ok := metadata.FromIncomingContext(ctx) if !ok &#123; return fmt.Errorf(&quot;missing credentials&quot;) &#125; var user string var password string if val, ok := md[&quot;user&quot;]; ok &#123; user = val[0] &#125; if val, ok := md[&quot;password&quot;]; ok &#123; password = val[0] &#125; if user != &quot;admin&quot; || password != &quot;123456&quot; &#123; return status.Errorf(codes.Unauthenticated, &quot;token不合法&quot;) &#125; return nil&#125; 客户端12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport ( &quot;context&quot; &quot;fmt&quot; &quot;google.golang.org/grpc&quot; &quot;google.golang.org/grpc/credentials/insecure&quot; pd &quot;grpc_helloworld/client/proto&quot; &quot;log&quot;)type Authentication struct &#123; User string Password string&#125;func (a *Authentication) GetRequestMetadata(context.Context, ...string) ( map[string]string, error,) &#123; return map[string]string&#123;&quot;user&quot;: a.User, &quot;password&quot;: a.Password&#125;, nil&#125;func (a *Authentication) RequireTransportSecurity() bool &#123; return false&#125;func main() &#123; user := &amp;Authentication&#123; User: &quot;admin&quot;, Password: &quot;123456&quot;, &#125; conn, err := grpc.Dial(&quot;:8080&quot;, grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithPerRPCCredentials(user)) if err != nil &#123; fmt.Print(err) &#125; defer conn.Close() client := pd.NewHelloServerClient(conn) feature, err := client.Say(context.Background(), &amp;pd.HelloReq&#123; Name: &quot;hello&quot;, Age: 22, &#125;) if err != nil &#123; log.Print(err) &#125; fmt.Print(feature)&#125;","categories":[],"tags":[]},{"title":"GRPC使用","slug":"GRPC使用","date":"2023-06-19T12:20:34.000Z","updated":"2023-06-20T02:50:30.000Z","comments":true,"path":"2023/06/19/GRPC使用/","link":"","permalink":"http://peapod.top/2023/06/19/GRPC%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Grpc简介及使用简介在 gRPC 中，客户端应用程序可以像本地对象一样直接调用不同机器上的服务器应用程序上的方法，可以更轻松地创建分布式应用程序和服务。 服务端实现了接口，运行一个gRPC服务端来处理客户端调用。客户端提供与服务器相同的方法。 使用 编写.proto文件 使用protoc生成.pd.go和-grpc.pd.go文件 编写服务端代码 实现接口 监听端口 新建grpc服务 注册接口的实现（结构体） 调用grpc服务的Server方法 编写客户端代码 拨号建立连接 创建客户端 客户端调用服务端实现的接口方法 .proto文件12345678910111213syntax = &quot;proto3&quot;;option go_package = &quot;.;helloService&quot;;message helloReq &#123; string name = 1; int32 age = 2;&#125;message helloRep &#123; string say = 1;&#125;service HelloServer &#123; rpc Say(helloReq) returns (helloRep) &#123;&#125;;&#125; 服务端1234567891011121314151617181920212223242526272829package mainimport ( &quot;context&quot; &quot;google.golang.org/grpc&quot; pd &quot;grpc_helloworld/server/proto&quot; &quot;log&quot; &quot;net&quot;)type Server struct &#123; pd.UnimplementedHelloServerServer&#125;func (s *Server) Say(ctx context.Context, q *pd.HelloReq) (*pd.HelloRep, error) &#123; return &amp;pd.HelloRep&#123; Say: q.Name, &#125;, nil&#125;func main() &#123; listen, _ := net.Listen(&quot;tcp&quot;, &quot;:8080&quot;) newServer := grpc.NewServer() pd.RegisterHelloServerServer(newServer, new(Server)) err := newServer.Serve(listen) if err != nil &#123; log.Print(&quot;err:&quot;, err) &#125;&#125; 客户端12345678910111213141516171819202122232425262728package mainimport ( &quot;context&quot; &quot;fmt&quot; &quot;google.golang.org/grpc&quot; &quot;google.golang.org/grpc/credentials/insecure&quot; pd &quot;grpc_helloworld/client/proto&quot; &quot;log&quot;)func main() &#123; conn, err := grpc.Dial(&quot;:8080&quot;, grpc.WithTransportCredentials(insecure.NewCredentials())) if err != nil &#123; fmt.Print(err) &#125; defer conn.Close() client := pd.NewHelloServerClient(conn) feature, err := client.Say(context.Background(), &amp;pd.HelloReq&#123; Name: &quot;hello&quot;, Age: 0, &#125;) if err != nil &#123; log.Print(err) &#125; fmt.Print(feature)&#125; Go work使用 进入工作目录 使用go work init创建go.work文件 生成proto文件夹及文件 创建服务端及客户端文件夹并分别生成go.mod文件 关联依赖","categories":[],"tags":[{"name":"GRPC","slug":"GRPC","permalink":"http://peapod.top/tags/GRPC/"}]},{"title":"Protocol Buffers","slug":"Protocol-Buffers","date":"2023-06-10T12:05:04.000Z","updated":"2023-06-19T11:55:51.000Z","comments":true,"path":"2023/06/10/Protocol-Buffers/","link":"","permalink":"http://peapod.top/2023/06/10/Protocol-Buffers/","excerpt":"","text":"Protocol Buffers 概述简介Protocol Buffers语言无关，平台无关，可扩展的结构化数据序列化方案, 用于协议通讯, 数据存储和其他更多用途。是一个灵活,高效,自动化的结构化数据序列化机制。 原理在.proto文件中定义protocol buffer消息类型来指定要序列化的信息如何组织。 protocol buffer信息是一个小的信息逻辑记录，包含一序列的”名字-值”对。 123456789101112131415161718message Person &#123; required string name = 1; required int32 id = 2; optional string email = 3; enum PhoneType &#123; MOBILE = 0; HOME = 1; WORK = 2; &#125; message PhoneNumber &#123; required string number = 1; optional PhoneType type = 2 [default = HOME]; &#125; repeated PhoneNumber phone = 4;&#125; 每个消息类型有一个或者多个唯一的编号的字段，而每个字段有一个名字和值类型。 在.proto文件上运行对应应用语言的protcol buffer的编译器来生成数据访问类。 这些类为每个字段(类似name()或者set_name())提供简单的访问器，还有用于序列化&#x2F;解析整个结构到&#x2F;从原始字节的方法。 安装使用安装下载通用编译器地址：https://github.com/protocolbuffers/protobuf/releases Protobuf 运行时安装grpc官网安装12$ go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28$ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2 使用 编写.proto文件 使用protoc工具生成代码文件 调用 1234567891011syntax = &quot;proto3&quot;;// 指定版本option go_package = &quot;./model&quot;;// 指定生成的文件存放位置package model;// 指定包名message User&#123; string name = 1; int32 age = 32;&#125; 1protoc --go_out=. --go-grpc_out=. helloworld/helloworld.proto –go_out .pd.go文件生成目录 –go-grpc_out _grpc.pd.go文件生成目录 123456789101112131415161718192021222324252627package mainimport ( &quot;fmt&quot; &quot;google.golang.org/protobuf/proto&quot; &quot;protobuftest/model&quot;)func main() &#123; user := &amp;model.User&#123; Name: &quot;twz&quot;, Age: 32, &#125; marshal, err := proto.Marshal(user) if err != nil &#123; return &#125; newUser := &amp;model.User&#123;&#125; err = proto.Unmarshal(marshal, newUser) if err != nil &#123; return &#125; fmt.Print(newUser)&#125; 定义消息类型定义消息类型.proto文件 12345678syntax = &quot;proto3&quot;;// 使用的是proto3语法message SearchRequest &#123; string query = 1; int32 page_number = 2; int32 results_per_page = 3;&#125;// SearchRequest消息定义指定了三个字段 为消息定义中的每个字段指定一个介于1和#之间的数字,给定的数字在该消息的所有字段中必须是唯一的。 字段规则 required:消息体中必填字段，不设置会导致编解码异常。默认使用。 optional: 消息体中可选字段。生成指针类型。 repeated: 消息体中可重复字段，重复的值的顺序会被保留（例如位置3）在go中重复的会被定义为切片。 123456message User &#123; string username = 1; int32 age = 2; optional string password = 3; repeated string address = 4;&#125; 定义多种消息类型123456789message SearchRequest &#123; string query = 1; int32 page_number = 2; int32 results_per_page = 3;&#125;message SearchResponse &#123; ...&#125; 添加注释12345678/* SearchRequest represents a search query, with pagination options to * indicate which results to include in the response. */message SearchRequest &#123; string query = 1; int32 page_number = 2; // Which page number do we want? int32 results_per_page = 3; // Number of results to return per page.&#125; 对于Go，编译器生成一个.pb.go文件，每个文件都有一个类型消息类型。 值类型 .proto Type GO Type double float64 float float32 int32 Int32 uint32 uint32 int64 long bool bool string string bytes []byte 默认值被编码的消息没有包含特定的简单元素, 被解析的对象对应的字段被设置为默认值。 对于strings, 默认值是空字符串(注, 是””, 而不是null) 对于bytes, 默认值是空字节(注, 应该是byte[0], 注意这里也不是null) 对于boolean, 默认值是false. 对于数字类型, 默认值是0. 对于枚举, 默认值是第一个定义的枚举值, 而这个值必须是0. 对于消息字段, 默认值是null. 枚举能希望某个字段只能有预先定义的多个值中的一个。 123456789101112131415message SearchRequest &#123; string query = 1; int32 page_number = 2; int32 result_per_page = 3; enum Corpus &#123; UNIVERSAL = 0; WEB = 1; IMAGES = 2; LOCAL = 3; NEWS = 4; PRODUCTS = 5; VIDEO = 6; &#125; Corpus corpus = 4;&#125; Corpus 枚举的第一个常量设置到0: 每个枚举定义必须包含一个映射到0的常量作为它的第一个元素. 必须有一个0值, 这样我们才能用0来作为数值默认值. 0值必须是第一个元素 消息调用可以使用其他消息类型作为字段类型。 123456789message SearchResponse &#123; repeated Result result = 1;&#125;message Result &#123; string url = 1; string title = 2; repeated string snippets = 3;&#125; 导入定义消息类型已经在其他的.proto文件中定义。 导入来使用来自其他.proto文件的定义. 为了导入其他.proto的定义, 需要在文件的顶端增加导入声明: 1import &quot;myproject/other_protos.proto&quot;; 需要移动.proto文件到新的位置。 在原有位置放置一个伪装的.proto文件, 通过使用import public方式转发所有的import到新的位置。其他任何导入这个包含import public语句的proto文件都可以透明的得到通过import public方法导入的依赖。 protocol编译器在通过命令行-I&#x2F;–proto_path参数指定的目录集合中搜索导入的文件。如果没有指定, 则在编译器被调用的目录下查找. 通常应该设置–proto_path参数到项目所在的根目录然后为所有的导入使用完整限定名。 消息嵌套可以在消息类型内部定义和使用消息类型。 12345678message SearchResponse &#123; message Result &#123; string url = 1; string title = 2; repeated string snippets = 3; &#125; repeated Result result = 1;&#125; 在父消息类型之外重用消息类型。 123message SomeOtherMessage &#123; SearchResponse.Result result = 1;&#125; 定义服务在.proto文件中定义RPC服务接口, 然后protocol buffer编译器会生成所选语言的服务接口代码和桩(stubs)。 定义一个RPC服务,带一个方法处理SearchRequest并返回SearchResponse。 123service SearchService &#123; rpc Search (SearchRequest) returns (SearchResponse);&#125; 生成类 定义在.proto文件中的消息类型 在.proto文件上运行protocol buffer编译器protoc 对于Go, 需要为编译器安装特别的代码生成插件 选项参数 –proto_path&#x3D;：指定一个目录用于查找.proto文件, 当解析导入命令时. 缺省使用当前目录。 –go_out&#x3D;：生成代码文件的目录。 1protoc --proto_path=IMPORT_PATH --go_out=DST_DIR","categories":[{"name":"云原生","slug":"云原生","permalink":"http://peapod.top/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"http://peapod.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"author":"taweizhong"},{"title":"","slug":"rides配置","date":"2023-06-10T10:46:21.000Z","updated":"2023-06-10T10:46:21.000Z","comments":true,"path":"2023/06/10/rides配置/","link":"","permalink":"http://peapod.top/2023/06/10/rides%E9%85%8D%E7%BD%AE/","excerpt":"","text":"sudo docker run -p 6379:6379 –name redis -v &#x2F;root&#x2F;go&#x2F;src&#x2F;redis&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf -v &#x2F;data&#x2F;redis&#x2F;data:&#x2F;data -d redis redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf –appendonly yes https://blog.csdn.net/qq_52889967/article/details/126586781 redis-benchmark -h 127.0.0.1 -p 6379 -t set,get -n 10000 -q -d 10240","categories":[],"tags":[]},{"title":"","slug":"GORM","date":"2023-05-11T02:36:35.000Z","updated":"2023-05-11T02:36:35.000Z","comments":true,"path":"2023/05/11/GORM/","link":"","permalink":"http://peapod.top/2023/05/11/GORM/","excerpt":"","text":"GORM手册连接数据库导入驱动 1import _ &quot;github.com/go-sql-driver/mysql&quot; 123456789import ( &quot;github.com/jinzhu/gorm&quot; _ &quot;github.com/jinzhu/gorm/dialects/mysql&quot;)func main() &#123; db, err := gorm.Open(&quot;mysql&quot;, &quot;user:password@tcp(port)/dbname?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;) defer db.Close()&#125; 模型","categories":[],"tags":[]},{"title":"","slug":"gin-blog说明","date":"2023-05-08T10:20:54.000Z","updated":"2023-05-08T10:20:54.000Z","comments":true,"path":"2023/05/08/gin-blog说明/","link":"","permalink":"http://peapod.top/2023/05/08/gin-blog%E8%AF%B4%E6%98%8E/","excerpt":"","text":"gin-blogday1初始化项目目录gin-blog/ ├── conf 存储配置文件 ├── middleware 中间件 ├── models 数据库模型 ├── pkg 三方包 ├── routers 路由 └── runtime运行时数据 初始项目数据库 创建数据库blog 创建三张表 标签表 文章表 认证表 编写项目配置包 拉取go-ini/ini的依赖包 编写配置文件 conf目录下新建app.ini文件 编写配置setting模块 新建setting.go文件 读取配置文件并存储到变量 编写API错误码包 pkg目录下新建e目录，新建code.go和msg.go文件 code.go 编写错误码 msg.go 编写错误信息 编写分页页码的获取方法 util目录下新建pagination.go 编写models init 拉取gorm的依赖包 拉取mysql驱动的依赖包 models目录下新建models.go 读取配置文件 连接数据库 编写项目启动、路由文件 routers目录新建router.go文件 编写路由 编写main.go文件 注册并监听 当前目录结构gin-blog/ ├── conf │ └── app.ini ├── main.go ├── middleware ├── models │ └── models.go ├── pkg │ ├── e │ │ ├── code.go │ │ └── msg.go │ ├── setting │ │ └── setting.go │ └── util │ └── pagination.go ├── routers │ └── router.go ├── runtime","categories":[],"tags":[]},{"title":"","slug":"JavaScript笔记","date":"2023-05-06T12:51:37.000Z","updated":"2023-05-06T12:51:37.000Z","comments":true,"path":"2023/05/06/JavaScript笔记/","link":"","permalink":"http://peapod.top/2023/05/06/JavaScript%E7%AC%94%E8%AE%B0/","excerpt":"","text":"JavaScript 参考第一章：基础语法基本语法只是声明变量而没有赋值，则该变量的值是undefined。undefined是一个特殊的值，表示“无定义”。 JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。 JavaScript 使用大括号，将多个相关的语句组合在一起，称为“区块”（block）。 对于var命令来说，JavaScript 的区块不构成单独的作用域（scope）。","categories":[],"tags":[]},{"title":"Mac视频播放器测试","slug":"Mac视频播放器测试","date":"2023-04-19T11:39:51.000Z","updated":"2023-06-10T10:41:04.000Z","comments":true,"path":"2023/04/19/Mac视频播放器测试/","link":"","permalink":"http://peapod.top/2023/04/19/Mac%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8%E6%B5%8B%E8%AF%95/","excerpt":"","text":"视频播放器名称 版本 Fig Player 1.2.3 Elmedia Player 8.15 Infuse 7 PRO 7.4.10 Movist Pro 2.9.2 OmniPlayer Pro 2.0.19 测试视频：蚁人2 格式：2160p.MA.WEB-DL.DDP5.1.Atmos.DV.HDR10.H.265-CMRG.mkv 样张： ![截屏2023-04-19 20.02.59](&#x2F;Users&#x2F;taweizhong&#x2F;Desktop&#x2F;截屏2023-04-19 20.02.59.png) ![截屏2023-04-19 20.02.42](&#x2F;Users&#x2F;taweizhong&#x2F;Desktop&#x2F;截屏2023-04-19 20.02.42.png) ![截屏2023-04-19 20.03.37](&#x2F;Users&#x2F;taweizhong&#x2F;Desktop&#x2F;截屏2023-04-19 20.03.37.png) ![截屏2023-04-19 20.03.30](&#x2F;Users&#x2F;taweizhong&#x2F;Desktop&#x2F;截屏2023-04-19 20.03.30.png)","categories":[],"tags":[{"name":"测试","slug":"测试","permalink":"http://peapod.top/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"Vue3入门教程","slug":"Vue3","date":"2023-04-19T11:39:51.000Z","updated":"2023-06-19T11:56:58.000Z","comments":true,"path":"2023/04/19/Vue3/","link":"","permalink":"http://peapod.top/2023/04/19/Vue3/","excerpt":"","text":"Vue3入门教程简介Vue是一款用于构建用户界面的 JavaScript 框架。 Vue 的两个核心功能： 声明式渲染：Vue 基于标准 HTML 拓展了一套模板语法，使得我们可以声明式地描述最终输出的 HTML 和 JavaScript 状态之间的关系。 响应性：Vue 会自动跟踪 JavaScript 状态并在其发生变化时响应式地更新 DOM。 渐进式框架用不同的方式使用 Vue： 无需构建步骤，渐进式增强静态的 HTML 在任何页面中作为 Web Components 嵌入 单页应用 (SPA) 全栈 &#x2F; 服务端渲染 (SSR) Jamstack &#x2F; 静态站点生成 (SSG) 开发桌面端、移动端、WebGL，甚至是命令行终端中的界面 单文件组件单文件组件 (也被称为 *.vue 文件，英文 Single-File Components，缩写为 SFC)。顾名思义，Vue 的单文件组件会将一个组件的逻辑 (JavaScript)，模板 (HTML) 和样式 (CSS) 封装在同一个文件里。 选项式 API (Options API)用包含多个选项的对象来描述组件的逻辑，例如 data、methods 和 mounted。选项所定义的属性都会暴露在函数内部的 this 上，它会指向当前的组件实例。 1234567891011121314151617181920212223242526272829&lt;script&gt;export default &#123; // data() 返回的属性将会成为响应式的状态 // 并且暴露在 `this` 上 data() &#123; return &#123; count: 0 &#125; &#125;, // methods 是一些用来更改状态与触发更新的函数 // 它们可以在模板中作为事件监听器绑定 methods: &#123; increment() &#123; this.count++ &#125; &#125;, // 生命周期钩子会在组件生命周期的各个不同阶段被调用 // 例如这个函数就会在组件挂载完成后被调用 mounted() &#123; console.log(`The initial count is $&#123;this.count&#125;.`) &#125;&#125;&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;increment&quot;&gt;Count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt; 组合式 API (Composition API)与 搭配使用。 中的导入和顶层变量/函数都能够在模板中直接使用。 组合式 API 的核心思想是直接在函数作用域内定义响应式状态变量，并将从多个函数中得到的状态组合起来处理复杂问题。 1234567891011121314151617181920&lt;script setup&gt;import &#123; ref, onMounted &#125; from &#x27;vue&#x27;// 响应式状态const count = ref(0)// 用来修改状态、触发更新的函数function increment() &#123; count.value++&#125;// 生命周期钩子onMounted(() =&gt; &#123; console.log(`The initial count is $&#123;count.value&#125;.`)&#125;)&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;increment&quot;&gt;Count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt; 第一个vue每个 Vue 应用都是通过 createApp 函数创建一个新的 应用实例 12345import &#123; createApp &#125; from &#x27;vue&#x27;const app = createApp(&#123; /* 根组件选项 */&#125;) 直接从另一个文件中导入根组件。 12345import &#123; createApp &#125; from &#x27;vue&#x27;// 从一个单文件组件中导入根组件import App from &#x27;./App.vue&#x27;const app = createApp(App) 应用实例必须在调用了 .mount() 方法后才会渲染出来。 应用根组件的内容将会被渲染在容器元素里面。容器元素自己将不会被视为应用的一部分。 模版语法文本插值1&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt; 双大括号 原始HTML12&lt;p&gt;Using text interpolation: &#123;&#123; rawHtml &#125;&#125;&lt;/p&gt;&lt;p&gt;Using v-html directive: &lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt; 使用 v-html 指令 span 的内容将会被替换为 rawHtml 属性的值，插值为纯 HTML——数据绑定将会被忽略。 Attribute 绑定响应式地绑定一个 attribute，应该使用 v-bind 指令： 1&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt; id attribute 与组件的 dynamicId 属性保持一致。 依据 true / false 值来决定 attribute 是否应该存在于该元素上。disabled就是最常见的例子之一。 1&lt;button :disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt; 当 isButtonDisabled 为真值或一个空字符串 (即 &lt;button disabled=&quot;&quot;&gt;) 时，元素会包含这个 disabled attribute。而当其为其他假值时 attribute 将被忽略。 动态绑定多个值12345678data() &#123; return &#123; objectOfAttrs: &#123; id: &#x27;container&#x27;, class: &#x27;wrapper&#x27; &#125; &#125;&#125; 通过不带参数的 v-bind，你可以将它们绑定到单个元素上： 1&lt;div v-bind=&quot;objectOfAttrs&quot;&gt;&lt;/div&gt; 使用 JavaScript 表达式 Vue 实际上在所有的数据绑定中都支持完整的 JavaScript 表达式： 1234567&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;&lt;div :id=&quot;`list-$&#123;id&#125;`&quot;&gt;&lt;/div&gt; JavaScript 表达式可以被使用在如下场景上： 在文本插值中 (双大括号) 在任何 Vue 指令 (以 v- 开头的特殊 attribute) attribute 的值中 动态参数在指令参数上也可以使用一个 JavaScript 表达式，需要包含在一对方括号内： 12345678&lt;!--注意，参数表达式有一些约束，参见下面“动态参数值的限制”与“动态参数语法的限制”章节的解释--&gt;&lt;a v-bind:[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;&lt;!-- 简写 --&gt;&lt;a :[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://peapod.top/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"http://peapod.top/tags/Vue3/"}],"author":"taweizhong"},{"title":"javascript对象","slug":"javascript对象","date":"2023-04-19T11:39:51.000Z","updated":"2023-06-10T10:42:33.000Z","comments":true,"path":"2023/04/19/javascript对象/","link":"","permalink":"http://peapod.top/2023/04/19/javascript%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"javascript对象对象JavaScript 语言使用构造函数（constructor）作为对象的模板。 构造函数的特点有两个。 函数体内部使用了this关键字，代表了所要生成的对象实例。 生成对象的时候，必须使用new命令。 new命令的作用，就是执行构造函数，返回一个实例对象。 new 命令的原理 创建一个空对象，作为将要返回的对象实例。 将这个空对象的原型，指向构造函数的prototype属性。 将这个空对象赋值给函数内部的this关键字。 开始执行构造函数内部的代码。 Object.create() 创建实例对象现有的对象作为模板，生成新的实例对象，这时就可以使用Object.create()方法。 12345678910var person1 = &#123; name: &#x27;张三&#x27;, age: 38, greeting: function() &#123; console.log(&#x27;Hi! I\\&#x27;m &#x27; + this.name + &#x27;.&#x27;); &#125;&#125;;var person2 = Object.create(person1);person2.name // 张三person2.greeting() // Hi! I&#x27;m 张三. this关键字this可以用在构造函数之中，表示实例对象。this都有一个共同点：它总是返回一个对象。 它的设计目的就是在函数体内部，指代函数当前的运行环境。 使用场合全局环境使用this，它指的就是顶层对象window。 构造函数中的this，指的是实例对象。 对象的方法里面包含this，this的指向就是方法运行时所在的对象。 Function.prototype.call()函数实例的call方法，可以指定函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。 call方法的参数，应该是一个对象。如果参数为空、null和undefined，则默认传入全局对象。 继承通过构造函数为实例对象定义属性，虽然很方便，但是有一个缺点。同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费。 问题的解决方法，就是 JavaScript 的原型对象（prototype）。 原型对象的所有属性和方法，都能被实例对象共享。 每个函数都有一个prototype属性，指向一个对象。 12function f() &#123;&#125;typeof f.prototype // &quot;object&quot; 生成实例的时候，该属性会自动成为实例对象的原型。原型对象的属性不是实例对象自身的属性。 当实例对象本身没有某个属性或方法的时候，它会到原型对象去寻找该属性或方法。 原型对象的作用，就是定义所有实例对象共享的属性和方法。 对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）。 原型对象相当于父类 constructor 属性prototype对象有一个constructor属性，默认指向prototype对象所在的构造函数。 constructor属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。 有了constructor属性，就可以从一个实例对象新建另一个实例。constructor属性表示原型对象与构造函数之间的关联关系。 instanceof 运算符返回一个布尔值，表示对象是否为某个构造函数的实例。 instanceof运算符的左边是实例对象，右边是构造函数。它会检查右边构建函数的原型对象（prototype），是否在左边对象的原型链上。 构造函数的继承第一步是在子类的构造函数中，调用父类的构造函数。 第二步，是让子类的原型指向父类的原型，这样子类就可以继承父类原型。 123Sub.prototype = Object.create(Super.prototype);Sub.prototype.constructor = Sub;Sub.prototype.method = &#x27;...&#x27;; Sub.prototype是子类的原型，要将它赋值为Object.create(Super.prototype)，而不是直接等于Super.prototype。否则后面两行对Sub.prototype的操作，会连父类的原型Super.prototype一起修改掉。 12345678910111213141516171819202122function Shape() &#123; this.x = 0; this.y = 0;&#125;Shape.prototype.move = function (x, y) &#123; this.x += x; this.y += y; console.info(&#x27;Shape moved.&#x27;);&#125;;// 第一步，子类继承父类的实例function Rectangle() &#123; Shape.call(this); // 调用父类构造函数&#125;// 另一种写法function Rectangle() &#123; this.base = Shape; this.base();&#125;// 第二步，子类继承父类的原型Rectangle.prototype = Object.create(Shape.prototype);Rectangle.prototype.constructor = Rectangle;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://peapod.top/tags/javascript/"}]},{"title":"props","slug":"props","date":"2023-04-19T11:39:51.000Z","updated":"2023-06-10T10:44:01.000Z","comments":true,"path":"2023/04/19/props/","link":"","permalink":"http://peapod.top/2023/04/19/props/","excerpt":"","text":"propsProps 声明使用 &lt;script setup&gt; 的单文件组件中，props 可以使用 defineProps() 宏来声明： 12345&lt;script setup&gt;const props = defineProps([&#x27;foo&#x27;])console.log(props.foo)&lt;/script&gt; 单向数据流所有的 props 都遵循着单向绑定原则，props 因父组件的更新而变化，自然地将新的状态向下流往子组件，而不会逆向传递。 不应该在子组件中去更改一个 prop。警告！prop 是只读的！ 更改一个 prop 的需求：prop 被用于传入初始值；而子组件想在之后将其作为一个局部数据属性。 12345const props = defineProps([&#x27;initialCounter&#x27;])// 计数器只是将 props.initialCounter 作为初始值// 像下面这样做就使 prop 和后续更新无关了const counter = ref(props.initialCounter) 需要对传入的 prop 值做进一步的转换。 1234const props = defineProps([&#x27;size&#x27;])// 该 prop 变更时计算属性也会自动更新const normalizedSize = computed(() =&gt; props.size.trim().toLowerCase()) Prop 校验向 defineProps() 宏提供一个带有 props 校验选项的对象，例如： 12345678910111213141516171819202122232425262728293031323334353637383940414243defineProps(&#123; // 基础类型检查 // （给出 `null` 和 `undefined` 值则会跳过任何类型检查） propA: Number, // 多种可能的类型 propB: [String, Number], // 必传，且为 String 类型 propC: &#123; type: String, required: true &#125;, // Number 类型的默认值 propD: &#123; type: Number, default: 100 &#125;, // 对象类型的默认值 propE: &#123; type: Object, // 对象或数组的默认值 // 必须从一个工厂函数返回。 // 该函数接收组件所接收到的原始 prop 作为参数。 default(rawProps) &#123; return &#123; message: &#x27;hello&#x27; &#125; &#125; &#125;, // 自定义类型校验函数 propF: &#123; validator(value) &#123; // The value must match one of these strings return [&#x27;success&#x27;, &#x27;warning&#x27;, &#x27;danger&#x27;].includes(value) &#125; &#125;, // 函数类型的默认值 propG: &#123; type: Function, // 不像对象或数组的默认，这不是一个 // 工厂函数。这会是一个用来作为默认值的函数 default() &#123; return &#x27;Default function&#x27; &#125; &#125;&#125;)","categories":[],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"http://peapod.top/tags/Vue3/"}]},{"title":"侦听器","slug":"侦听器","date":"2023-04-19T11:39:51.000Z","updated":"2023-06-19T11:58:33.000Z","comments":true,"path":"2023/04/19/侦听器/","link":"","permalink":"http://peapod.top/2023/04/19/%E4%BE%A6%E5%90%AC%E5%99%A8/","excerpt":"","text":"侦听器在状态变化时执行一些“副作用”：例如更改 DOM，或是根据异步操作的结果去修改另一处的状态。 响应式变量的状态发生变化时，调用回调函数。 使用 watch 函数在每次响应式状态发生变化时触发回调函数 watch 的第一个参数可以是不同形式的“数据源”：它可以是一个 ref (包括计算属性)、一个响应式对象、一个 getter 函数、或多个数据源组成的数组： 1234567891011121314151617181920const x = ref(0)const y = ref(0)// 单个 refwatch(x, (newX) =&gt; &#123; console.log(`x is $&#123;newX&#125;`)&#125;)// getter 函数watch( () =&gt; x.value + y.value, (sum) =&gt; &#123; console.log(`sum of x + y is: $&#123;sum&#125;`) &#125;)// 多个来源组成的数组watch([x, () =&gt; y.value], ([newX, newY]) =&gt; &#123; console.log(`x is $&#123;newX&#125; and y is $&#123;newY&#125;`)&#125;) 不能直接侦听响应式对象的属性值，例如: 123456const obj = reactive(&#123; count: 0 &#125;)// 错误，因为 watch() 得到的参数是一个 numberwatch(obj.count, (count) =&gt; &#123; console.log(`count is: $&#123;count&#125;`)&#125;) 需要用一个返回该属性的 getter 函数： 1234567// 提供一个 getter 函数watch( () =&gt; obj.count, (count) =&gt; &#123; console.log(`count is: $&#123;count&#125;`) &#125;) 深层侦听器给 watch() 传入一个响应式对象，会隐式地创建一个深层侦听器——该回调函数在所有嵌套的变更时都会被触发： 123456789const obj = reactive(&#123; count: 0 &#125;)watch(obj, (newValue, oldValue) =&gt; &#123; // 在嵌套的属性变更时触发 // 注意：`newValue` 此处和 `oldValue` 是相等的 // 因为它们是同一个对象！&#125;)obj.count++ 相比之下，一个返回响应式对象的 getter 函数，只有在返回不同的对象时，才会触发回调： 123456watch( () =&gt; state.someObject, () =&gt; &#123; // 仅当 state.someObject 被替换时触发 &#125;) 即时回调的侦听器通过传入 immediate: true 选项来强制侦听器的回调立即执行： 123watch(source, (newValue, oldValue) =&gt; &#123; // 立即执行，且当 `source` 改变时再次执行&#125;, &#123; immediate: true &#125;) watchEffect()123456789const todoId = ref(1)const data = ref(null)watch(todoId, async () =&gt; &#123; const response = await fetch( `https://jsonplaceholder.typicode.com/todos/$&#123;todoId.value&#125;` ) data.value = await response.json()&#125;, &#123; immediate: true &#125;) watchEffect() 允许我们自动跟踪回调的响应式依赖。上面的侦听器可以重写为： 123456watchEffect(async () =&gt; &#123; const response = await fetch( `https://jsonplaceholder.typicode.com/todos/$&#123;todoId.value&#125;` ) data.value = await response.json()&#125;) 不需要指定 immediate: true。在执行期间，它会自动追踪 todoId.value 作为依赖（和计算属性类似）。每当 todoId.value 变化时，回调会再次执行。有了 watchEffect()，我们不再需要明确传递 todoId 作为源值。 watch 只追踪明确侦听的数据源。它不会追踪任何在回调中访问到的东西。另外，仅在数据源确实改变时才会触发回调。watch 会避免在发生副作用时追踪依赖，因此，我们能更加精确地控制回调函数的触发时机。 watchEffect，则会在副作用发生期间追踪依赖。它会在同步执行过程中，自动追踪所有能访问到的响应式属性。这更方便，而且代码往往更简洁，但有时其响应性依赖关系会不那么明确。 回调的触发时机当你更改了响应式状态，它可能会同时触发 Vue 组件更新和侦听器回调。 默认情况下，用户创建的侦听器回调，都会在 Vue 组件更新之前被调用。这意味着你在侦听器回调中访问的 DOM 将是被 Vue 更新之前的状态。 在侦听器回调中能访问被 Vue 更新之后的 DOM，你需要指明 flush: &#39;post&#39; 选项： 1234567watch(source, callback, &#123; flush: &#x27;post&#x27;&#125;)watchEffect(callback, &#123; flush: &#x27;post&#x27;&#125;) 停止侦听器在 setup() 或 &lt;script setup&gt; 中用同步语句创建的侦听器，会自动绑定到宿主组件实例上，并且会在宿主组件卸载时自动停止。 侦听器必须用同步语句创建：如果用异步回调创建一个侦听器，那么它不会绑定到当前组件上，你必须手动停止它，以防内存泄漏。如下方这个例子： 1234567891011&lt;script setup&gt;import &#123; watchEffect &#125; from &#x27;vue&#x27;// 它会自动停止watchEffect(() =&gt; &#123;&#125;)// ...这个则不会！setTimeout(() =&gt; &#123; watchEffect(() =&gt; &#123;&#125;)&#125;, 100)&lt;/script&gt; 手动停止一个侦听器 1234const unwatch = watchEffect(() =&gt; &#123;&#125;)// ...当该侦听器不再需要时unwatch()","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://peapod.top/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"http://peapod.top/tags/Vue3/"}],"author":"taweizhong"},{"title":"插槽 Slots","slug":"插槽 Slots","date":"2023-04-19T11:39:51.000Z","updated":"2023-06-10T10:43:05.000Z","comments":true,"path":"2023/04/19/插槽 Slots/","link":"","permalink":"http://peapod.top/2023/04/19/%E6%8F%92%E6%A7%BD%20Slots/","excerpt":"","text":"插槽 Slots插槽内容与出口一个 &lt;FancyButton&gt; 组件，可以像这样使用： 123&lt;FancyButton&gt; Click me! &lt;!-- 插槽内容 --&gt;&lt;/FancyButton&gt; 而 &lt;FancyButton&gt; 的模板是这样的： 123&lt;button class=&quot;fancy-btn&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;!-- 插槽出口 --&gt;&lt;/button&gt; &lt;slot&gt; 元素是一个插槽出口 (slot outlet)，标示了父元素提供的插槽内容 (slot content) 将在哪里被渲染。 插槽内容可以是任意合法的模板内容，不局限于文本。例如我们可以传入多个元素，甚至是组件： 1234&lt;FancyButton&gt; &lt;span style=&quot;color:red&quot;&gt;Click me!&lt;/span&gt; &lt;AwesomeIcon name=&quot;plus&quot; /&gt;&lt;/FancyButton&gt; 渲染作用域插槽内容可以访问到父组件的数据作用域，因为插槽内容本身是在父组件模板中定义的。 插槽内容无法访问子组件的数据。Vue 模板中的表达式只能访问其定义时所处的作用域。 具名插槽&lt;slot&gt; 元素可以有一个特殊的 attribute name，用来给各个插槽分配唯一的 ID，以确定每一处要渲染的内容： 1234567891011&lt;div class=&quot;container&quot;&gt; &lt;header&gt; &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt; &lt;/footer&gt;&lt;/div&gt; 要为具名插槽传入内容，我们需要使用一个含 v-slot 指令的 &lt;template&gt; 元素，并将目标插槽的名字传给该指令： 12345&lt;BaseLayout&gt; &lt;template v-slot:header&gt; &lt;!-- header 插槽的内容放这里 --&gt; &lt;/template&gt;&lt;/BaseLayout&gt; v-slot 有对应的简写 # 作用域插槽插槽的内容无法访问到子组件的状态。 像对组件传递 props 那样，向一个插槽的出口上传递 attributes： 1234&lt;!-- &lt;MyComponent&gt; 的模板 --&gt;&lt;div&gt; &lt;slot :text=&quot;greetingMessage&quot; :count=&quot;1&quot;&gt;&lt;/slot&gt;&lt;/div&gt; 默认插槽接受 props 123&lt;MyComponent v-slot=&quot;slotProps&quot;&gt; &#123;&#123; slotProps.text &#125;&#125; &#123;&#123; slotProps.count &#125;&#125;&lt;/MyComponent&gt; 具名作用域插槽12345678910111213&lt;MyComponent&gt; &lt;template #header=&quot;headerProps&quot;&gt; &#123;&#123; headerProps &#125;&#125; &lt;/template&gt; &lt;template #default=&quot;defaultProps&quot;&gt; &#123;&#123; defaultProps &#125;&#125; &lt;/template&gt; &lt;template #footer=&quot;footerProps&quot;&gt; &#123;&#123; footerProps &#125;&#125; &lt;/template&gt;&lt;/MyComponent&gt; 向具名插槽中传入 props： 1&lt;slot name=&quot;header&quot; message=&quot;hello&quot;&gt;&lt;/slot&gt;","categories":[],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"http://peapod.top/tags/Vue3/"}]},{"title":"模版引用（访问DOM元素）","slug":"模版引用","date":"2023-04-19T11:39:51.000Z","updated":"2023-06-19T11:58:04.000Z","comments":true,"path":"2023/04/19/模版引用/","link":"","permalink":"http://peapod.top/2023/04/19/%E6%A8%A1%E7%89%88%E5%BC%95%E7%94%A8/","excerpt":"","text":"模版引用（访问DOM元素）需要直接访问底层 DOM 元素。要实现这一点，我们可以使用特殊的 ref attribute： 1&lt;input ref=&quot;input&quot;&gt; 允许我们在一个特定的 DOM 元素或子组件实例被挂载后，获得对它的直接引用。 访问模版引用为了通过组合式 API 获得该模板引用，我们需要声明一个同名的 ref： 123456789101112131415&lt;script setup&gt;import &#123; ref, onMounted &#125; from &#x27;vue&#x27;// 声明一个 ref 来存放该元素的引用// 必须和模板里的 ref 同名const input = ref(null)onMounted(() =&gt; &#123; input.value.focus()&#125;)&lt;/script&gt;&lt;template&gt; &lt;input ref=&quot;input&quot; /&gt;&lt;/template&gt; 侦听一个模板引用 ref 的变化，确保考虑到其值为 null 的情况： 1234567watchEffect(() =&gt; &#123; if (input.value) &#123; input.value.focus() &#125; else &#123; // 此时还未挂载，或此元素已经被卸载（例如通过 v-if 控制） &#125;&#125;) v-for 中的模板引用对应的 ref 中包含的值是一个数组，它将在元素被挂载后包含对应整个列表的所有元素： 12345678910111213141516171819&lt;script setup&gt;import &#123; ref, onMounted &#125; from &#x27;vue&#x27;const list = ref([ /* ... */])const itemRefs = ref([])onMounted(() =&gt; console.log(itemRefs.value))&lt;/script&gt;&lt;template&gt; &lt;ul&gt; &lt;li v-for=&quot;item in list&quot; ref=&quot;itemRefs&quot;&gt; &#123;&#123; item &#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/template&gt; 组件上的ref引用中获得的值是组件实例： 1234567891011121314&lt;script setup&gt;import &#123; ref, onMounted &#125; from &#x27;vue&#x27;import Child from &#x27;./Child.vue&#x27;const child = ref(null)onMounted(() =&gt; &#123; // child.value 是 &lt;Child /&gt; 组件的实例&#125;)&lt;/script&gt;&lt;template&gt; &lt;Child ref=&quot;child&quot; /&gt;&lt;/template&gt; 使用了 &lt;script setup&gt; 的组件是默认私有的：一个父组件无法访问到一个使用了 &lt;script setup&gt; 的子组件中的任何东西，除非子组件在其中通过 defineExpose 宏显式暴露： 123456789101112&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const a = 1const b = ref(2)// 像 defineExpose 这样的编译器宏不需要导入defineExpose(&#123; a, b&#125;)&lt;/script&gt;","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://peapod.top/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"http://peapod.top/tags/Vue3/"}],"author":"taweizhong"},{"title":"全局注册","slug":"注册","date":"2023-04-19T11:39:51.000Z","updated":"2023-06-10T10:44:29.000Z","comments":true,"path":"2023/04/19/注册/","link":"","permalink":"http://peapod.top/2023/04/19/%E6%B3%A8%E5%86%8C/","excerpt":"","text":"全局注册 app.component() 方法，让组件在当前 Vue 应用中全局可用。 123import MyComponent from &#x27;./App.vue&#x27;app.component(&#x27;MyComponent&#x27;, MyComponent) 全局注册的组件可以在此应用的任意组件的模板中使用： 1234&lt;!-- 这在当前应用的任意组件中都可用 --&gt;&lt;ComponentA/&gt;&lt;ComponentB/&gt;&lt;ComponentC/&gt; 局部注册在使用 &lt;script setup&gt; 的单文件组件中，导入的组件可以直接在模板中使用，无需注册： 1234567&lt;script setup&gt;import ComponentA from &#x27;./ComponentA.vue&#x27;&lt;/script&gt;&lt;template&gt; &lt;ComponentA /&gt;&lt;/template&gt;","categories":[],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"http://peapod.top/tags/Vue3/"}]},{"title":"组件事件","slug":"组件事件","date":"2023-04-19T11:39:51.000Z","updated":"2023-06-10T10:43:44.000Z","comments":true,"path":"2023/04/19/组件事件/","link":"","permalink":"http://peapod.top/2023/04/19/%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6/","excerpt":"","text":"组件事件触发与监听事件子组件上抛 12&lt;!-- MyComponent --&gt;&lt;button @click=&quot;$emit(&#x27;someEvent&#x27;)&quot;&gt;click me&lt;/button&gt; 父组件监听 1&lt;MyComponent @some-event=&quot;callback&quot; /&gt; 事件参数给 $emit 提供一个额外的参数： 123&lt;button @click=&quot;$emit(&#x27;increaseBy&#x27;, 1)&quot;&gt; Increase by 1&lt;/button&gt; 父组件 1&lt;MyButton @increase-by=&quot;(n) =&gt; count += n&quot; /&gt; 声明触发的事件显式地通过 defineEmits() 宏来声明它要触发的事件： 1234567&lt;script setup&gt;const emit = defineEmits([&#x27;inFocus&#x27;, &#x27;submit&#x27;])function buttonClick() &#123; emit(&#x27;submit&#x27;)&#125;&lt;/script&gt; 事件校验要为事件添加校验，那么事件可以被赋值为一个函数，接受的参数就是抛出事件时传入 emit的内容，返回一个布尔值来表明事件是否合法。 1234567891011121314151617181920&lt;script setup&gt;const emit = defineEmits(&#123; // 没有校验 click: null, // 校验 submit 事件 submit: (&#123; email, password &#125;) =&gt; &#123; if (email &amp;&amp; password) &#123; return true &#125; else &#123; console.warn(&#x27;Invalid submit event payload!&#x27;) return false &#125; &#125;&#125;)function submitForm(email, password) &#123; emit(&#x27;submit&#x27;, &#123; email, password &#125;)&#125;&lt;/script&gt;","categories":[],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"http://peapod.top/tags/Vue3/"}]},{"title":"组件 v-model","slug":"组件 v-model","date":"2023-04-19T11:39:51.000Z","updated":"2023-06-10T10:43:25.000Z","comments":true,"path":"2023/04/19/组件 v-model/","link":"","permalink":"http://peapod.top/2023/04/19/%E7%BB%84%E4%BB%B6%20v-model/","excerpt":"","text":"组件 v-modelv-model 可以在组件上使用以实现双向绑定。 当使用在一个组件上时，v-model 会被展开为如下的形式： 1234&lt;CustomInput :modelValue=&quot;searchText&quot; @update:modelValue=&quot;newValue =&gt; searchText = newValue&quot;/&gt; &lt;CustomInput&gt; 组件内部需要做两件事： 将内部原生 &lt;input&gt; 元素的 value attribute 绑定到 modelValue prop 当原生的 input 事件触发时，触发一个携带了新值的 update:modelValue 自定义事件 123456789101112&lt;!-- CustomInput.vue --&gt;&lt;script setup&gt;defineProps([&#x27;modelValue&#x27;])defineEmits([&#x27;update:modelValue&#x27;])&lt;/script&gt;&lt;template&gt; &lt;input :value=&quot;modelValue&quot; @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot; /&gt;&lt;/template&gt; v-model 的参数默认情况下，v-model 在组件上都是使用 modelValue 作为 prop，并以 update:modelValue 作为对应的事件。我们可以通过给 v-model 指定一个参数来更改这些名字： 1&lt;MyComponent v-model:title=&quot;bookTitle&quot; /&gt; 子组件应声明一个 title prop，并通过触发 update:title 事件更新父组件值： 12345678910111213&lt;!-- MyComponent.vue --&gt;&lt;script setup&gt;defineProps([&#x27;title&#x27;])defineEmits([&#x27;update:title&#x27;])&lt;/script&gt;&lt;template&gt; &lt;input type=&quot;text&quot; :value=&quot;title&quot; @input=&quot;$emit(&#x27;update:title&#x27;, $event.target.value)&quot; /&gt;&lt;/template&gt;","categories":[],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"http://peapod.top/tags/Vue3/"}]},{"title":"组件基础","slug":"组件基础","date":"2023-04-19T11:39:51.000Z","updated":"2023-06-19T11:57:27.000Z","comments":true,"path":"2023/04/19/组件基础/","link":"","permalink":"http://peapod.top/2023/04/19/%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/","excerpt":"","text":"组件基础定义一个组件将 Vue 组件定义在一个单独的 .vue 文件中，这被叫做单文件组件 (简称 SFC) 123456789&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const count = ref(0)&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;count++&quot;&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&lt;/template&gt; 使用一个组件要使用一个子组件，我们需要在父组件中导入它。这个组件将会以默认导出的形式被暴露给外部。 12345678&lt;script setup&gt;import ButtonCounter from &#x27;./ButtonCounter.vue&#x27;&lt;/script&gt;&lt;template&gt; &lt;h1&gt;Here is a child component!&lt;/h1&gt; &lt;ButtonCounter /&gt;&lt;/template&gt; 通过 &lt;script setup&gt;，导入的组件都在模板中直接可用。 传递props（父-子）向组件中传递数据，这就会使用到 props。 父组件向子组件传递数据使用子组件使用props。 Props 是一种特别的 attributes，你可以在组件上声明注册。 12345678&lt;!-- BlogPost.vue --&gt;&lt;script setup&gt;defineProps([&#x27;title&#x27;])&lt;/script&gt;&lt;template&gt; &lt;h4&gt;&#123;&#123; title &#125;&#125;&lt;/h4&gt;&lt;/template&gt; 当一个 prop 被注册后，可以像这样以自定义 attribute 的形式传递数据给它： 123&lt;BlogPost title=&quot;My journey with Vue&quot; /&gt;&lt;BlogPost title=&quot;Blogging with Vue&quot; /&gt;&lt;BlogPost title=&quot;Why Vue is so fun&quot; /&gt; defineProps 会返回一个对象，其中包含了可以传递给组件的所有 props： 12const props = defineProps([&#x27;title&#x27;])console.log(props.title) 使用 v-bind 来传递动态 prop 值的。 1234567891011const posts = ref([ &#123; id: 1, title: &#x27;My journey with Vue&#x27; &#125;, &#123; id: 2, title: &#x27;Blogging with Vue&#x27; &#125;, &#123; id: 3, title: &#x27;Why Vue is so fun&#x27; &#125;])&lt;BlogPost v-for=&quot;post in posts&quot; :key=&quot;post.id&quot; :title=&quot;post.title&quot; /&gt; 监听事件（子-父）子组件使用 $emit 方法向上抛出自定义事件，向父组件传递行为（自定义事件），父组件监听上抛的事件。 123&lt;BlogPost @enlarge-text=&quot;postFontSize += 0.1&quot; /&gt; 1234567&lt;!-- BlogPost.vue, 省略了 &lt;script&gt; --&gt;&lt;template&gt; &lt;div class=&quot;blog-post&quot;&gt; &lt;h4&gt;&#123;&#123; title &#125;&#125;&lt;/h4&gt; &lt;button @click=&quot;$emit(&#x27;enlarge-text&#x27;)&quot;&gt;Enlarge text&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; 当点击按钮之后，抛出的事件会被父组件监听，同时父组件触发该事件并引发行为。 通过 defineEmits 宏来声明需要抛出的事件： 12345&lt;!-- BlogPost.vue --&gt;&lt;script setup&gt;defineProps([&#x27;title&#x27;])defineEmits([&#x27;enlarge-text&#x27;])&lt;/script&gt; 声明了一个组件可能触发的所有事件，还可以对事件的参数进行验证。 返回一个等同于 $emit 方法的 emit 函数。它可以被用于在组件的 &lt;script setup&gt;中抛出事件，因为此处无法直接访问 $emit： 12345&lt;script setup&gt;const emit = defineEmits([&#x27;enlarge-text&#x27;])emit(&#x27;enlarge-text&#x27;)&lt;/script&gt; 插槽分配内容（父-子）将父组件中的内容会自动替换插槽中的内容。 通过 Vue 的自定义 &lt;slot&gt; 元素来实现： 123456789101112&lt;template&gt; &lt;div class=&quot;alert-box&quot;&gt; &lt;strong&gt;This is an Error for Demo Purposes&lt;/strong&gt; &lt;slot /&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.alert-box &#123; /* ... */&#125;&lt;/style&gt; 使用 &lt;slot&gt; 作为一个占位符，父组件传递进来的内容就会渲染在这里。 动态组件当使用 &lt;component :is=&quot;...&quot;&gt; 来在多个组件间作切换时，被切换掉的组件会被卸载。 被传给 :is 的值可以是以下几种： 被注册的组件名 导入的组件对象 12345678910111213141516171819202122232425262728&lt;script setup&gt;import Home from &#x27;./Home.vue&#x27;import Posts from &#x27;./Posts.vue&#x27;import Archive from &#x27;./Archive.vue&#x27;import &#123; ref &#125; from &#x27;vue&#x27; const currentTab = ref(&#x27;Home&#x27;)const tabs = &#123; Home, Posts, Archive&#125;&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;demo&quot;&gt; &lt;button v-for=&quot;(_, tab) in tabs&quot; :key=&quot;tab&quot; :class=&quot;[&#x27;tab-button&#x27;, &#123; active: currentTab === tab &#125;]&quot; @click=&quot;currentTab = tab&quot; &gt; &#123;&#123; tab &#125;&#125; &lt;/button&gt; &lt;component :is=&quot;tabs[currentTab]&quot; class=&quot;tab&quot;&gt;&lt;/component&gt; &lt;/div&gt;&lt;/template&gt;","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://peapod.top/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"http://peapod.top/tags/Vue3/"}],"author":"taweizhong"},{"title":"Web APIs - 第4天笔记","slug":"Web-APIs-第4天笔记","date":"2023-04-17T08:05:56.000Z","updated":"2023-04-17T08:05:58.000Z","comments":true,"path":"2023/04/17/Web-APIs-第4天笔记/","link":"","permalink":"http://peapod.top/2023/04/17/Web-APIs-%E7%AC%AC4%E5%A4%A9%E7%AC%94%E8%AE%B0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Web APIs - 第3天笔记","slug":"Web-APIs-第3天笔记","date":"2023-04-17T08:05:53.000Z","updated":"2023-04-17T08:08:28.000Z","comments":true,"path":"2023/04/17/Web-APIs-第3天笔记/","link":"","permalink":"http://peapod.top/2023/04/17/Web-APIs-%E7%AC%AC3%E5%A4%A9%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Web APIs - 第3天 进一步学习 事件进阶，实现更多交互的网页特效，结合事件流的特征优化事件执行的效率 掌握阻止事件冒泡的方法 理解事件委托的实现原理 事件流事件流是对事件执行过程的描述，了解事件的执行过程有助于加深对事件的理解，提升开发实践中对事件运用的灵活度。 ![event](&#x2F;Users&#x2F;taweizhong&#x2F;Desktop&#x2F;js&#x2F;web APIs第三天&#x2F;02-笔记&#x2F;assets&#x2F;event.png) 如上图所示，任意事件被触发时总会经历两个阶段：【捕获阶段】和【冒泡阶段】。 简言之，捕获阶段是【从父到子】的传导过程，冒泡阶段是【从子向父】的传导过程。 捕获和冒泡了解了什么是事件流之后，我们来看事件流是如何影响事件执行的： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;body&gt; &lt;h3&gt;事件流&lt;/h3&gt; &lt;p&gt;事件流是事件在执行时的底层机制，主要体现在父子盒子之间事件的执行上。&lt;/p&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 获取嵌套的3个节点 const outer = document.querySelector(&#x27;.outer&#x27;); const inner = document.querySelector(&#x27;.inner&#x27;); const child = document.querySelector(&#x27;.child&#x27;); // html 元素添加事件 document.documentElement.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;html...&#x27;) &#125;) // body 元素添加事件 document.body.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;body...&#x27;) &#125;) // 外层的盒子添加事件 outer.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;outer...&#x27;) &#125;) // 中间的盒子添加事件 outer.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;inner...&#x27;) &#125;) // 内层的盒子添加事件 outer.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;child...&#x27;) &#125;) &lt;/script&gt;&lt;/body&gt; 执行上述代码后发现，当单击事件触发时，其祖先元素的单击事件也【相继触发】，这是为什么呢？ 结合事件流的特征，我们知道当某个元素的事件被触发时，事件总是会先经过其祖先才能到达当前元素，然后再由当前元素向祖先传递，事件在流动的过程中遇到相同的事件便会被触发。 再来关注一个细节就是事件相继触发的【执行顺序】，事件的执行顺序是可控制的，即可以在捕获阶段被执行，也可以在冒泡阶段被执行。 如果事件是在冒泡阶段执行的，我们称为冒泡模式，它会先执行子盒子事件再去执行父盒子事件，默认是冒泡模式。 如果事件是在捕获阶段执行的，我们称为捕获模式，它会先执行父盒子事件再去执行子盒子事件。 12345678910111213141516171819202122&lt;body&gt; &lt;h3&gt;事件流&lt;/h3&gt; &lt;p&gt;事件流是事件在执行时的底层机制，主要体现在父子盒子之间事件的执行上。&lt;/p&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 获取嵌套的3个节点 const outer = document.querySelector(&#x27;.outer&#x27;) const inner = document.querySelector(&#x27;.inner&#x27;) // 外层的盒子 outer.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;outer...&#x27;) &#125;, true) // true 表示在捕获阶段执行事件 // 中间的盒子 outer.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;inner...&#x27;) &#125;, true) &lt;/script&gt;&lt;/body&gt; 结论： addEventListener 第3个参数决定了事件是在捕获阶段触发还是在冒泡阶段触发 addEventListener 第3个参数为 true 表示捕获阶段触发，false 表示冒泡阶段触发，默认值为 false 事件流只会在父子元素具有相同事件类型时才会产生影响 绝大部分场景都采用默认的冒泡模式（其中一个原因是早期 IE 不支持捕获） 阻止冒泡阻止冒泡是指阻断事件的流动，保证事件只在当前元素被执行，而不再去影响到其对应的祖先元素。 123456789101112131415161718192021222324252627282930313233343536&lt;body&gt; &lt;h3&gt;阻止冒泡&lt;/h3&gt; &lt;p&gt;阻止冒泡是指阻断事件的流动，保证事件只在当前元素被执行，而不再去影响到其对应的祖先元素。&lt;/p&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 获取嵌套的3个节点 const outer = document.querySelector(&#x27;.outer&#x27;) const inner = document.querySelector(&#x27;.inner&#x27;) const child = document.querySelector(&#x27;.child&#x27;) // 外层的盒子 outer.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;outer...&#x27;) &#125;) // 中间的盒子 inner.addEventListener(&#x27;click&#x27;, function (ev) &#123; console.log(&#x27;inner...&#x27;) // 阻止事件冒泡 ev.stopPropagation() &#125;) // 内层的盒子 child.addEventListener(&#x27;click&#x27;, function (ev) &#123; console.log(&#x27;child...&#x27;) // 借助事件对象，阻止事件向上冒泡 ev.stopPropagation() &#125;) &lt;/script&gt;&lt;/body&gt; 结论：事件对象中的 ev.stopPropagation 方法，专门用来阻止事件冒泡。 鼠标经过事件： mouseover 和 mouseout 会有冒泡效果 mouseenter 和 mouseleave 没有冒泡效果 (推荐) 事件委托事件委托是利用事件流的特征解决一些现实开发需求的知识技巧，主要的作用是提升程序效率。 大量的事件监听是比较耗费性能的，如下代码所示 1234567891011&lt;script&gt; // 假设页面中有 10000 个 button 元素 const buttons = document.querySelectorAll(&#x27;table button&#x27;); for(let i = 0; i &lt;= buttons.length; i++) &#123; // 为 10000 个 button 元素添加了事件 buttons.addEventListener(&#x27;click&#x27;, function () &#123; // 省略具体执行逻辑... &#125;) &#125;&lt;/script&gt; 利用事件流的特征，可以对上述的代码进行优化，事件的的冒泡模式总是会将事件流向其父元素的，如果父元素监听了相同的事件类型，那么父元素的事件就会被触发并执行，正是利用这一特征对上述代码进行优化，如下代码所示： 12345678910&lt;script&gt; // 假设页面中有 10000 个 button 元素 let buttons = document.querySelectorAll(&#x27;table button&#x27;); // 假设上述的 10000 个 buttom 元素共同的祖先元素是 table let parents = document.querySelector(&#x27;table&#x27;); parents.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;点击任意子元素都会触发事件...&#x27;); &#125;)&lt;/script&gt; 我们的最终目的是保证只有点击 button 子元素才去执行事件的回调函数，如何判断用户点击是哪一个子元素呢？ ![event](&#x2F;Users&#x2F;taweizhong&#x2F;Desktop&#x2F;js&#x2F;web APIs第三天&#x2F;02-笔记&#x2F;assets&#x2F;event.png) 事件对象中的属性 target 或 srcElement属性表示真正触发事件的元素，它是一个元素类型的节点。 1234567891011121314&lt;script&gt; // 假设页面中有 10000 个 button 元素 const buttons = document.querySelectorAll(&#x27;table button&#x27;) // 假设上述的 10000 个 buttom 元素共同的祖先元素是 table const parents = document.querySelector(&#x27;table&#x27;) parents.addEventListener(&#x27;click&#x27;, function (ev) &#123; // console.log(ev.target); // 只有 button 元素才会真正去执行逻辑 if(ev.target.tagName === &#x27;BUTTON&#x27;) &#123; // 执行的逻辑 &#125; &#125;)&lt;/script&gt; 优化过的代码只对祖先元素添加事件监听，相比对 10000 个元素添加事件监听执行效率要高许多！！！ 其他事件页面加载事件加载外部资源（如图片、外联CSS和JavaScript等）加载完毕时触发的事件 有些时候需要等页面资源全部处理完了做一些事情 事件名：load 监听页面所有资源加载完毕： 123window.addEventListener(&#x27;load&#x27;, function() &#123; // xxxxx&#125;) 元素滚动事件滚动条在滚动的时候持续触发的事件 123window.addEventListener(&#x27;scroll&#x27;, function() &#123; // xxxxx&#125;) 页面尺寸事件会在窗口尺寸改变的时候触发事件： 123window.addEventListener(&#x27;resize&#x27;, function() &#123; // xxxxx&#125;) 元素尺寸与位置获取元素的自身宽高、包含元素自身设置的宽高、padding、border offsetWidth和offsetHeight 获取出来的是数值,方便计算 注意: 获取的是可视宽高, 如果盒子是隐藏的,获取的结果是0","categories":[],"tags":[]},{"title":"Web APIs - 第2天笔记","slug":"Web-APIs-第2天笔记","date":"2023-04-17T08:05:49.000Z","updated":"2023-04-17T08:07:56.000Z","comments":true,"path":"2023/04/17/Web-APIs-第2天笔记/","link":"","permalink":"http://peapod.top/2023/04/17/Web-APIs-%E7%AC%AC2%E5%A4%A9%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Web APIs - 第2天 学会通过为DOM注册事件来实现可交互的网页特效。 能够判断函数运行的环境并确字 this 所指代的对象 理解事件的作用，知道应用事件的 3 个步骤 学习会为 DOM 注册事件，实现简单可交互的网页特交。 事件事件是编程语言中的术语，它是用来描述程序的行为或状态的，一旦行为或状态发生改变，便立即调用一个函数。 例如：用户使用【鼠标点击】网页中的一个按钮、用户使用【鼠标拖拽】网页中的一张图片 事件监听结合 DOM 使用事件时，需要为 DOM 对象添加事件监听，等待事件发生（触发）时，便立即调用一个函数。 addEventListener 是 DOM 对象专门用来添加事件监听的方法，它的两个参数分别为【事件类型】和【事件回调】。 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;事件监听&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;事件监听&lt;/h3&gt; &lt;p id=&quot;text&quot;&gt;为 DOM 元素添加事件监听，等待事件发生，便立即执行一个函数。&lt;/p&gt; &lt;button id=&quot;btn&quot;&gt;点击改变文字颜色&lt;/button&gt; &lt;script&gt; // 1. 获取 button 对应的 DOM 对象 const btn = document.querySelector(&#x27;#btn&#x27;) // 2. 添加事件监听 btn.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;等待事件被触发...&#x27;) // 改变 p 标签的文字颜色 let text = document.getElementById(&#x27;text&#x27;) text.style.color = &#x27;red&#x27; &#125;) // 3. 只要用户点击了按钮，事件便触发了！！！ &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 完成事件监听分成3个步骤： 获取 DOM 元素 通过 addEventListener 方法为 DOM 节点添加事件监听 等待事件触发，如用户点击了某个按钮时便会触发 click 事件类型 事件触发后，相对应的回调函数会被执行 大白话描述：所谓的事件无非就是找个机会（事件触发）调用一个函数（回调函数）。 事件类型click 译成中文是【点击】的意思，它的含义是监听（等着）用户鼠标的单击操作，除了【单击】还有【双击】dblclick 1234567891011&lt;script&gt; // 双击事件类型 btn.addEventListener(&#x27;dblclick&#x27;, function () &#123; console.log(&#x27;等待事件被触发...&#x27;); // 改变 p 标签的文字颜色 const text = document.querySelector(&#x27;.text&#x27;) text.style.color = &#x27;red&#x27; &#125;) // 只要用户双击击了按钮，事件便触发了！！！&lt;/script&gt; 结论：【事件类型】决定了事件被触发的方式，如 click 代表鼠标单击，dblclick 代表鼠标双击。 事件处理程序addEventListener 的第2个参数是函数，这个函数会在事件被触发时立即被调用，在这个函数中可以编写任意逻辑的代码，如改变 DOM 文本颜色、文本内容等。 123456789101112&lt;script&gt; // 双击事件类型 btn.addEventListener(&#x27;dblclick&#x27;, function () &#123; console.log(&#x27;等待事件被触发...&#x27;) const text = document.querySelector(&#x27;.text&#x27;) // 改变 p 标签的文字颜色 text.style.color = &#x27;red&#x27; // 改变 p 标签的文本内容 text.style.fontSize = &#x27;20px&#x27; &#125;)&lt;/script&gt; 结论：【事件处理程序】决定了事件触发后应该执行的逻辑。 事件类型将众多的事件类型分类可分为：鼠标事件、键盘事件、表单事件、焦点事件等，我们逐一展开学习。 鼠标事件鼠标事件是指跟鼠标操作相关的事件，如单击、双击、移动等。 &#96;mouseenter 监听鼠标是否移入 DOM 元素 123456789101112131415161718&lt;body&gt; &lt;h3&gt;鼠标事件&lt;/h3&gt; &lt;p&gt;监听与鼠标相关的操作&lt;/p&gt; &lt;hr&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;script&gt; // 需要事件监听的 DOM 元素 const box = document.querySelector(&#x27;.box&#x27;); // 监听鼠标是移入当前 DOM 元素 box.addEventListener(&#x27;mouseenter&#x27;, function () &#123; // 修改文本内容 this.innerText = &#x27;鼠标移入了...&#x27;; // 修改光标的风格 this.style.cursor = &#x27;move&#x27;; &#125;) &lt;/script&gt;&lt;/body&gt; &#96;mouseleave 监听鼠标是否移出 DOM 元素 12345678910111213141516&lt;body&gt; &lt;h3&gt;鼠标事件&lt;/h3&gt; &lt;p&gt;监听与鼠标相关的操作&lt;/p&gt; &lt;hr&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;script&gt; // 需要事件监听的 DOM 元素 const box = document.querySelector(&#x27;.box&#x27;); // 监听鼠标是移出当前 DOM 元素 box.addEventListener(&#x27;mouseleave&#x27;, function () &#123; // 修改文本内容 this.innerText = &#x27;鼠标移出了...&#x27;; &#125;) &lt;/script&gt;&lt;/body&gt; 键盘事件keydown 键盘按下触发keyup 键盘抬起触发 焦点事件focus 获得焦点 blur 失去焦点 文本框输入事件input 事件对象任意事件类型被触发时与事件相关的信息会被以对象的形式记录下来，我们称这个对象为事件对象。 123456789101112131415161718&lt;body&gt; &lt;h3&gt;事件对象&lt;/h3&gt; &lt;p&gt;任意事件类型被触发时与事件相关的信息会被以对象的形式记录下来，我们称这个对象为事件对象。&lt;/p&gt; &lt;hr&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;script&gt; // 获取 .box 元素 const box = document.querySelector(&#x27;.box&#x27;) // 添加事件监听 box.addEventListener(&#x27;click&#x27;, function (e) &#123; console.log(&#x27;任意事件类型被触发后，相关信息会以对象形式被记录下来...&#x27;); // 事件回调函数的第1个参数即所谓的事件对象 console.log(e) &#125;) &lt;/script&gt;&lt;/body&gt; 事件回调函数的【第1个参数】即所谓的事件对象，通常习惯性的将这个对数命名为 event、ev 、ev 。 接下来简单看一下事件对象中包含了哪些有用的信息： ev.type 当前事件的类型 ev.clientX/Y 光标相对浏览器窗口的位置 ev.offsetX/Y 光标相于当前 DOM 元素的位置 注：在事件回调函数内部通过 window.event 同样可以获取事件对象。 环境对象 能够分析判断函数运行在不同环境中 this 所指代的对象。 环境对象指的是函数内部特殊的变量 this ，它代表着当前函数运行时所处的环境。 1234567891011121314151617181920212223242526&lt;script&gt; // 声明函数 function sayHi() &#123; // this 是一个变量 console.log(this); &#125; // 声明一个对象 let user = &#123; name: &#x27;张三&#x27;, sayHi: sayHi // 此处把 sayHi 函数，赋值给 sayHi 属性 &#125; let person = &#123; name: &#x27;李四&#x27;, sayHi: sayHi &#125; // 直接调用 sayHi() // window window.sayHi() // window // 做为对象方法调用 user.sayHi()// user person.sayHi()// person&lt;/script&gt; 结论： this 本质上是一个变量，数据类型为对象 函数的调用方式不同 this 变量的值也不同 【谁调用 this 就是谁】是判断 this 值的粗略规则 函数直接调用时实际上 window.sayHi() 所以 this 的值为 window 回调函数如果将函数 A 做为参数传递给函数 B 时，我们称函数 A 为回调函数。 1234567891011121314151617&lt;script&gt; // 声明 foo 函数 function foo(arg) &#123; console.log(arg); &#125; // 普通的值做为参数 foo(10); foo(&#x27;hello world!&#x27;); foo([&#x27;html&#x27;, &#x27;css&#x27;, &#x27;javascript&#x27;]); function bar() &#123; console.log(&#x27;函数也能当参数...&#x27;); &#125; // 函数也可以做为参数！！！！ foo(bar);&lt;/script&gt; 函数 bar 做参数传给了 foo 函数，bar 就是所谓的回调函数了！！！ 我们回顾一下间歇函数 setInterval 1234567&lt;script&gt; function fn() &#123; console.log(&#x27;我是回调函数...&#x27;); &#125; // 调用定时器 setInterval(fn, 1000);&lt;/script&gt; fn 函数做为参数传给了 setInterval ，这便是回调函数的实际应用了，结合刚刚学习的函数表达式上述代码还有另一种更常见写法。 123456&lt;script&gt; // 调用定时器，匿名函数做为参数 setInterval(function () &#123; console.log(&#x27;我是回调函数...&#x27;); &#125;, 1000);&lt;/script&gt; 结论： 回调函数本质还是函数，只不过把它当成参数使用 使用匿名函数做为回调函数比较常见","categories":[],"tags":[]},{"title":"Web APIs - 第1天笔记","slug":"Web-APIs-第1天笔记","date":"2023-04-17T08:05:44.000Z","updated":"2023-04-17T08:07:26.000Z","comments":true,"path":"2023/04/17/Web-APIs-第1天笔记/","link":"","permalink":"http://peapod.top/2023/04/17/Web-APIs-%E7%AC%AC1%E5%A4%A9%E7%AC%94%E8%AE%B0/","excerpt":"","text":"复习： splice() 方法用于添加或删除数组中的元素。 注意：这种方法会改变原始数组。 删除数组： splice(起始位置， 删除的个数) 比如：1 123let arr = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;]arr.splice(1,1) // 删除green元素console.log(arr) // [&#x27;red, &#x27;blue&#x27;] 添加元素 splice(起始位置，删除个数，添加数组元素) 12345let arr = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;]//arr.splice(1, 0, &#x27;pink&#x27;) // 在索引号是1的位置添加 pink//console.log(arr) // [&#x27;red&#x27;, &#x27;pink&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;]arr.splice(1, 0, &#x27;pink&#x27;, &#x27;hotpink&#x27;) // 在索引号是1的位置添加 pink hotpinkconsole.log(arr) // [&#x27;red&#x27;, &#x27;pink&#x27;, &#x27;hotpink&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;] Web APIs - 第1天笔记 了解 DOM 的结构并掌握其基本的操作，体验 DOM 的在开发中的作用 知道 ECMAScript 与 JavaScript 的关系 了解 DOM 的相关概念及DOM 的本质是一个对象 掌握查找节点的基本方法 掌握节点属性和文本的操作 能够使用间歇函数创建定时任务 介绍 知道 ECMAScript 与 JavaScript 的关系，Web APIs 是浏览器扩展的功能。 严格意义上讲，我们在 JavaScript 阶段学习的知识绝大部分属于 ECMAScript 的知识体系，ECMAScript 简称 ES 它提供了一套语言标准规范，如变量、数据类型、表达式、语句、函数等语法规则都是由 ECMAScript 规定的。浏览器将 ECMAScript 大部分的规范加以实现，并且在此基础上又扩展一些实用的功能，这些被扩展出来的内容我们称为 Web APIs。 ![guide](&#x2F;Users&#x2F;taweizhong&#x2F;Desktop&#x2F;js&#x2F;web APIs第一天&#x2F;02-笔记&#x2F;assets&#x2F;guide.png) ECMAScript 运行在浏览器中然后再结合 Web APIs 才是真正的 JavaScript，Web APIs 的核心是 DOM 和 BOM。 扩展阅读：ECMAScript 规范在不断的更新中，存在多个不同的版本，早期的版本号采用数字顺序编号如 ECMAScript3、ECMAScript5，后来由于更新速度较快便采用年份做为版本号，如 ECMAScript2017、ECMAScript2018 这种格式，ECMAScript6 是 2015 年发布的，常叫做 EMCAScript2015。 关于 JavaScript 历史的扩展阅读。 知道 DOM 相关的概念，建立对 DOM 的初步认识，学习 DOM 的基本操作，体会 DOM 的作用 DOM（Document Object Model）是将整个 HTML 文档的每一个标签元素视为一个对象，这个对象下包含了许多的属性和方法，通过操作这些属性或者调用这些方法实现对 HTML 的动态更新，为实现网页特效以及用户交互提供技术支撑。 简言之 DOM 是用来动态修改 HTML 的，其目的是开发网页特效及用户交互。 观察一个小例子： ![demo](&#x2F;Users&#x2F;taweizhong&#x2F;Desktop&#x2F;js&#x2F;web APIs第一天&#x2F;02-笔记&#x2F;assets&#x2F;demo.gif) 上述的例子中当用户分分别点击【开始】或【结束】按钮后，通过右侧调试窗口可以观察到 html 标签的内容在不断的发生改变，这便是通过 DOM 实现的。 概念DOM 树12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 文本 &lt;a href=&quot;&quot;&gt;链接名&lt;/a&gt; &lt;div id=&quot;&quot; class=&quot;&quot;&gt;文本&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 如下图所示，将 HTML 文档以树状结构直观的表现出来，我们称之为文档树或 DOM 树，文档树直观的体现了标签与标签之间的关系。 ![dom](&#x2F;Users&#x2F;taweizhong&#x2F;Desktop&#x2F;js&#x2F;web APIs第一天&#x2F;02-笔记&#x2F;assets&#x2F;web-api.jpg) DOM 节点节点是文档树的组成部分，每一个节点都是一个 DOM 对象，主要分为元素节点、属性节点、文本节点等。 【元素节点】其实就是 HTML 标签，如上图中 head、div、body 等都属于元素节点。 【属性节点】是指 HTML 标签中的属性，如上图中 a 标签的 href 属性、div 标签的 class 属性。 【文本节点】是指 HTML 标签的文字内容，如 title 标签中的文字。 【根节点】特指 html 标签。 其它… documentdocument 是 JavaScript 内置的专门用于 DOM 的对象，该对象包含了若干的属性和方法，document 是学习 DOM 的核心。 12345678910111213&lt;script&gt; // document 是内置的对象 // console.log(typeof document); // 1. 通过 document 获取根节点 console.log(document.documentElement); // 对应 html 标签 // 2. 通过 document 节取 body 节点 console.log(document.body); // 对应 body 标签 // 3. 通过 document.write 方法向网页输出内容 document.write(&#x27;Hello World!&#x27;);&lt;/script&gt; 上述列举了 document 对象的部分属性和方法，我们先对 document 有一个整体的认识。 获取DOM对象 querySelector 满足条件的第一个元素 querySelectorAll 满足条件的元素集合 返回伪数组 了解其他方式 getElementById getElementsByTagName 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;DOM - 查找节点&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;查找元素类型节点&lt;/h3&gt; &lt;p&gt;从整个 DOM 树中查找 DOM 节点是学习 DOM 的第一个步骤。&lt;/p&gt; &lt;ul&gt; &lt;li&gt;元素&lt;/li&gt; &lt;li&gt;元素&lt;/li&gt; &lt;li&gt;元素&lt;/li&gt; &lt;li&gt;元素&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; const p = document.querySelector(&#x27;p&#x27;) // 获取第一个p元素 const lis = document.querySelectorAll(&#x27;li&#x27;) // 获取第一个p元素 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 总结： document.getElementById 专门获取元素类型节点，根据标签的 id 属性查找 任意 DOM 对象都包含 nodeType 属性，用来检检测节点类型 操作元素内容通过修改 DOM 的文本内容，动态改变网页的内容。 innerText 将文本内容添加&#x2F;更新到任意标签位置，文本中包含的标签不会被解析。 123456&lt;script&gt; // innerText 将文本内容添加/更新到任意标签位置 const intro = document.querySelector(&#x27;.intro&#x27;) // intro.innerText = &#x27;嗨~ 我叫李雷！&#x27; // intro.innerText = &#x27;&lt;h4&gt;嗨~ 我叫李雷！&lt;/h4&gt;&#x27;&lt;/script&gt; innerHTML 将文本内容添加&#x2F;更新到任意标签位置，文本中包含的标签会被解析。 123456&lt;script&gt; // innerHTML 将文本内容添加/更新到任意标签位置 const intro = document.querySelector(&#x27;.intro&#x27;) intro.innerHTML = &#x27;嗨~ 我叫韩梅梅！&#x27; intro.innerHTML = &#x27;&lt;h4&gt;嗨~ 我叫韩梅梅！&lt;/h4&gt;&#x27;&lt;/script&gt; 总结：如果文本内容中包含 html 标签时推荐使用 innerHTML，否则建议使用 innerText 属性。 ##操作元素属性 有3种方式可以实现对属性的修改： 常用属性修改 直接能过属性名修改，最简洁的语法 12345678&lt;script&gt; // 1. 获取 img 对应的 DOM 元素 const pic = document.querySelector(&#x27;.pic&#x27;) // 2. 修改属性 pic.src = &#x27;./images/lion.webp&#x27; pic.width = 400; pic.alt = &#x27;图片不见了...&#x27;&lt;/script&gt; 控制样式属性 应用【修改样式】，通过修改行内样式 style 属性，实现对样式的动态修改。 通过元素节点获得的 style 属性本身的数据类型也是对象，如 box.style.color、box.style.width 分别用来获取元素节点 CSS 样式的 color 和 width 的值。 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;练习 - 修改样式&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;随便一些文本内容&lt;/div&gt; &lt;script&gt; // 获取 DOM 节点 const box = document.querySelector(&#x27;.intro&#x27;) box.style.color = &#x27;red&#x27; box.style.width = &#x27;300px&#x27; // css 属性的 - 连接符与 JavaScript 的 减运算符 // 冲突，所以要改成驼峰法 box.style.backgroundColor = &#x27;pink&#x27; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 任何标签都有 style 属性，通过 style 属性可以动态更改网页标签的样式，如要遇到 css 属性中包含字符 - 时，要将 - 去掉并将其后面的字母改成大写，如 background-color 要写成 box.style.backgroundColor 操作类名(className) 操作CSS 如果修改的样式比较多，直接通过style属性修改比较繁琐，我们可以通过借助于css类名的形式。 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;练习 - 修改样式&lt;/title&gt; &lt;style&gt; .pink &#123; background: pink; color: hotpink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;随便一些文本内容&lt;/div&gt; &lt;script&gt; // 获取 DOM 节点 const box = document.querySelector(&#x27;.intro&#x27;) box.className = &#x27;pink&#x27; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意： 1.由于class是关键字, 所以使用className去代替 2.className是使用新值换旧值, 如果需要添加一个类,需要保留之前的类名 通过 classList 操作类控制CSS 为了解决className 容易覆盖以前的类名，我们可以通过classList方式追加和删除类名 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div &#123; width: 200px; height: 200px; background-color: pink; &#125; .active &#123; width: 300px; height: 300px; background-color: hotpink; margin-left: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;one&quot;&gt;&lt;/div&gt; &lt;script&gt; // 1.获取元素 // let box = document.querySelector(&#x27;css选择器&#x27;) let box = document.querySelector(&#x27;div&#x27;) // add是个方法 添加 追加 // box.classList.add(&#x27;active&#x27;) // remove() 移除 类 // box.classList.remove(&#x27;one&#x27;) // 切换类 box.classList.toggle(&#x27;one&#x27;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 操作表单元素属性表单很多情况，也需要修改属性，比如点击眼睛，可以看到密码，本质是把表单类型转换为文本框 正常的有属性有取值的跟其他的标签属性没有任何区别 获取:DOM对象.属性名 设置:DOM对象.属性名&#x3D; 新值 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;text&quot; value=&quot;请输入&quot;&gt; &lt;button disabled&gt;按钮&lt;/button&gt; &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; class=&quot;agree&quot;&gt; &lt;script&gt; // 1. 获取元素 let input = document.querySelector(&#x27;input&#x27;) // 2. 取值或者设置值 得到input里面的值可以用 value // console.log(input.value) input.value = &#x27;小米手机&#x27; input.type = &#x27;password&#x27; // 2. 启用按钮 let btn = document.querySelector(&#x27;button&#x27;) // disabled 不可用 = false 这样可以让按钮启用 btn.disabled = false // 3. 勾选复选框 let checkbox = document.querySelector(&#x27;.agree&#x27;) checkbox.checked = false &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 自定义属性标准属性: 标签天生自带的属性 比如class id title等, 可以直接使用点语法操作比如： disabled、checked、selected 自定义属性： 在html5中推出来了专门的data-自定义属性 在标签上一律以data-开头 在DOM对象上一律以dataset对象方式获取 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div data-id=&quot;1&quot;&gt; 自定义属性 &lt;/div&gt; &lt;script&gt; // 1. 获取元素 let div = document.querySelector(&#x27;div&#x27;) // 2. 获取自定义属性值 console.log(div.dataset.id) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 间歇函数 知道间歇函数的作用，利用间歇函数创建定时任务。 setInterval 是 JavaScript 中内置的函数，它的作用是间隔固定的时间自动重复执行另一个函数，也叫定时器函数。 12345678910&lt;script&gt; // 1. 定义一个普通函数 function repeat() &#123; console.log(&#x27;不知疲倦的执行下去....&#x27;) &#125; // 2. 使用 setInterval 调用 repeat 函数 // 间隔 1000 毫秒，重复调用 repeat setInterval(repeat, 1000)&lt;/script&gt;","categories":[],"tags":[]},{"title":"Fabric入门教程","slug":"Fabric入门教程","date":"2023-03-27T01:42:39.000Z","updated":"2023-04-17T08:07:04.000Z","comments":true,"path":"2023/03/27/Fabric入门教程/","link":"","permalink":"http://peapod.top/2023/03/27/Fabric%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/","excerpt":"","text":"Hyperledger Fabric 2.0 使用教程简介区块链是一个由分布式网络中的节点维护的不可篡改的账本。 Hyperledger Fabric 是一个开源的企业级许可分布式账本技术（Distributed Ledger Technology，DLT）平台，专为在企业环境中使用而设计。 模块化Fabric 由以下模块化的组件组成： 可插拔的排序服务对交易顺序建立共识，然后向节点广播区块； 可插拔的成员服务提供者负责将网络中的实体与加密身份相关联； 可选的P2P gossip 服务通过排序服务将区块发送到其他节点； 智能合约（“链码”）隔离运行在容器环境（例如 Docker）中。它们可以用标准编程语言编写，但不能直接访问账本状态； 账本可以通过配置支持多种 DBMS； 可插拔的背书和验证策略，每个应用程序可以独立配置。 许可区块链在一组已知的、已识别的且经常经过审查的参与者中操作区块链，这些参与者在产生一定程度信任的治理模型下运作。 通过依赖参与者的身份，许可区块链可以使用更传统的崩溃容错（CFT）或拜占庭容错（BFT）共识协议，而不需要昂贵的挖掘。 在许可的情况下，降低了参与者故意通过智能合约引入恶意代码的风险。 链码三个关键点适用于智能合约，尤其是应用于平台时： 多个智能合约在网络中同时运行， 它们可以动态部署（很多情况下任何人都可以部署）， 应用代码应视为不被信任的，甚至可能是恶意的。 顺序执行架构，其中共识协议： 验证并将交易排序，然后将它们传播到所有的节点， 每个节点按顺序执行交易。 结果一定是确定的。 执行-排序-验证架构，它将交易流分为三个步骤： 执行一个交易并检查其正确性，从而给它背书， 通过（可插拔的）共识协议将交易排序， 提交交易到账本前先根据特定应用程序的背书策略验证交易 在交易顺序达成最终一致前执行交易。每个交易只需要由满足交易的背书策略所必需的节点的子集来执行（背书）。这样可以并行执行，从而提高系统的整体性能和规模。第一阶段也消除了任何非确定性，因为在排序之前可以过滤掉不一致的结果。 隐私和保密在一个公共的、非许可的区块链网络中，利用 PoW 作为其共识模型，交易在每个节点上执行。这意味着合约本身和他们处理的交易数据都不保密。每个交易以及实现它的代码，对于网络中的每个节点都是可见的。 Hyperledger Fabric 是一个许可平台，通过其通道架构和 私有数据特性实现保密。 在通道方面，参与到通道的节点才有权访问智能合约（链码）和交易数据，以此保证了隐私性和保密性。 私有数据通过在通道中的成员间使用集合，实现了和通道相同的隐私能力并且不用创建和维护独立的通道。 可插拔共识Fabric 目前提供了一种基于etcd 库 中 Raft 协议 的 CFT 排序服务的实现。 一个 Fabric 网络中可以有多种排序服务以支持不同的应用或应用需求。 性能和可扩展一个区块链平台的性能可能会受到许多因素的影响，例如交易大小、区块大小、网络大小以及硬件限制等。 Hyperledger Caliper的基准测试框架。 将 Fabric 扩展到 20000 笔交易每秒（Scaled Fabric to 20,000 transactions per second）。 更新说明智能合约的去中心化治理新的 Fabric 链码生命周期支持多个组织在链码和账本交互之前协商链码的参数，例如链码背书策略。 新的模式有几个改进: 多个组织必须认同链码参数。去中心化的模型要求在链码在通道上变为活动状态之前，要有足够数量的组织就背书策略和其他细节达成一致意见。 更周密的链码升级过程。只有在足够数量的组织批准升级后才能升级链码。 更简单的背书策略和私有数据集合更新 。支持在不重新打包或重新安装链码的情况下，更改背书策略或私有数据集合配置。 可查验的链码包 Fabric 生命周期将链码封装在可读性更强的 tar 文件中。 使用一个包在通道上启动多个链码。 通道成员之间的链码包不需要为同一个。 使用新的链码生命周期 私有数据增强私有数据模式： 共享和验证私有数据 集合级别的背书策略 每个组织的隐式集合 外部链码启动器 消除 Docker 守护进程依赖 容器的替代品 不再要求链码在 Docker 容器中运行，可以在运营者选择的环境（包括容器）中执行。 可执行的外部构建器 操作员可以提供一组可执行的外部构建器，以覆盖 Peer 节点构建和启动链码方式。 作为外部服务的链码 提高状态数据库缓存 在使用外部 CouchDB 状态数据库时，背书和验证阶段的读取延迟历来是性能瓶颈。 在 Fabric v2.0 中，用快速的本地缓存读取取代了 Peer 节点中那些耗费资源的查找操作。可以使用 core.yaml 文件中的属性 cachesize 来配置缓存大小。 关键概念1.账本一个状态（您的银行余额）和一组促成该状态的有序交易（收入和支出）。 呈现一组账本状态的当前值，同时记录下促成了以上账本状态的交易的历史。 Hyperledger Fabric 中的账本由“世界状态“和”区块链“这两部分组成，它们彼此不同但却相互关联。 世界状态是一个数据库，它存储了一组账本状态的当前值。（余额） 通过世界状态，程序可以直接访问一个账本状态的当前值，不需要遍历整个交易日志来计算当前值。 可以创建、更新和删除状态，所以世界状态能够频繁更改。 区块链是交易日志，它记录了促成当前世界状态的所有改变。 一旦把数据写入区块链，就无法修改，它是不可篡改的。 从世界状态中可以直接获取当前值。世界状态被作为数据库来实现。这一点很有意义，因为数据库为有效存储和状态检索提供了充分的算子。 所有被提交的交易，无论有效与否，都会被收进区块链。 关键设计在于，只有那些受到相关背书组织签名的交易才会更新世界状态。 每当更新状态时，都会检查该状态的版本，以确保当前状态与背书时的版本相匹配。这就确保了世界状态是按照预期进行更新的，没有发生并发更新。 区块链记录了每个账本状态之前的所有版本以及状态是如何被更改的。 区块链的结构是一群相互链接的区块的序列化日志，其中每个区块都包含一系列交易，各项交易代表了一个对世界状态进行的查询或更新操作。 区块链总是以文件实现，而与之相反的是，世界状态以数据库实现。 创世区块包含了一个配置交易，该交易含有网络配置（未显示）的初始状态。 世界状态数据库选项LevelDB 是世界状态数据库的默认选项，当账本状态是简单的键值对时，使用 LevelDB 非常合适。LevelDB 数据库与 peer 节点位于相同位置，它被嵌入与 peer 节点相同的操作系统进程中。 当账本状态结构为 JSON 文档时，以 CouchDB 来实现世界状态非常合适，这是因为业务交易涉及的数据类型通常十分丰富，而 CouchDB 可支持对这些数据类型进行各种形式的查询和更新。在实现方面，CouchDB 是在单独的操作系统进程中运行的，但是节点和 CouchDB 实例之间仍然存在1:1的关系。 命名空间每个链码都有自己的世界状态，并且与所有其他链码的世界状态分离。世界状态位于一个命名空间中，因此只有位于同一链码中的智能合约才能访问一个给定的命名空间。 每个通道都有一个完全独立的账本。这意味着完全独立的区块链和完全独立的世界状态，包括命名空间。 2.通道功能（capabilities）支持不同的版本 才使得Fabric节点能够滚动升级。 capabilities在每个通道的配置中定义， 通过定义行为会产生一致结果的版本，确保了确定性。 capabilities使运行在不同版本的节点能够 以兼容和一致的方式在给定特定区块高度的通道配置下运行。 每次发布版本不一定都有一个新的capability level。 在通道中，节点版本必须不能低于特定的capability版本。 3.策略策略是一组规则，用来定义如何做出决策和实现特定结果。 Fabric 策略表示成员如何同意或者拒绝网络、通道或者智能合约的变更。策略是基础设施的管理机制。 策略决定了那些组织可以访问或者更新 Fabric 网络，并且提供了强制执行这些决策的机制。 系统通道配置排序系统通道配置区块中的策略治理着排序服务使用的共识，并定义了新区块如何被创建。系统通道也治理着联盟中的哪些成员可以创建新通道。","categories":[],"tags":[]},{"title":"Git教程","slug":"Git教程","date":"2023-01-15T07:59:39.000Z","updated":"2023-01-15T11:31:20.000Z","comments":true,"path":"2023/01/15/Git教程/","link":"","permalink":"http://peapod.top/2023/01/15/Git%E6%95%99%E7%A8%8B/","excerpt":"","text":"Git简介Git是一个开放源码的分布式版本控制系统。 初始化设置在新的系统上要配置工作环境。 git config工具可以配置或读取相应的工作环境变量。 用户信息配置12git config --global user.name &quot;username&quot;git config --global user.email johndoe@example.com 查看配置信息12git config --listgit config user.name // 查阅环境变量的设定 获取Git帮助12git help &lt;verb&gt;git help config // 查看config命令 设置仓库本地创建仓库进入工作目录 1git init 远程仓库克隆12git clone git@gitee.com:oschina/git-osc.gitgit clone git@gitee.com:oschina/git-osc.git mygrit // 克隆之后使用自定义的文件名 基本操作12345678cd /home/testgit initgit add &quot;READNE.md&quot; // 将文件添加到Git的暂存区git commit -m &quot;v1&quot; // Git的暂存区提交版本到仓库git status -s // 查看项目当前文件提交状态git push https://gitee.com/***/test.git // 将本地的Git仓库信息推送上传到服务器git log // 查看git提交的日志 仓库操作1234git remote rename origin ch1 // 修改仓库名git remote add origin // 添加一个仓库git remote -v // 查看当前仓库对应的远程仓库地址git remote set-url origin 仓库地址 // 修改仓库对应的远程仓库地址","categories":[{"name":"笔记","slug":"笔记","permalink":"http://peapod.top/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://peapod.top/tags/Git/"}],"author":"taweizhong"},{"title":"区块链环境配置教程","slug":"区块链环境配置教程","date":"2022-11-10T14:10:37.000Z","updated":"2023-01-03T14:59:00.000Z","comments":true,"path":"2022/11/10/区块链环境配置教程/","link":"","permalink":"http://peapod.top/2022/11/10/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/","excerpt":"","text":"Hyperledger Fabric v2.2 Ubuntu准备阶段运行环境：Ubuntu18.04安装git（分布式版本控制系统）1apt install git 安装cURL（利用URL语法在命令行下工作的文件传输工具）1apt install curl 安装docker在 Ubuntu | 上安装 Docker 引擎码头工人文档 1apt install docker.io 设置docker服务 123systemctl start docker // 启动docker的服务systemctl enable docker // 设置开机启动usermod -a -G docker root // 将root用户添加到docker组中 安装docker-compose（注：这个地方版本要2.xx）centos 8安装docker-compose - 民工黑猫 - 博客园 (cnblogs.com) 安装golang0.16 下载安装包 解压 配置环境变量 验证 安装clash服务器安装Clash - 秋季的blog (taweizhong.github.io) 安装示例、二进制和 Docker 镜像1curl -sSL https://bit.ly/2ysbOFE | bash -s -- 2.2.0 Hyperledger Fabric v2.2 Centos准备阶段运行环境：Centos v8安装git（分布式版本控制系统）1yum install git 安装cURL（利用URL语法在命令行下工作的文件传输工具）1yum install curl 安装docker在 CentOS | 上安装 Docker 引擎码头工人文档 设置docker服务 123systemctl start docker // 启动docker的服务systemctl enable docker // 设置开机启动usermod -a -G docker root // 将root用户添加到docker组中 安装docker-compose（注：这个地方版本要2.xx）centos 8安装docker-compose - 民工黑猫 - 博客园 (cnblogs.com) 安装golang0.16 下载安装包 解压 配置环境变量 验证 安装clash服务器安装Clash - 秋季的blog (taweizhong.github.io) 安装示例、二进制和 Docker 镜像1curl -sSL https://bit.ly/2ysbOFE | bash -s -- 2.2.0","categories":[{"name":"区块链","slug":"区块链","permalink":"http://peapod.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[],"author":"taweizhong"},{"title":"GCC","slug":"GCC","date":"2022-11-04T11:23:05.000Z","updated":"2022-11-04T12:41:06.000Z","comments":true,"path":"2022/11/04/GCC/","link":"","permalink":"http://peapod.top/2022/11/04/GCC/","excerpt":"","text":"GCCGNU 计划，最终的目标是打造一套完全自由、开源的操作系统。 早期 GCC 的全拼为 GNU C Compiler，即 GUN 计划诞生的 C 语言编译器，显然最初 GCC 的定位确实只用于编译 C 语言。 GCC的功能得到了很大的扩展，它不仅可以用来编译C语言程序，还可以处理C++、GO等多种语言。被重新定义为 GNU Compiler Collection，即 GNU 编译器套件。 安装GCC编译器12yum -y install gccyum -y install gcc-c++ 以源码的方式安装 12yum install -y glibc-static libstdc++-static # 所需的静态链接库yum install -y gcc gcc-c++ 安装包 gcc-10.1.0.tar.gz Windows平台安装GCC 移植版主要有 2 种，分别为 MinGW 和 Cygwin。 MinGW 侧重于服务 Windows 用户可以使用 GCC 编译环境，直接生成可运行 Windows 平台上的可执行程序，相比后者体积更小，使用更方便。 Cygwin 则可以提供一个完整的 Linux 环境，借助它不仅可以在 Windows 平台上使用 GCC 编译器，理论上可以运行 Linux 平台上所有的程序。 GCC的组成部分 部分 描述 c++ gcc 的一个版木，默认语言设置为 C++，而且在连接的时候自动包含标准 C++ 库。这和 g++ 一样 ccl 实际的C编译程序 cclplus 实际的 C++ 编泽程序 collect2 在不使用 GNU 连接程序的系统上，有必要运行 collect2 来产生特定的全局初始化代码（例如 C++ 的构造函数和析构函数） configure GCC 源代码树根目录中的一个脚木。用于设置配置值和创建GCC 编译程序必需的 make 程序的描述文件 crt0.o 这个初始化和结束代码是为每个系统定制的，而且也被编译进该文件，该文件然后会被连接到每个可执行文件中来执行必要的启动和终止程序 cygwin1.dll Windows 的共享库提供的 API，模拟 UNIX 系统调用 f77 该驱动程序可用于编译 Fortran f771 实际的 Fortran 编译程序 g++ gcc 的一个版木，默认语言设置为 C++，而且在连接的时候自动包含标准 C++ 库。这和 c++ 一样 gcc 该驱动程序等同于执行编译程序和连接程序以产生需要的输出 gcj 该驱动程序用于编译 Java gnat1 实际的 Ada 编译程序 gnatbind 一种工具，用于执行 Ada 语言绑定 gnatlink 一种工具，用于执行 Ada 语言连接 jc1 实际的 Java 编译程序 libgcc 该库包含的例程被作为编泽程序的一部分，是因为它们可被连接到实际的可执行程序中。 它们是特殊的例程，连接到可执行程序，来执行基木的任务，例如浮点运算。这些库中的例程通常都是平台相关的 libgcj 运行时库包含所有的核心 Java 类 libobjc 对所有 Objective-C 程序都必须的运行时库 libstdc++ 运行时库，包括定义为标准语言一部分的所有的 C++ 类和函数 C程序的编译过程 预处理处理那些源文件和头文件中以#开头的命令。 规则： 将所有的#define删除，并展开所有的宏定义。 处理所有条件编译命令，比如 #if、#ifdef、#elif、#else、#endif 等。 处理#include命令，将被包含文件的内容插入到该命令所在的位置，这与复制粘贴的效果一样。注意，这个过程是递归进行的，也就是说被包含的文件可能还会包含其他的文件。 删除所有的注释//和/* ... */。 添加行号和文件名标识，便于在调试和出错时给出具体的代码位置。 保留所有的#pragma命令，因为编译器需要使用它们。 预处理的结果是生成.i文件。 命令： 1g++ -E hello.cpp -o hello.i -E表示只进行预编译。 编译进行一些列的词法分析、语法分析、语义分析以及优化后生成相应的汇编代码文件。 编译的结果是生成.s文件。 命令： 12g++ -S hello.cpp -o hello.sg++ -S hello.i -o hello.s 汇编将汇编代码转换成可以执行的机器指令。 汇编的结果是产生目标文件，在 GCC 下的后缀为.o，在 Visual Studio 下的后缀为.obj。 链接目标文件已经是二进制文件，与可执行文件的组织形式类似，只是有些函数和全局变量的地址还未找到，程序不能执行。 链接的作用就是找到这些目标地址，将所有的目标文件组织成一个可以执行的二进制文件。 GCC编译C&#x2F;C++程序1g++ hello.cpp GCC 编译器会在当前目录下生成一个名为 a.out 的可执行文件。 gcc&#x2F;g++指令选项 功 能 -E（大写） 预处理指定的源文件，不进行编译。 -S（大写） 编译指定的源文件，但是不进行汇编。 -c 编译、汇编指定的源文件，但是不进行链接。 -o 指定生成文件的文件名。 -llibrary（-I library） 其中 library 表示要搜索的库文件的名称。该选项用于手动指定链接环节中程序可以调用的库文件。建议 -l 和库文件名之间不使用空格，比如 -lstdc++。 -ansi 对于 C 语言程序来说，其等价于 -std&#x3D;c90；对于 C++ 程序来说，其等价于 -std&#x3D;c++98。 -std&#x3D; 手动指令编程语言所遵循的标准，例如 c89、c90、c++98、c++11 等。 GCC -E选项通过为 gcc 指令添加 -E 选项，即可控制 GCC 编译器仅对源代码做预处理操作。 默认情况下 gcc -E 指令只会将预处理操作的结果输出到屏幕上，并不会自动保存到某个文件。 和 -o 选项连用，将结果导入到指令的文件中。 1g++ -E hello.cpp -o hello.i 为 gcc 指令再添加一个 -C 选项，阻止 GCC 删除源文件和头文件中的注释。 1gcc -E -C demo.c -o demo.i GCC -S选项：编译非汇编文件编译是整个程序构建的核心部分，也是最复杂的部分之一。 编译，简单理解就是将预处理得到的程序代码，经过一系列的词法分析、语法分析、语义分析以及优化，加工为当前机器支持的汇编代码。 默认情况下，编译操作会自行新建一个文件名和指定文件相同、后缀名为 .s 的文件，并将编译的结果保存在该文件中。 为 gcc -S 指令添加 -o 选项，令 GCC 编译器将编译结果保存在我们指定的文件中。 1gcc -S demo.i -o test.i 最终生成的 .s 汇编文件。 GCC -c选项：生成目标文件汇编其实就是将汇编代码转换成可以执行的机器指令。 为 gcc 指令添加 -c 选项，即可让 GCC 编译器将指定文件加工至汇编阶段，并生成相应的目标文件。 1gcc -c demo.s 生成了和 demo.s 同名但后缀名为 .o 的文件，这就是经过汇编操作得到的目标文件。 可以为 gcc -c 指令在添加一个 -o 选项，用于将汇编操作的结果输入到指定文件中。 1gcc -c demo.s -o test.o GCC -l选项：手动添加链接库链接器把多个二进制的目标文件（object file）链接成一个单独的可执行文件。 在链接过程中，它必须把符号（变量名、函数名等一些列标识符）用对应的数据的内存地址（变量地址、函数地址等）替代，以完成程序中多个模块的外部引用。 当把程序链接到一个链接库时，只会链接程序所用到的函数的目标文件。 标准库的大部分函数通常放在文件 libc.a 中，或者放在用于共享的动态链接文件 libc.so 中。 链接库一般位于 &#x2F;lib&#x2F; 或 &#x2F;usr&#x2F;lib&#x2F;，或者位于 GCC 默认搜索的其他目录。 GCC 默认会链接 libc.a 或者 libc.so，但是对于其他的库（例如非标准库、第三方库等），就需要手动添加。 1gcc main.c -o main.out -lm 有三种方式可以链接在 GCC 搜索路径以外的链接库： 链接库作为一般的目标文件，为 GCC 指定该链接库的完整路径与文件名。 1gcc main.c -o main.out /usr/lib/libm.a 用-L选项，为 GCC 增加另一个搜索链接库的目录： 1gcc main.c -o main.out -L/usr/lib -lm 包括所需链接库的目录加到环境变量 LIBRARYPATH 中。 gcc指令一次处理多个文件1gcc -c demo1.c demo2.c GCC编译多文件项目12345gcc -c myfun.c main.clsmain.c main.o myfun.c myfun.ogcc myfun.o main.o -o main.exe ./main.exe gcc 指令还可以直接编译并链接它们 12gcc myfun.c main.c -o main.exe ./main.exe 如果一个项目中有十几个甚至几十个源文件,用 *.c 表示所有的源文件。 1gcc *.c -o main.exe GCC使用静态链接库和动态链接库库文件中每个目标文件存储的代码，并非完整的程序，而是一个个实用的功能模块。 C++ 库文件不仅提供有使用的函数，还有大量事先设计好的类（如 string 字符串类）。 头文件和库文件并不是一码事，它们最大的区别在于：头文件只存储变量、函数或者类等这些功能模块的声明部分，库文件才负责存储各模块具体的实现部分。 所有的库文件都提供有相应的头文件作为调用它的接口。 库文件是无法直接使用的，只能通过头文件间接调用。 库文件只是一个统称，代指的是一类压缩包，它们都包含有功能实用的目标文件。 库文件用于程序的链接阶段。 采用静态链接方式实现链接操作的库文件，称为静态链接库；采用动态链接方式实现链接操作的库文件，称为动态链接库。 静态链接库程序文件中哪里用到了库文件中的功能模块，GCC 编译器就会将该模板代码直接复制到程序文件的适当位置，最终生成可执行文件。 优势劣势： 优势是，生成的可执行文件不再需要任何静态库文件的支持就可以独立运行（可移植性强）； 劣势是，如果程序文件中多次调用库中的同一功能模块，则该模块代码势必就会被复制多次，生成的可执行文件中会包含多段完全相同的代码，造成代码的冗余。 动态链接库程序文件中哪里需要库文件的功能模块，GCC 编译器不会直接将该功能模块的代码拷贝到文件中，而是将功能模块的位置信息记录到文件中，直接生成可执行文件。 采用动态链接库生成的可执行文件运行时，GCC 编译器会将对应的动态链接库一同加载在内存中，由于可执行文件中事先记录了所需功能模块的位置信息，所以在现有动态链接库的支持下，也可以成功运行。 优势劣势： 真正的实现代码会在程序运行时被载入内存，这意味着，即便功能模块被调用多次，使用的都是同一份实现代码。 此方式生成的可执行文件无法独立运行，必须借助相应的库文件（可移植性差）。 动态链接库生成的可执行文件的体积更小，因为其内部不会被复制一堆冗余的代码。 GCC 编译器生成可执行文件时，默认情况下会优先使用动态链接库实现链接操作，除非当前系统环境中没有程序文件所需要的动态链接库，GCC 编译器才会选择相应的静态链接库。 静态链接库和动态链接库通常存放在 &#x2F;usr&#x2F;bin 或者 &#x2F;bin 目录下。","categories":[],"tags":[]},{"title":"c到cpp","slug":"c到cpp","date":"2022-11-04T10:59:28.000Z","updated":"2022-11-04T11:06:12.000Z","comments":true,"path":"2022/11/04/c到cpp/","link":"","permalink":"http://peapod.top/2022/11/04/c%E5%88%B0cpp/","excerpt":"","text":"C语言到C++类和对象简介123456789101112131415#include &lt;stdio.h&gt;struct Stu &#123; char *name; int age;&#125;;void display(struct Stu stu)&#123; printf(&quot;%s, %d&quot;, stu.name, stu.age);&#125;int main()&#123; Stu stu; stu.name = &quot;taweizhong&quot;; stu.age = &quot;22&quot;; display(stu); return 0;&#125;","categories":[],"tags":[]},{"title":"分布式系统","slug":"分布式系统","date":"2022-10-26T11:07:12.000Z","updated":"2022-10-27T00:21:50.000Z","comments":true,"path":"2022/10/26/分布式系统/","link":"","permalink":"http://peapod.top/2022/10/26/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"课程笔记翻译多处理器与多核处理器 多核处理器 多处理器 芯片组 DDR5 是第五代 DDR SDRAM 的简称，DDR SDRAM 是英文 Double Data Rate SDRAM 的缩写，中文译为双倍速率 SDRAM。 nvme是通信协议，主流的主板上，都支持m.2 nvme协议。 高速串行总线，pcie总线有两种规格，即pcie3.0和pcie4.0。 分布式系统软件负载均衡 Nginx：高性能、高并发的web服务器；功能包括负载均衡、反向代理、静态内容缓存、访问控制；工作在应用层 LVS： Linux virtual server，基于集群技术和Linux操作系统实现一个高性能、高可用的服务器；工作在网络层 容器 docker kubernetes cache memcache redis 协调中心： etcd zookeeper：使用了Paxos协议Paxos是强一致性。 rpc框架 grpc dubbo是阿里开源的Java语言开发的高性能RPC框架 分布式系统的应用区块链 分布式账本 In Search of an Understandable Consensus Algorithm (raft.github.io) 大数据 Hadoop生态圈 CAP定理BASE理论Paxos共识算法Gossip协议Raft算法","categories":[{"name":"分布式系统","slug":"分布式系统","permalink":"http://peapod.top/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://peapod.top/tags/%E7%AC%94%E8%AE%B0/"}],"author":"taweizhong"},{"title":"知链区块链教程","slug":"知链区块链教程","date":"2022-10-19T08:47:26.000Z","updated":"2022-10-19T09:58:38.000Z","comments":true,"path":"2022/10/19/知链区块链教程/","link":"","permalink":"http://peapod.top/2022/10/19/%E7%9F%A5%E9%93%BE%E5%8C%BA%E5%9D%97%E9%93%BE%E6%95%99%E7%A8%8B/","excerpt":"","text":"目录初识区块链诞生区块链诞生http://study.educhainx.com/newres/static/pdfjs/web/viewer.html?file=6JYM32GCS7GIGTLWH45BD5 发展区块链的发展http://study.educhainx.com/newres/static/pdfjs/web/viewer.html?file=UORY960KQ8CKNGRTYO5JBF 结构与特性区块链的结构与特性http://study.educhainx.com/newres/static/pdfjs/web/viewer.html?file=V_5BMPQISOOGIYVMNVKV6B 区块头与区块体区块与区块体http://study.educhainx.com/newres/static/pdfjs/web/viewer.html?file=T97CBLZBSQCM3X6QVHFK46 区块链原理数据存储：分布式记账分布式记账http://study.educhainx.com/newres/static/pdfjs/web/viewer.html?file=XFMUBGQUT8--SUHYGSBS2C 公链记账：挖矿与奖励挖矿与奖励http://study.educhainx.com/newres/static/pdfjs/web/viewer.html?file=-YGVXCXOSYOL48Q0EHFOAA 交易支付：代币交易代币交易http://study.educhainx.com/newres/static/pdfjs/web/viewer.html?file=SAXYHAPGR3W6WKG1E1HZDA 系统奖励：交易币基交易币基http://study.educhainx.com/newres/static/pdfjs/web/viewer.html?file=CXR_CND6FHD3EXP2EXF5DA 溯源的基础：Merkle树结构Merkle树结构http://study.educhainx.com/newres/static/pdfjs/web/viewer.html?file=B8ZGAYF9TPOE1CXEKL6_89 Merkle树与区块链Merkle树与区块链http://study.educhainx.com/newres/static/pdfjs/web/viewer.html?file=ZNGLK5CUQ-009TEQNUDZD9 区块链关键技术数据链上ID：哈希哈希http://study.educhainx.com/newres/static/pdfjs/web/viewer.html?file=FNFYC3X6FHJ3EHR9F3R_EW 链上数据的加密基础：公钥公钥http://study.educhainx.com/newres/static/pdfjs/web/viewer.html?file=FN99DXN0FHN1ENJ9FXN-CG 区块链时代下的账户钥匙：私钥私钥http://study.educhainx.com/newres/static/pdfjs/web/viewer.html?file=YC-BKMBTRJGCVWCGIY6591 数据加密：非对称加密非对称加密http://study.educhainx.com/newres/static/pdfjs/web/viewer.html?file=CNRYF39ZFHL1EHVZF3LXFW 数据归属：数字签名数字签名http://study.educhainx.com/newres/static/pdfjs/web/viewer.html?file=1ULR6AVAQHWILGCJSLKYDC 数据防篡改的手段：数字摘要数字摘要http://study.educhainx.com/newres/static/pdfjs/web/viewer.html?file=7JLZ62MDTYWRAN4MPMGY1E 安全技术：数字证书数字证书http://study.educhainx.com/newres/static/pdfjs/web/viewer.html?file=W0RZTWCETXWKAHHG7M0C39 链上通信：P2P传播机制P2P传播机制http://study.educhainx.com/newres/static/pdfjs/web/viewer.html?file=QQOWLWEHRX8DHNKLIX0BC1 交易先后顺序：时间戳时间戳http://study.educhainx.com/newres/static/pdfjs/web/viewer.html?file=A3WPWDKPSTOPZNXUBXEI15 实力挖矿：POW共识机制POW共识机制http://study.educhainx.com/newres/static/pdfjs/web/viewer.html?file=SCC4HRMDSLCNBD4PJGUP21 权益挖矿：POS共识机制POS共识机制http://study.educhainx.com/newres/static/pdfjs/web/viewer.html?file=F3T_FHZ5FH91FNJ3E4B4DQ 董事会体制：DPOS共识机制DPOS共识机制http://study.educhainx.com/newres/static/pdfjs/web/viewer.html?file=F357EH52FHL3F3Z4FXT5CW 少数服从多数：PBFT共识机制PBFT共识机制http://study.educhainx.com/newres/static/pdfjs/web/viewer.html?file=EWFN9RDRTJOWWL1S-YXVE3 区块链核心代表1.0代表：比特币概述与特性比特币概述与特性http://study.educhainx.com/newres/static/pdfjs/web/viewer.html?file=KZAQ3GAKTLSZDN-XN3KBAC 比特币与交易比特币与交易http://study.educhainx.com/newres/static/pdfjs/web/viewer.html?file=I5F8MCXLRZKEIKAHOGMN18 2.0代表：以太坊简介以太坊简介http://study.educhainx.com/newres/static/pdfjs/web/viewer.html?file=D55GTFFXRMOSZV2TMZY529 3.0代表：EOS简介EOS简介http://study.educhainx.com/newres/static/pdfjs/web/viewer.html?file=YKRGHFKOTPSS8SX7SENX47 典型联盟链：超级账本超级账本http://study.educhainx.com/newres/static/pdfjs/web/viewer.html?file=DCYEGSVIRVC7ZTH1OJPFBF 交易瓶颈的处理手段：DAGDAGhttp://study.educhainx.com/newres/static/pdfjs/web/viewer.html?file=7LJQXLWMQDKV03QZDPE3A3 技术风险隐患依旧：51%攻击51%攻击http://study.educhainx.com/newres/static/pdfjs/web/viewer.html?file=SEXW8R4ESUKND3JBRYSN7C 增加区块容量：扩容与隔离见证扩容与隔离见证http://study.educhainx.com/newres/static/pdfjs/web/viewer.html?file=LIJA1OODTS49GGME1KGSAB 提高交易效率：侧链与闪电网络侧链与闪电网络http://study.educhainx.com/newres/static/pdfjs/web/viewer.html?file=GIB9DXF1FHF2C3DYENF6CW","categories":[{"name":"区块链","slug":"区块链","permalink":"http://peapod.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://peapod.top/tags/%E7%AC%94%E8%AE%B0/"}],"author":"taweizhong"},{"title":"Hyperledger-Fabric 网络构建","slug":"Hyperledger-Fabric-网络构建","date":"2022-10-15T06:22:10.000Z","updated":"2022-10-19T09:24:50.000Z","comments":true,"path":"2022/10/15/Hyperledger-Fabric-网络构建/","link":"","permalink":"http://peapod.top/2022/10/15/Hyperledger-Fabric-%E7%BD%91%E7%BB%9C%E6%9E%84%E5%BB%BA/","excerpt":"","text":"网络构建生成组织结构和身份证书配置文件orderer路径：frist-network/organizations/cryptogen/crypto-config-orderer.yaml 1234567891011121314151617181920212223# Copyright IBM Corp. All Rights Reserved.## SPDX-License-Identifier: Apache-2.0## ---------------------------------------------------------------------------# &quot;OrdererOrgs&quot; - Definition of organizations managing orderer nodes# ---------------------------------------------------------------------------OrdererOrgs: # --------------------------------------------------------------------------- # Orderer # --------------------------------------------------------------------------- - Name: Orderer Domain: example.com EnableNodeOUs: true # --------------------------------------------------------------------------- # &quot;Specs&quot; - See PeerOrgs for complete description # --------------------------------------------------------------------------- Specs: - Hostname: orderer SANS: - localhost org1路径：frist-network/organizations/cryptogen/crypto-config-org1.yaml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# Copyright IBM Corp. All Rights Reserved.## SPDX-License-Identifier: Apache-2.0## ---------------------------------------------------------------------------# &quot;PeerOrgs&quot; - Definition of organizations managing peer nodes# ---------------------------------------------------------------------------PeerOrgs: # --------------------------------------------------------------------------- # Org1 # --------------------------------------------------------------------------- - Name: Org1 Domain: org1.example.com EnableNodeOUs: true # --------------------------------------------------------------------------- # &quot;Specs&quot; # --------------------------------------------------------------------------- # Uncomment this section to enable the explicit definition of hosts in your # configuration. Most users will want to use Template, below # # Specs is an array of Spec entries. Each Spec entry consists of two fields: # - Hostname: (Required) The desired hostname, sans the domain. # - CommonName: (Optional) Specifies the template or explicit override for # the CN. By default, this is the template: # # &quot;&#123;&#123;.Hostname&#125;&#125;.&#123;&#123;.Domain&#125;&#125;&quot; # # which obtains its values from the Spec.Hostname and # Org.Domain, respectively. # --------------------------------------------------------------------------- # - Hostname: foo # implicitly &quot;foo.org1.example.com&quot; # CommonName: foo27.org5.example.com # overrides Hostname-based FQDN set above # - Hostname: bar # - Hostname: baz # --------------------------------------------------------------------------- # &quot;Template&quot; # --------------------------------------------------------------------------- # Allows for the definition of 1 or more hosts that are created sequentially # from a template. By default, this looks like &quot;peer%d&quot; from 0 to Count-1. # You may override the number of nodes (Count), the starting index (Start) # or the template used to construct the name (Hostname). # # Note: Template and Specs are not mutually exclusive. You may define both # sections and the aggregate nodes will be created for you. Take care with # name collisions # --------------------------------------------------------------------------- Template: Count: 1 SANS: - localhost # Start: 5 # Hostname: &#123;&#123;.Prefix&#125;&#125;&#123;&#123;.Index&#125;&#125; # default # --------------------------------------------------------------------------- # &quot;Users&quot; # --------------------------------------------------------------------------- # Count: The number of user accounts _in addition_ to Admin # --------------------------------------------------------------------------- Users: Count: 1 org2路径：frist-network/organizations/cryptogen/crypto-config-org2.yaml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# Copyright IBM Corp. All Rights Reserved.## SPDX-License-Identifier: Apache-2.0## ---------------------------------------------------------------------------# &quot;PeerOrgs&quot; - Definition of organizations managing peer nodes# ---------------------------------------------------------------------------PeerOrgs: # --------------------------------------------------------------------------- # Org2 # --------------------------------------------------------------------------- - Name: Org2 Domain: org2.example.com EnableNodeOUs: true # --------------------------------------------------------------------------- # &quot;Specs&quot; # --------------------------------------------------------------------------- # Uncomment this section to enable the explicit definition of hosts in your # configuration. Most users will want to use Template, below # # Specs is an array of Spec entries. Each Spec entry consists of two fields: # - Hostname: (Required) The desired hostname, sans the domain. # - CommonName: (Optional) Specifies the template or explicit override for # the CN. By default, this is the template: # # &quot;&#123;&#123;.Hostname&#125;&#125;.&#123;&#123;.Domain&#125;&#125;&quot; # # which obtains its values from the Spec.Hostname and # Org.Domain, respectively. # --------------------------------------------------------------------------- # Specs: # - Hostname: foo # implicitly &quot;foo.org1.example.com&quot; # CommonName: foo27.org5.example.com # overrides Hostname-based FQDN set above # - Hostname: bar # - Hostname: baz # --------------------------------------------------------------------------- # &quot;Template&quot; # --------------------------------------------------------------------------- # Allows for the definition of 1 or more hosts that are created sequentially # from a template. By default, this looks like &quot;peer%d&quot; from 0 to Count-1. # You may override the number of nodes (Count), the starting index (Start) # or the template used to construct the name (Hostname). # # Note: Template and Specs are not mutually exclusive. You may define both # sections and the aggregate nodes will be created for you. Take care with # name collisions # --------------------------------------------------------------------------- Template: Count: 1 SANS: - localhost # Start: 5 # Hostname: &#123;&#123;.Prefix&#125;&#125;&#123;&#123;.Index&#125;&#125; # default # --------------------------------------------------------------------------- # &quot;Users&quot; # --------------------------------------------------------------------------- # Count: The number of user accounts _in addition_ to Admin # --------------------------------------------------------------------------- Users: Count: 1 生成1234cd /frist-network/organizations../../bin/cryptogen generate --congfig=./cryptogen/crypto-config-orderer.yaml../../bin/cryptogen generate --congfig=./cryptogen/crypto-config-org1.yaml../../bin/cryptogen generate --congfig=./cryptogen/crypto-config-org2.yaml 命令：generate 生成组织结构和身份证书信息。 参数：--congfig指定使用的配置模板文件，--output指定生成内容的输出目录。 在当前文件夹下生成两个子目录： ordererOrganizations peerOrganizations 初始区块和通道交易配置文件配置文件路径：frist-network/configtx/configtx.yaml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327# Copyright IBM Corp. All Rights Reserved.## SPDX-License-Identifier: Apache-2.0#---################################################################################## Section: Organizations## - This section defines the different organizational identities which will# be referenced later in the configuration.#################################################################################Organizations: # SampleOrg defines an MSP using the sampleconfig. It should never be used # in production but may be used as a template for other definitions - &amp;OrdererOrg # DefaultOrg defines the organization which is used in the sampleconfig # of the fabric.git development environment Name: OrdererOrg # ID to load the MSP definition as ID: OrdererMSP # MSPDir is the filesystem path which contains the MSP configuration MSPDir: ../organizations/ordererOrganizations/example.com/msp # Policies defines the set of policies at this level of the config tree # For organization policies, their canonical path is usually # /Channel/&lt;Application|Orderer&gt;/&lt;OrgName&gt;/&lt;PolicyName&gt; Policies: Readers: Type: Signature Rule: &quot;OR(&#x27;OrdererMSP.member&#x27;)&quot; Writers: Type: Signature Rule: &quot;OR(&#x27;OrdererMSP.member&#x27;)&quot; Admins: Type: Signature Rule: &quot;OR(&#x27;OrdererMSP.admin&#x27;)&quot; OrdererEndpoints: - orderer.example.com:7050 - &amp;Org1 # DefaultOrg defines the organization which is used in the sampleconfig # of the fabric.git development environment Name: Org1MSP # ID to load the MSP definition as ID: Org1MSP MSPDir: ../organizations/peerOrganizations/org1.example.com/msp # Policies defines the set of policies at this level of the config tree # For organization policies, their canonical path is usually # /Channel/&lt;Application|Orderer&gt;/&lt;OrgName&gt;/&lt;PolicyName&gt; Policies: Readers: Type: Signature Rule: &quot;OR(&#x27;Org1MSP.admin&#x27;, &#x27;Org1MSP.peer&#x27;, &#x27;Org1MSP.client&#x27;)&quot; Writers: Type: Signature Rule: &quot;OR(&#x27;Org1MSP.admin&#x27;, &#x27;Org1MSP.client&#x27;)&quot; Admins: Type: Signature Rule: &quot;OR(&#x27;Org1MSP.admin&#x27;)&quot; Endorsement: Type: Signature Rule: &quot;OR(&#x27;Org1MSP.peer&#x27;)&quot; - &amp;Org2 # DefaultOrg defines the organization which is used in the sampleconfig # of the fabric.git development environment Name: Org2MSP # ID to load the MSP definition as ID: Org2MSP MSPDir: ../organizations/peerOrganizations/org2.example.com/msp # Policies defines the set of policies at this level of the config tree # For organization policies, their canonical path is usually # /Channel/&lt;Application|Orderer&gt;/&lt;OrgName&gt;/&lt;PolicyName&gt; Policies: Readers: Type: Signature Rule: &quot;OR(&#x27;Org2MSP.admin&#x27;, &#x27;Org2MSP.peer&#x27;, &#x27;Org2MSP.client&#x27;)&quot; Writers: Type: Signature Rule: &quot;OR(&#x27;Org2MSP.admin&#x27;, &#x27;Org2MSP.client&#x27;)&quot; Admins: Type: Signature Rule: &quot;OR(&#x27;Org2MSP.admin&#x27;)&quot; Endorsement: Type: Signature Rule: &quot;OR(&#x27;Org2MSP.peer&#x27;)&quot;################################################################################## SECTION: Capabilities## - This section defines the capabilities of fabric network. This is a new# concept as of v1.1.0 and should not be utilized in mixed networks with# v1.0.x peers and orderers. Capabilities define features which must be# present in a fabric binary for that binary to safely participate in the# fabric network. For instance, if a new MSP type is added, newer binaries# might recognize and validate the signatures from this type, while older# binaries without this support would be unable to validate those# transactions. This could lead to different versions of the fabric binaries# having different world states. Instead, defining a capability for a channel# informs those binaries without this capability that they must cease# processing transactions until they have been upgraded. For v1.0.x if any# capabilities are defined (including a map with all capabilities turned off)# then the v1.0.x peer will deliberately crash.#################################################################################Capabilities: # Channel capabilities apply to both the orderers and the peers and must be # supported by both. # Set the value of the capability to true to require it. Channel: &amp;ChannelCapabilities # V2_0 capability ensures that orderers and peers behave according # to v2.0 channel capabilities. Orderers and peers from # prior releases would behave in an incompatible way, and are therefore # not able to participate in channels at v2.0 capability. # Prior to enabling V2.0 channel capabilities, ensure that all # orderers and peers on a channel are at v2.0.0 or later. V2_0: true # Orderer capabilities apply only to the orderers, and may be safely # used with prior release peers. # Set the value of the capability to true to require it. Orderer: &amp;OrdererCapabilities # V2_0 orderer capability ensures that orderers behave according # to v2.0 orderer capabilities. Orderers from # prior releases would behave in an incompatible way, and are therefore # not able to participate in channels at v2.0 orderer capability. # Prior to enabling V2.0 orderer capabilities, ensure that all # orderers on channel are at v2.0.0 or later. V2_0: true # Application capabilities apply only to the peer network, and may be safely # used with prior release orderers. # Set the value of the capability to true to require it. Application: &amp;ApplicationCapabilities # V2_0 application capability ensures that peers behave according # to v2.0 application capabilities. Peers from # prior releases would behave in an incompatible way, and are therefore # not able to participate in channels at v2.0 application capability. # Prior to enabling V2.0 application capabilities, ensure that all # peers on channel are at v2.0.0 or later. V2_0: true################################################################################## SECTION: Application## - This section defines the values to encode into a config transaction or# genesis block for application related parameters#################################################################################Application: &amp;ApplicationDefaults # Organizations is the list of orgs which are defined as participants on # the application side of the network Organizations: # Policies defines the set of policies at this level of the config tree # For Application policies, their canonical path is # /Channel/Application/&lt;PolicyName&gt; Policies: Readers: Type: ImplicitMeta Rule: &quot;ANY Readers&quot; Writers: Type: ImplicitMeta Rule: &quot;ANY Writers&quot; Admins: Type: ImplicitMeta Rule: &quot;MAJORITY Admins&quot; LifecycleEndorsement: Type: ImplicitMeta Rule: &quot;MAJORITY Endorsement&quot; Endorsement: Type: ImplicitMeta Rule: &quot;MAJORITY Endorsement&quot; Capabilities: &lt;&lt;: *ApplicationCapabilities################################################################################## SECTION: Orderer## - This section defines the values to encode into a config transaction or# genesis block for orderer related parameters#################################################################################Orderer: &amp;OrdererDefaults # Orderer Type: The orderer implementation to start OrdererType: etcdraft # Addresses used to be the list of orderer addresses that clients and peers # could connect to. However, this does not allow clients to associate orderer # addresses and orderer organizations which can be useful for things such # as TLS validation. The preferred way to specify orderer addresses is now # to include the OrdererEndpoints item in your org definition Addresses: - orderer.example.com:7050 EtcdRaft: Consenters: - Host: orderer.example.com Port: 7050 ClientTLSCert: ../organizations/ordererOrganizations/example.com/orderers/orderer.example.com/tls/server.crt ServerTLSCert: ../organizations/ordererOrganizations/example.com/orderers/orderer.example.com/tls/server.crt # Batch Timeout: The amount of time to wait before creating a batch BatchTimeout: 2s # Batch Size: Controls the number of messages batched into a block BatchSize: # Max Message Count: The maximum number of messages to permit in a batch MaxMessageCount: 10 # Absolute Max Bytes: The absolute maximum number of bytes allowed for # the serialized messages in a batch. AbsoluteMaxBytes: 99 MB # Preferred Max Bytes: The preferred maximum number of bytes allowed for # the serialized messages in a batch. A message larger than the preferred # max bytes will result in a batch larger than preferred max bytes. PreferredMaxBytes: 512 KB # Organizations is the list of orgs which are defined as participants on # the orderer side of the network Organizations: # Policies defines the set of policies at this level of the config tree # For Orderer policies, their canonical path is # /Channel/Orderer/&lt;PolicyName&gt; Policies: Readers: Type: ImplicitMeta Rule: &quot;ANY Readers&quot; Writers: Type: ImplicitMeta Rule: &quot;ANY Writers&quot; Admins: Type: ImplicitMeta Rule: &quot;MAJORITY Admins&quot; # BlockValidation specifies what signatures must be included in the block # from the orderer for the peer to validate it. BlockValidation: Type: ImplicitMeta Rule: &quot;ANY Writers&quot;################################################################################## CHANNEL## This section defines the values to encode into a config transaction or# genesis block for channel related parameters.#################################################################################Channel: &amp;ChannelDefaults # Policies defines the set of policies at this level of the config tree # For Channel policies, their canonical path is # /Channel/&lt;PolicyName&gt; Policies: # Who may invoke the &#x27;Deliver&#x27; API Readers: Type: ImplicitMeta Rule: &quot;ANY Readers&quot; # Who may invoke the &#x27;Broadcast&#x27; API Writers: Type: ImplicitMeta Rule: &quot;ANY Writers&quot; # By default, who may modify elements at this config level Admins: Type: ImplicitMeta Rule: &quot;MAJORITY Admins&quot; # Capabilities describes the channel level capabilities, see the # dedicated Capabilities section elsewhere in this file for a full # description Capabilities: &lt;&lt;: *ChannelCapabilities################################################################################## Profile## - Different configuration profiles may be encoded here to be specified# as parameters to the configtxgen tool#################################################################################Profiles: TwoOrgsOrdererGenesis: &lt;&lt;: *ChannelDefaults Orderer: &lt;&lt;: *OrdererDefaults Organizations: - *OrdererOrg Capabilities: &lt;&lt;: *OrdererCapabilities Consortiums: SampleConsortium: Organizations: - *Org1 - *Org2 TwoOrgsChannel: Consortium: SampleConsortium &lt;&lt;: *ChannelDefaults Application: &lt;&lt;: *ApplicationDefaults Organizations: - *Org1 - *Org2 Capabilities: &lt;&lt;: *ApplicationCapabilities 初始区块的创建12cd /frist-network/configtx../../bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ../system-genesis-block/genesis.block 应用通道交易配置文件创建1../../bin/configtxgen -profile TwoOrgsChannel -outpotCreateChannelTx ../channel-artifacts/mychannel.tx 启动网络配置文件路径：frist-network/docker/docker-compose-test-net.yaml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149# Copyright IBM Corp. All Rights Reserved.## SPDX-License-Identifier: Apache-2.0#version: &#x27;2&#x27;volumes: orderer.example.com: peer0.org1.example.com: peer0.org2.example.com:networks: test: name: fabric_testservices: orderer.example.com: container_name: orderer.example.com image: hyperledger/fabric-orderer:latest environment: - FABRIC_LOGGING_SPEC=INFO - ORDERER_GENERAL_LISTENADDRESS=0.0.0.0 - ORDERER_GENERAL_LISTENPORT=7050 - ORDERER_GENERAL_GENESISMETHOD=file - ORDERER_GENERAL_GENESISFILE=/var/hyperledger/orderer/orderer.genesis.block - ORDERER_GENERAL_LOCALMSPID=OrdererMSP - ORDERER_GENERAL_LOCALMSPDIR=/var/hyperledger/orderer/msp - ORDERER_OPERATIONS_LISTENADDRESS=0.0.0.0:17050 # enabled TLS - ORDERER_GENERAL_TLS_ENABLED=true - ORDERER_GENERAL_TLS_PRIVATEKEY=/var/hyperledger/orderer/tls/server.key - ORDERER_GENERAL_TLS_CERTIFICATE=/var/hyperledger/orderer/tls/server.crt - ORDERER_GENERAL_TLS_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt] - ORDERER_KAFKA_TOPIC_REPLICATIONFACTOR=1 - ORDERER_KAFKA_VERBOSE=true - ORDERER_GENERAL_CLUSTER_CLIENTCERTIFICATE=/var/hyperledger/orderer/tls/server.crt - ORDERER_GENERAL_CLUSTER_CLIENTPRIVATEKEY=/var/hyperledger/orderer/tls/server.key - ORDERER_GENERAL_CLUSTER_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt] working_dir: /opt/gopath/src/github.com/hyperledger/fabric command: orderer volumes: - ../system-genesis-block/genesis.block:/var/hyperledger/orderer/orderer.genesis.block - ../organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp:/var/hyperledger/orderer/msp - ../organizations/ordererOrganizations/example.com/orderers/orderer.example.com/tls/:/var/hyperledger/orderer/tls - orderer.example.com:/var/hyperledger/production/orderer ports: - 7050:7050 - 17050:17050 networks: - test peer0.org1.example.com: container_name: peer0.org1.example.com image: hyperledger/fabric-peer:latest environment: #Generic peer variables - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=fabric_test - FABRIC_LOGGING_SPEC=INFO #- FABRIC_LOGGING_SPEC=DEBUG - CORE_PEER_TLS_ENABLED=true - CORE_PEER_PROFILE_ENABLED=true - CORE_PEER_TLS_CERT_FILE=/etc/hyperledger/fabric/tls/server.crt - CORE_PEER_TLS_KEY_FILE=/etc/hyperledger/fabric/tls/server.key - CORE_PEER_TLS_ROOTCERT_FILE=/etc/hyperledger/fabric/tls/ca.crt # Peer specific variabes - CORE_PEER_ID=peer0.org1.example.com - CORE_PEER_ADDRESS=peer0.org1.example.com:7051 - CORE_PEER_LISTENADDRESS=0.0.0.0:7051 - CORE_PEER_CHAINCODEADDRESS=peer0.org1.example.com:7052 - CORE_PEER_CHAINCODELISTENADDRESS=0.0.0.0:7052 - CORE_PEER_GOSSIP_BOOTSTRAP=peer0.org1.example.com:7051 - CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer0.org1.example.com:7051 - CORE_PEER_LOCALMSPID=Org1MSP - CORE_OPERATIONS_LISTENADDRESS=0.0.0.0:17051 volumes: - /var/run/docker.sock:/host/var/run/docker.sock - ../organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/msp:/etc/hyperledger/fabric/msp - ../organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls:/etc/hyperledger/fabric/tls - peer0.org1.example.com:/var/hyperledger/production working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer command: peer node start ports: - 7051:7051 - 17051:17051 networks: - test peer0.org2.example.com: container_name: peer0.org2.example.com image: hyperledger/fabric-peer:latest environment: #Generic peer variables - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=fabric_test - FABRIC_LOGGING_SPEC=INFO #- FABRIC_LOGGING_SPEC=DEBUG - CORE_PEER_TLS_ENABLED=true - CORE_PEER_PROFILE_ENABLED=true - CORE_PEER_TLS_CERT_FILE=/etc/hyperledger/fabric/tls/server.crt - CORE_PEER_TLS_KEY_FILE=/etc/hyperledger/fabric/tls/server.key - CORE_PEER_TLS_ROOTCERT_FILE=/etc/hyperledger/fabric/tls/ca.crt # Peer specific variabes - CORE_PEER_ID=peer0.org2.example.com - CORE_PEER_ADDRESS=peer0.org2.example.com:9051 - CORE_PEER_LISTENADDRESS=0.0.0.0:9051 - CORE_PEER_CHAINCODEADDRESS=peer0.org2.example.com:9052 - CORE_PEER_CHAINCODELISTENADDRESS=0.0.0.0:9052 - CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer0.org2.example.com:9051 - CORE_PEER_GOSSIP_BOOTSTRAP=peer0.org2.example.com:9051 - CORE_PEER_LOCALMSPID=Org2MSP - CORE_OPERATIONS_LISTENADDRESS=0.0.0.0:19051 volumes: - /var/run/docker.sock:/host/var/run/docker.sock - ../organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/msp:/etc/hyperledger/fabric/msp - ../organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls:/etc/hyperledger/fabric/tls - peer0.org2.example.com:/var/hyperledger/production working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer command: peer node start ports: - 9051:9051 - 19051:19051 networks: - test cli: container_name: cli image: hyperledger/fabric-tools:latest tty: true stdin_open: true environment: - GOPATH=/opt/gopath - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock - FABRIC_LOGGING_SPEC=INFO #- FABRIC_LOGGING_SPEC=DEBUG working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer command: /bin/bash volumes: - /var/run/:/host/var/run/ - ../organizations:/opt/gopath/src/github.com/hyperledger/fabric/peer/organizations - ../scripts:/opt/gopath/src/github.com/hyperledger/fabric/peer/scripts/ depends_on: - peer0.org1.example.com - peer0.org2.example.com networks: - test 启动1docker-compose -f docker-compose-test-net.yaml up -d 创建通道进入CLI容器1docker exec -it cli bash 创建1peer channel create -o orderer.example.com:7075 -c mychannel -f ./channel-artifacts/mychannel.tx --tls --cafile ./organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem 节点加入通道1peer channel join -b mychannel.block","categories":[{"name":"区块链","slug":"区块链","permalink":"http://peapod.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"Hyperledger Fabric进阶","slug":"Hyperledger-Fabric进阶","permalink":"http://peapod.top/tags/Hyperledger-Fabric%E8%BF%9B%E9%98%B6/"}],"author":"taweizhong"},{"title":"Hyperledger-Fabric 核心配置文件","slug":"Hyperledger-Fabric-核心配置文件","date":"2022-10-15T06:21:21.000Z","updated":"2022-10-15T07:01:04.000Z","comments":true,"path":"2022/10/15/Hyperledger-Fabric-核心配置文件/","link":"","permalink":"http://peapod.top/2022/10/15/Hyperledger-Fabric-%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","excerpt":"","text":"核心配置文件core.yaml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738# Copyright IBM Corp. All Rights Reserved.## SPDX-License-Identifier: Apache-2.0################################################################################## Peer section# 节点部分###############################################################################peer: # The peer id provides a name for this peer instance and is used when # naming docker resources. # 指定节点ID id: jdoe # The networkId allows for logical separation of networks and is used when # naming docker resources. # 指定网络ID networkId: dev # The Address at local network interface this Peer will listen on. # By default, it will listen on all network interfaces listenAddress: 0.0.0.0:7051 # The endpoint this peer uses to listen for inbound chaincode connections. # If this is commented-out, the listen address is selected to be # the peer&#x27;s address (see below) with port 7052 # chaincodeListenAddress: 0.0.0.0:7052 # The endpoint the chaincode for this peer uses to connect to the peer. # If this is not specified, the chaincodeListenAddress address is selected. # And if chaincodeListenAddress is not specified, address is selected from # peer address (see below). If specified peer address is invalid then it # will fallback to the auto detected IP (local IP) regardless of the peer # addressAutoDetect value. # chaincodeAddress: 0.0.0.0:7052 # When used as peer config, this represents the endpoint to other peers # in the same organization. For peers in other organization, see # gossip.externalEndpoint for more info. # When used as CLI config, this means the peer&#x27;s endpoint to interact with address: 0.0.0.0:7051 # Whether the Peer should programmatically determine its address # This case is useful for docker containers. # When set to true, will override peer address. addressAutoDetect: false # Keepalive settings for peer server and clients keepalive: # Interval is the duration after which if the server does not see # any activity from the client it pings the client to see if it&#x27;s alive interval: 7200s # Timeout is the duration the server waits for a response # from the client after sending a ping before closing the connection timeout: 20s # MinInterval is the minimum permitted time between client pings. # If clients send pings more frequently, the peer server will # disconnect them minInterval: 60s # Client keepalive settings for communicating with other peer nodes client: # Interval is the time between pings to peer nodes. This must # greater than or equal to the minInterval specified by peer # nodes interval: 60s # Timeout is the duration the client waits for a response from # peer nodes before closing the connection timeout: 20s # DeliveryClient keepalive settings for communication with ordering # nodes. deliveryClient: # Interval is the time between pings to ordering nodes. This must # greater than or equal to the minInterval specified by ordering # nodes. interval: 60s # Timeout is the duration the client waits for a response from # ordering nodes before closing the connection timeout: 20s # Gossip related configuration gossip: # Bootstrap set to initialize gossip with. # This is a list of other peers that this peer reaches out to at startup. # Important: The endpoints here have to be endpoints of peers in the same # organization, because the peer would refuse connecting to these endpoints # unless they are in the same organization as the peer. bootstrap: 127.0.0.1:7051 # NOTE: orgLeader and useLeaderElection parameters are mutual exclusive. # Setting both to true would result in the termination of the peer # since this is undefined state. If the peers are configured with # useLeaderElection=false, make sure there is at least 1 peer in the # organization that its orgLeader is set to true. # Defines whenever peer will initialize dynamic algorithm for # &quot;leader&quot; selection, where leader is the peer to establish # connection with ordering service and use delivery protocol # to pull ledger blocks from ordering service. useLeaderElection: false # Statically defines peer to be an organization &quot;leader&quot;, # where this means that current peer will maintain connection # with ordering service and disseminate block across peers in # its own organization. Multiple peers or all peers in an organization # may be configured as org leaders, so that they all pull # blocks directly from ordering service. orgLeader: true # Interval for membershipTracker polling membershipTrackerInterval: 5s # Overrides the endpoint that the peer publishes to peers # in its organization. For peers in foreign organizations # see &#x27;externalEndpoint&#x27; endpoint: # Maximum count of blocks stored in memory maxBlockCountToStore: 10 # Max time between consecutive message pushes(unit: millisecond) maxPropagationBurstLatency: 10ms # Max number of messages stored until a push is triggered to remote peers maxPropagationBurstSize: 10 # Number of times a message is pushed to remote peers propagateIterations: 1 # Number of peers selected to push messages to propagatePeerNum: 3 # Determines frequency of pull phases(unit: second) # Must be greater than digestWaitTime + responseWaitTime pullInterval: 4s # Number of peers to pull from pullPeerNum: 3 # Determines frequency of pulling state info messages from peers(unit: second) requestStateInfoInterval: 4s # Determines frequency of pushing state info messages to peers(unit: second) publishStateInfoInterval: 4s # Maximum time a stateInfo message is kept until expired stateInfoRetentionInterval: # Time from startup certificates are included in Alive messages(unit: second) publishCertPeriod: 10s # Should we skip verifying block messages or not (currently not in use) skipBlockVerification: false # Dial timeout(unit: second) dialTimeout: 3s # Connection timeout(unit: second) connTimeout: 2s # Buffer size of received messages recvBuffSize: 20 # Buffer size of sending messages sendBuffSize: 200 # Time to wait before pull engine processes incoming digests (unit: second) # Should be slightly smaller than requestWaitTime digestWaitTime: 1s # Time to wait before pull engine removes incoming nonce (unit: milliseconds) # Should be slightly bigger than digestWaitTime requestWaitTime: 1500ms # Time to wait before pull engine ends pull (unit: second) responseWaitTime: 2s # Alive check interval(unit: second) aliveTimeInterval: 5s # Alive expiration timeout(unit: second) aliveExpirationTimeout: 25s # Reconnect interval(unit: second) reconnectInterval: 25s # Max number of attempts to connect to a peer maxConnectionAttempts: 120 # Message expiration factor for alive messages msgExpirationFactor: 20 # This is an endpoint that is published to peers outside of the organization. # If this isn&#x27;t set, the peer will not be known to other organizations. externalEndpoint: # Leader election service configuration election: # Longest time peer waits for stable membership during leader election startup (unit: second) startupGracePeriod: 15s # Interval gossip membership samples to check its stability (unit: second) membershipSampleInterval: 1s # Time passes since last declaration message before peer decides to perform leader election (unit: second) leaderAliveThreshold: 10s # Time between peer sends propose message and declares itself as a leader (sends declaration message) (unit: second) leaderElectionDuration: 5s pvtData: # pullRetryThreshold determines the maximum duration of time private data corresponding for a given block # would be attempted to be pulled from peers until the block would be committed without the private data pullRetryThreshold: 60s # As private data enters the transient store, it is associated with the peer&#x27;s ledger&#x27;s height at that time. # transientstoreMaxBlockRetention defines the maximum difference between the current ledger&#x27;s height upon commit, # and the private data residing inside the transient store that is guaranteed not to be purged. # Private data is purged from the transient store when blocks with sequences that are multiples # of transientstoreMaxBlockRetention are committed. transientstoreMaxBlockRetention: 1000 # pushAckTimeout is the maximum time to wait for an acknowledgement from each peer # at private data push at endorsement time. pushAckTimeout: 3s # Block to live pulling margin, used as a buffer # to prevent peer from trying to pull private data # from peers that is soon to be purged in next N blocks. # This helps a newly joined peer catch up to current # blockchain height quicker. btlPullMargin: 10 # the process of reconciliation is done in an endless loop, while in each iteration reconciler tries to # pull from the other peers the most recent missing blocks with a maximum batch size limitation. # reconcileBatchSize determines the maximum batch size of missing private data that will be reconciled in a # single iteration. reconcileBatchSize: 10 # reconcileSleepInterval determines the time reconciler sleeps from end of an iteration until the beginning # of the next reconciliation iteration. reconcileSleepInterval: 1m # reconciliationEnabled is a flag that indicates whether private data reconciliation is enable or not. reconciliationEnabled: true # skipPullingInvalidTransactionsDuringCommit is a flag that indicates whether pulling of invalid # transaction&#x27;s private data from other peers need to be skipped during the commit time and pulled # only through reconciler. skipPullingInvalidTransactionsDuringCommit: false # implicitCollectionDisseminationPolicy specifies the dissemination policy for the peer&#x27;s own implicit collection. # When a peer endorses a proposal that writes to its own implicit collection, below values override the default values # for disseminating private data. # Note that it is applicable to all channels the peer has joined. The implication is that requiredPeerCount has to # be smaller than the number of peers in a channel that has the lowest numbers of peers from the organization. implicitCollectionDisseminationPolicy: # requiredPeerCount defines the minimum number of eligible peers to which the peer must successfully # disseminate private data for its own implicit collection during endorsement. Default value is 0. requiredPeerCount: 0 # maxPeerCount defines the maximum number of eligible peers to which the peer will attempt to # disseminate private data for its own implicit collection during endorsement. Default value is 1. maxPeerCount: 1 # Gossip state transfer related configuration state: # indicates whenever state transfer is enabled or not # default value is true, i.e. state transfer is active # and takes care to sync up missing blocks allowing # lagging peer to catch up to speed with rest network enabled: false # checkInterval interval to check whether peer is lagging behind enough to # request blocks via state transfer from another peer. checkInterval: 10s # responseTimeout amount of time to wait for state transfer response from # other peers responseTimeout: 3s # batchSize the number of blocks to request via state transfer from another peer batchSize: 10 # blockBufferSize reflects the size of the re-ordering buffer # which captures blocks and takes care to deliver them in order # down to the ledger layer. The actual buffer size is bounded between # 0 and 2*blockBufferSize, each channel maintains its own buffer blockBufferSize: 20 # maxRetries maximum number of re-tries to ask # for single state transfer request maxRetries: 3 # TLS Settings tls: # Require server-side TLS enabled: false # Require client certificates / mutual TLS. # Note that clients that are not configured to use a certificate will # fail to connect to the peer. clientAuthRequired: false # X.509 certificate used for TLS server cert: file: tls/server.crt # Private key used for TLS server (and client if clientAuthEnabled # is set to true key: file: tls/server.key # Trusted root certificate chain for tls.cert rootcert: file: tls/ca.crt # Set of root certificate authorities used to verify client certificates clientRootCAs: files: - tls/ca.crt # Private key used for TLS when making client connections. If # not set, peer.tls.key.file will be used instead clientKey: file: # X.509 certificate used for TLS when making client connections. # If not set, peer.tls.cert.file will be used instead clientCert: file: # Authentication contains configuration parameters related to authenticating # client messages authentication: # the acceptable difference between the current server time and the # client&#x27;s time as specified in a client request message timewindow: 15m # Path on the file system where peer will store data (eg ledger). This # location must be access control protected to prevent unintended # modification that might corrupt the peer operations. fileSystemPath: /var/hyperledger/production # BCCSP (Blockchain crypto provider): Select which crypto implementation or # library to use BCCSP: Default: SW # Settings for the SW crypto provider (i.e. when DEFAULT: SW) SW: # TODO: The default Hash and Security level needs refactoring to be # fully configurable. Changing these defaults requires coordination # SHA2 is hardcoded in several places, not only BCCSP Hash: SHA2 Security: 256 # Location of Key Store FileKeyStore: # If &quot;&quot;, defaults to &#x27;mspConfigPath&#x27;/keystore KeyStore: # Settings for the PKCS#11 crypto provider (i.e. when DEFAULT: PKCS11) PKCS11: # Location of the PKCS11 module library Library: # Token Label Label: # User PIN Pin: Hash: Security: # Path on the file system where peer will find MSP local configurations mspConfigPath: msp # Identifier of the local MSP # ----!!!!IMPORTANT!!!-!!!IMPORTANT!!!-!!!IMPORTANT!!!!---- # Deployers need to change the value of the localMspId string. # In particular, the name of the local MSP ID of a peer needs # to match the name of one of the MSPs in each of the channel # that this peer is a member of. Otherwise this peer&#x27;s messages # will not be identified as valid by other nodes. localMspId: SampleOrg # CLI common client config options client: # connection timeout connTimeout: 3s # Delivery service related config deliveryclient: # It sets the total time the delivery service may spend in reconnection # attempts until its retry logic gives up and returns an error reconnectTotalTimeThreshold: 3600s # It sets the delivery service &lt;-&gt; ordering service node connection timeout connTimeout: 3s # It sets the delivery service maximal delay between consecutive retries reConnectBackoffThreshold: 3600s # A list of orderer endpoint addresses which should be overridden # when found in channel configurations. addressOverrides: # - from: # to: # caCertsFile: # - from: # to: # caCertsFile: # Type for the local MSP - by default it&#x27;s of type bccsp localMspType: bccsp # Used with Go profiling tools only in none production environment. In # production, it should be disabled (eg enabled: false) profile: enabled: false listenAddress: 0.0.0.0:6060 # Handlers defines custom handlers that can filter and mutate # objects passing within the peer, such as: # Auth filter - reject or forward proposals from clients # Decorators - append or mutate the chaincode input passed to the chaincode # Endorsers - Custom signing over proposal response payload and its mutation # Valid handler definition contains: # - A name which is a factory method name defined in # core/handlers/library/library.go for statically compiled handlers # - library path to shared object binary for pluggable filters # Auth filters and decorators are chained and executed in the order that # they are defined. For example: # authFilters: # - # name: FilterOne # library: /opt/lib/filter.so # - # name: FilterTwo # decorators: # - # name: DecoratorOne # - # name: DecoratorTwo # library: /opt/lib/decorator.so # Endorsers are configured as a map that its keys are the endorsement system chaincodes that are being overridden. # Below is an example that overrides the default ESCC and uses an endorsement plugin that has the same functionality # as the default ESCC. # If the &#x27;library&#x27; property is missing, the name is used as the constructor method in the builtin library similar # to auth filters and decorators. # endorsers: # escc: # name: DefaultESCC # library: /etc/hyperledger/fabric/plugin/escc.so handlers: authFilters: - name: DefaultAuth - name: ExpirationCheck # This filter checks identity x509 certificate expiration decorators: - name: DefaultDecorator endorsers: escc: name: DefaultEndorsement library: validators: vscc: name: DefaultValidation library: # library: /etc/hyperledger/fabric/plugin/escc.so # Number of goroutines that will execute transaction validation in parallel. # By default, the peer chooses the number of CPUs on the machine. Set this # variable to override that choice. # NOTE: overriding this value might negatively influence the performance of # the peer so please change this value only if you know what you&#x27;re doing validatorPoolSize: # The discovery service is used by clients to query information about peers, # such as - which peers have joined a certain channel, what is the latest # channel config, and most importantly - given a chaincode and a channel, # what possible sets of peers satisfy the endorsement policy. discovery: enabled: true # Whether the authentication cache is enabled or not. authCacheEnabled: true # The maximum size of the cache, after which a purge takes place authCacheMaxSize: 1000 # The proportion (0 to 1) of entries that remain in the cache after the cache is purged due to overpopulation authCachePurgeRetentionRatio: 0.75 # Whether to allow non-admins to perform non channel scoped queries. # When this is false, it means that only peer admins can perform non channel scoped queries. orgMembersAllowedAccess: false # Limits is used to configure some internal resource limits. limits: # Concurrency limits the number of concurrently running requests to a service on each peer. # Currently this option is only applied to endorser service and deliver service. # When the property is missing or the value is 0, the concurrency limit is disabled for the service. concurrency: # endorserService limits concurrent requests to endorser service that handles chaincode deployment, query and invocation, # including both user chaincodes and system chaincodes. endorserService: 2500 # deliverService limits concurrent event listeners registered to deliver service for blocks and transaction events. deliverService: 2500################################################################################# VM section################################################################################vm: # Endpoint of the vm management system. For docker can be one of the following in general # unix:///var/run/docker.sock # http://localhost:2375 # https://localhost:2376 endpoint: unix:///var/run/docker.sock # settings for docker vms docker: tls: enabled: false ca: file: docker/ca.crt cert: file: docker/tls.crt key: file: docker/tls.key # Enables/disables the standard out/err from chaincode containers for # debugging purposes attachStdout: false # Parameters on creating docker container. # Container may be efficiently created using ipam &amp; dns-server for cluster # NetworkMode - sets the networking mode for the container. Supported # standard values are: `host`(default),`bridge`,`ipvlan`,`none`. # Dns - a list of DNS servers for the container to use. # Note: `Privileged` `Binds` `Links` and `PortBindings` properties of # Docker Host Config are not supported and will not be used if set. # LogConfig - sets the logging driver (Type) and related options # (Config) for Docker. For more info, # https://docs.docker.com/engine/admin/logging/overview/ # Note: Set LogConfig using Environment Variables is not supported. hostConfig: NetworkMode: host Dns: # - 192.168.0.1 LogConfig: Type: json-file Config: max-size: &quot;50m&quot; max-file: &quot;5&quot; Memory: 2147483648################################################################################# Chaincode section################################################################################chaincode: # The id is used by the Chaincode stub to register the executing Chaincode # ID with the Peer and is generally supplied through ENV variables # the `path` form of ID is provided when installing the chaincode. # The `name` is used for all other requests and can be any string. id: path: name: # Generic builder environment, suitable for most chaincode types builder: $(DOCKER_NS)/fabric-ccenv:$(TWO_DIGIT_VERSION) # Enables/disables force pulling of the base docker images (listed below) # during user chaincode instantiation. # Useful when using moving image tags (such as :latest) pull: false golang: # golang will never need more than baseos runtime: $(DOCKER_NS)/fabric-baseos:$(TWO_DIGIT_VERSION) # whether or not golang chaincode should be linked dynamically dynamicLink: false java: # This is an image based on java:openjdk-8 with addition compiler # tools added for java shim layer packaging. # This image is packed with shim layer libraries that are necessary # for Java chaincode runtime. runtime: $(DOCKER_NS)/fabric-javaenv:$(TWO_DIGIT_VERSION) node: # This is an image based on node:$(NODE_VER)-alpine runtime: $(DOCKER_NS)/fabric-nodeenv:$(TWO_DIGIT_VERSION) # List of directories to treat as external builders and launchers for # chaincode. The external builder detection processing will iterate over the # builders in the order specified below. externalBuilders: [] # - path: /path/to/directory # name: descriptive-builder-name # propagateEnvironment: # - ENVVAR_NAME_TO_PROPAGATE_FROM_PEER # - GOPROXY # The maximum duration to wait for the chaincode build and install process # to complete. installTimeout: 300s # Timeout duration for starting up a container and waiting for Register # to come through. startuptimeout: 300s # Timeout duration for Invoke and Init calls to prevent runaway. # This timeout is used by all chaincodes in all the channels, including # system chaincodes. # Note that during Invoke, if the image is not available (e.g. being # cleaned up when in development environment), the peer will automatically # build the image, which might take more time. In production environment, # the chaincode image is unlikely to be deleted, so the timeout could be # reduced accordingly. executetimeout: 30s # There are 2 modes: &quot;dev&quot; and &quot;net&quot;. # In dev mode, user runs the chaincode after starting peer from # command line on local machine. # In net mode, peer will run chaincode in a docker container. mode: net # keepalive in seconds. In situations where the communication goes through a # proxy that does not support keep-alive, this parameter will maintain connection # between peer and chaincode. # A value &lt;= 0 turns keepalive off keepalive: 0 # enabled system chaincodes system: _lifecycle: enable cscc: enable lscc: enable escc: enable vscc: enable qscc: enable # Logging section for the chaincode container logging: # Default level for all loggers within the chaincode container level: info # Override default level for the &#x27;shim&#x27; logger shim: warning # Format for the chaincode container logs format: &#x27;%&#123;color&#125;%&#123;time:2006-01-02 15:04:05.000 MST&#125; [%&#123;module&#125;] %&#123;shortfunc&#125; -&gt; %&#123;level:.4s&#125; %&#123;id:03x&#125;%&#123;color:reset&#125; %&#123;message&#125;&#x27;################################################################################# Ledger section - ledger configuration encompasses both the blockchain# and the state################################################################################ledger: blockchain: state: # stateDatabase - options are &quot;goleveldb&quot;, &quot;CouchDB&quot; # goleveldb - default state database stored in goleveldb. # CouchDB - store state database in CouchDB stateDatabase: goleveldb # Limit on the number of records to return per query totalQueryLimit: 100000 couchDBConfig: # It is recommended to run CouchDB on the same server as the peer, and # not map the CouchDB container port to a server port in docker-compose. # Otherwise proper security must be provided on the connection between # CouchDB client (on the peer) and server. couchDBAddress: 127.0.0.1:5984 # This username must have read and write authority on CouchDB username: # The password is recommended to pass as an environment variable # during start up (eg CORE_LEDGER_STATE_COUCHDBCONFIG_PASSWORD). # If it is stored here, the file must be access control protected # to prevent unintended users from discovering the password. password: # Number of retries for CouchDB errors maxRetries: 3 # Number of retries for CouchDB errors during peer startup. # The delay between retries doubles for each attempt. # Default of 10 retries results in 11 attempts over 2 minutes. maxRetriesOnStartup: 10 # CouchDB request timeout (unit: duration, e.g. 20s) requestTimeout: 35s # Limit on the number of records per each CouchDB query # Note that chaincode queries are only bound by totalQueryLimit. # Internally the chaincode may execute multiple CouchDB queries, # each of size internalQueryLimit. internalQueryLimit: 1000 # Limit on the number of records per CouchDB bulk update batch maxBatchUpdateSize: 1000 # Warm indexes after every N blocks. # This option warms any indexes that have been # deployed to CouchDB after every N blocks. # A value of 1 will warm indexes after every block commit, # to ensure fast selector queries. # Increasing the value may improve write efficiency of peer and CouchDB, # but may degrade query response time. warmIndexesAfterNBlocks: 1 # Create the _global_changes system database # This is optional. Creating the global changes database will require # additional system resources to track changes and maintain the database createGlobalChangesDB: false # CacheSize denotes the maximum mega bytes (MB) to be allocated for the in-memory state # cache. Note that CacheSize needs to be a multiple of 32 MB. If it is not a multiple # of 32 MB, the peer would round the size to the next multiple of 32 MB. # To disable the cache, 0 MB needs to be assigned to the cacheSize. cacheSize: 64 history: # enableHistoryDatabase - options are true or false # Indicates if the history of key updates should be stored. # All history &#x27;index&#x27; will be stored in goleveldb, regardless if using # CouchDB or alternate database for the state. enableHistoryDatabase: true pvtdataStore: # the maximum db batch size for converting # the ineligible missing data entries to eligible missing data entries collElgProcMaxDbBatchSize: 5000 # the minimum duration (in milliseconds) between writing # two consecutive db batches for converting the ineligible missing data entries to eligible missing data entries collElgProcDbBatchesInterval: 1000################################################################################# Operations section################################################################################operations: # host and port for the operations server listenAddress: 127.0.0.1:9443 # TLS configuration for the operations endpoint tls: # TLS enabled enabled: false # path to PEM encoded server certificate for the operations server cert: file: # path to PEM encoded server key for the operations server key: file: # most operations service endpoints require client authentication when TLS # is enabled. clientAuthRequired requires client certificate authentication # at the TLS layer to access all resources. clientAuthRequired: false # paths to PEM encoded ca certificates to trust for client authentication clientRootCAs: files: []################################################################################# Metrics section################################################################################metrics: # metrics provider is one of statsd, prometheus, or disabled provider: disabled # statsd configuration statsd: # network type: tcp or udp network: udp # statsd server address address: 127.0.0.1:8125 # the interval at which locally cached counters and gauges are pushed # to statsd; timings are pushed immediately writeInterval: 10s # prefix is prepended to all emitted statsd metrics prefix: orderer.yaml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363# Copyright IBM Corp. All Rights Reserved.## SPDX-License-Identifier: Apache-2.0#---################################################################################## Orderer Configuration## - This controls the type and configuration of the orderer.#################################################################################General: # Listen address: The IP on which to bind to listen. ListenAddress: 127.0.0.1 # Listen port: The port on which to bind to listen. ListenPort: 7050 # TLS: TLS settings for the GRPC server. TLS: Enabled: false # PrivateKey governs the file location of the private key of the TLS certificate. PrivateKey: tls/server.key # Certificate governs the file location of the server TLS certificate. Certificate: tls/server.crt RootCAs: - tls/ca.crt ClientAuthRequired: false ClientRootCAs: # Keepalive settings for the GRPC server. Keepalive: # ServerMinInterval is the minimum permitted time between client pings. # If clients send pings more frequently, the server will # disconnect them. ServerMinInterval: 60s # ServerInterval is the time between pings to clients. ServerInterval: 7200s # ServerTimeout is the duration the server waits for a response from # a client before closing the connection. ServerTimeout: 20s # Cluster settings for ordering service nodes that communicate with other ordering service nodes # such as Raft based ordering service. Cluster: # SendBufferSize is the maximum number of messages in the egress buffer. # Consensus messages are dropped if the buffer is full, and transaction # messages are waiting for space to be freed. SendBufferSize: 10 # ClientCertificate governs the file location of the client TLS certificate # used to establish mutual TLS connections with other ordering service nodes. ClientCertificate: # ClientPrivateKey governs the file location of the private key of the client TLS certificate. ClientPrivateKey: # The below 4 properties should be either set together, or be unset together. # If they are set, then the orderer node uses a separate listener for intra-cluster # communication. If they are unset, then the general orderer listener is used. # This is useful if you want to use a different TLS server certificates on the # client-facing and the intra-cluster listeners. # ListenPort defines the port on which the cluster listens to connections. ListenPort: # ListenAddress defines the IP on which to listen to intra-cluster communication. ListenAddress: # ServerCertificate defines the file location of the server TLS certificate used for intra-cluster # communication. ServerCertificate: # ServerPrivateKey defines the file location of the private key of the TLS certificate. ServerPrivateKey: # Bootstrap method: The method by which to obtain the bootstrap block # system channel is specified. The option can be one of: # &quot;file&quot; - path to a file containing the genesis block or config block of system channel # &quot;none&quot; - allows an orderer to start without a system channel configuration BootstrapMethod: file # Bootstrap file: The file containing the bootstrap block to use when # initializing the orderer system channel and BootstrapMethod is set to # &quot;file&quot;. The bootstrap file can be the genesis block, and it can also be # a config block for late bootstrap of some consensus methods like Raft. # Generate a genesis block by updating $FABRIC_CFG_PATH/configtx.yaml and # using configtxgen command with &quot;-outputBlock&quot; option. # Defaults to file &quot;genesisblock&quot; (in $FABRIC_CFG_PATH directory) if not specified. BootstrapFile: # LocalMSPDir is where to find the private crypto material needed by the # orderer. It is set relative here as a default for dev environments but # should be changed to the real location in production. LocalMSPDir: msp # LocalMSPID is the identity to register the local MSP material with the MSP # manager. IMPORTANT: The local MSP ID of an orderer needs to match the MSP # ID of one of the organizations defined in the orderer system channel&#x27;s # /Channel/Orderer configuration. The sample organization defined in the # sample configuration provided has an MSP ID of &quot;SampleOrg&quot;. LocalMSPID: SampleOrg # Enable an HTTP service for Go &quot;pprof&quot; profiling as documented at: # https://golang.org/pkg/net/http/pprof Profile: Enabled: false Address: 0.0.0.0:6060 # BCCSP configures the blockchain crypto service providers. BCCSP: # Default specifies the preferred blockchain crypto service provider # to use. If the preferred provider is not available, the software # based provider (&quot;SW&quot;) will be used. # Valid providers are: # - SW: a software based crypto provider # - PKCS11: a CA hardware security module crypto provider. Default: SW # SW configures the software based blockchain crypto provider. SW: # TODO: The default Hash and Security level needs refactoring to be # fully configurable. Changing these defaults requires coordination # SHA2 is hardcoded in several places, not only BCCSP Hash: SHA2 Security: 256 # Location of key store. If this is unset, a location will be # chosen using: &#x27;LocalMSPDir&#x27;/keystore FileKeyStore: KeyStore: # Settings for the PKCS#11 crypto provider (i.e. when DEFAULT: PKCS11) PKCS11: # Location of the PKCS11 module library Library: # Token Label Label: # User PIN Pin: Hash: Security: FileKeyStore: KeyStore: # Authentication contains configuration parameters related to authenticating # client messages Authentication: # the acceptable difference between the current server time and the # client&#x27;s time as specified in a client request message TimeWindow: 15m################################################################################## SECTION: File Ledger## - This section applies to the configuration of the file or json ledgers.#################################################################################FileLedger: # Location: The directory to store the blocks in. # NOTE: If this is unset, a new temporary location will be chosen every time # the orderer is restarted, using the prefix specified by Prefix. Location: /var/hyperledger/production/orderer # The prefix to use when generating a ledger directory in temporary space. # Otherwise, this value is ignored. Prefix: hyperledger-fabric-ordererledger################################################################################## SECTION: Kafka## - This section applies to the configuration of the Kafka-based orderer, and# its interaction with the Kafka cluster.#################################################################################Kafka: # Retry: What do if a connection to the Kafka cluster cannot be established, # or if a metadata request to the Kafka cluster needs to be repeated. Retry: # When a new channel is created, or when an existing channel is reloaded # (in case of a just-restarted orderer), the orderer interacts with the # Kafka cluster in the following ways: # 1. It creates a Kafka producer (writer) for the Kafka partition that # corresponds to the channel. # 2. It uses that producer to post a no-op CONNECT message to that # partition # 3. It creates a Kafka consumer (reader) for that partition. # If any of these steps fail, they will be re-attempted every # &lt;ShortInterval&gt; for a total of &lt;ShortTotal&gt;, and then every # &lt;LongInterval&gt; for a total of &lt;LongTotal&gt; until they succeed. # Note that the orderer will be unable to write to or read from a # channel until all of the steps above have been completed successfully. ShortInterval: 5s ShortTotal: 10m LongInterval: 5m LongTotal: 12h # Affects the socket timeouts when waiting for an initial connection, a # response, or a transmission. See Config.Net for more info: # https://godoc.org/github.com/Shopify/sarama#Config NetworkTimeouts: DialTimeout: 10s ReadTimeout: 10s WriteTimeout: 10s # Affects the metadata requests when the Kafka cluster is in the middle # of a leader election.See Config.Metadata for more info: # https://godoc.org/github.com/Shopify/sarama#Config Metadata: RetryBackoff: 250ms RetryMax: 3 # What to do if posting a message to the Kafka cluster fails. See # Config.Producer for more info: # https://godoc.org/github.com/Shopify/sarama#Config Producer: RetryBackoff: 100ms RetryMax: 3 # What to do if reading from the Kafka cluster fails. See # Config.Consumer for more info: # https://godoc.org/github.com/Shopify/sarama#Config Consumer: RetryBackoff: 2s # Settings to use when creating Kafka topics. Only applies when # Kafka.Version is v0.10.1.0 or higher Topic: # The number of Kafka brokers across which to replicate the topic ReplicationFactor: 3 # Verbose: Enable logging for interactions with the Kafka cluster. Verbose: false # TLS: TLS settings for the orderer&#x27;s connection to the Kafka cluster. TLS: # Enabled: Use TLS when connecting to the Kafka cluster. Enabled: false # PrivateKey: PEM-encoded private key the orderer will use for # authentication. PrivateKey: # As an alternative to specifying the PrivateKey here, uncomment the # following &quot;File&quot; key and specify the file name from which to load the # value of PrivateKey. #File: path/to/PrivateKey # Certificate: PEM-encoded signed public key certificate the orderer will # use for authentication. Certificate: # As an alternative to specifying the Certificate here, uncomment the # following &quot;File&quot; key and specify the file name from which to load the # value of Certificate. #File: path/to/Certificate # RootCAs: PEM-encoded trusted root certificates used to validate # certificates from the Kafka cluster. RootCAs: # As an alternative to specifying the RootCAs here, uncomment the # following &quot;File&quot; key and specify the file name from which to load the # value of RootCAs. #File: path/to/RootCAs # SASLPlain: Settings for using SASL/PLAIN authentication with Kafka brokers SASLPlain: # Enabled: Use SASL/PLAIN to authenticate with Kafka brokers Enabled: false # User: Required when Enabled is set to true User: # Password: Required when Enabled is set to true Password: # Kafka protocol version used to communicate with the Kafka cluster brokers # (defaults to 0.10.2.0 if not specified) Version:################################################################################## Debug Configuration## - This controls the debugging options for the orderer#################################################################################Debug: # BroadcastTraceDir when set will cause each request to the Broadcast service # for this orderer to be written to a file in this directory BroadcastTraceDir: # DeliverTraceDir when set will cause each request to the Deliver service # for this orderer to be written to a file in this directory DeliverTraceDir:################################################################################## Operations Configuration## - This configures the operations server endpoint for the orderer#################################################################################Operations: # host and port for the operations server ListenAddress: 127.0.0.1:8443 # TLS configuration for the operations endpoint TLS: # TLS enabled Enabled: false # Certificate is the location of the PEM encoded TLS certificate Certificate: # PrivateKey points to the location of the PEM-encoded key PrivateKey: # Most operations service endpoints require client authentication when TLS # is enabled. ClientAuthRequired requires client certificate authentication # at the TLS layer to access all resources. ClientAuthRequired: false # Paths to PEM encoded ca certificates to trust for client authentication ClientRootCAs: []################################################################################## Metrics Configuration## - This configures metrics collection for the orderer#################################################################################Metrics: # The metrics provider is one of statsd, prometheus, or disabled Provider: disabled # The statsd configuration Statsd: # network type: tcp or udp Network: udp # the statsd server address Address: 127.0.0.1:8125 # The interval at which locally cached counters and gauges are pushed # to statsd; timings are pushed immediately WriteInterval: 30s # The prefix is prepended to all emitted statsd metrics Prefix:################################################################################## Consensus Configuration## - This section contains config options for a consensus plugin. It is opaque# to orderer, and completely up to consensus implementation to make use of.#################################################################################Consensus: # The allowed key-value pairs here depend on consensus plugin. For etcd/raft, # we use following options: # WALDir specifies the location at which Write Ahead Logs for etcd/raft are # stored. Each channel will have its own subdir named after channel ID. WALDir: /var/hyperledger/production/orderer/etcdraft/wal # SnapDir specifies the location at which snapshots for etcd/raft are # stored. Each channel will have its own subdir named after channel ID. SnapDir: /var/hyperledger/production/orderer/etcdraft/snapshot","categories":[{"name":"区块链","slug":"区块链","permalink":"http://peapod.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"Hyperledger Fabric进阶","slug":"Hyperledger-Fabric进阶","permalink":"http://peapod.top/tags/Hyperledger-Fabric%E8%BF%9B%E9%98%B6/"}],"author":"taweizhong"},{"title":"锁和 sync 包","slug":"锁和-sync-包","date":"2022-10-04T06:57:58.000Z","updated":"2024-02-27T10:47:04.893Z","comments":true,"path":"2022/10/04/锁和-sync-包/","link":"","permalink":"http://peapod.top/2022/10/04/%E9%94%81%E5%92%8C-sync-%E5%8C%85/","excerpt":"","text":"锁和 sync 包map 类型是不存在锁的机制来实现这种效果(出于对性能的考虑)，所以 map 类型是非线程安全的。当并行访问一个共享的 map 类型的数据，map 数据将会出错。 一次只能让一个线程对共享变量进行操作。当变量被一个线程改变时(临界区)，我们为它上锁，直到这个线程执行完成并解锁后，其他线程才能访问它。 sync.Mutex 是一个互斥锁，它的作用是守护在临界区入口来确保同一时间只能有一个线程进入临界区。 1234567891011121314import &quot;sync&quot;type Info struct &#123; mu sync.Mutex // ... other fields, e.g.: Str string&#125;func Update(info *Info) &#123; info.mu.Lock() // critical section: info.Str = // new value // end critical section info.mu.Unlock()&#125; Mutex 来实现一个可以上锁的共享缓冲器: 1234type SyncedBuffer struct &#123; lock sync.Mutex buffer bytes.Buffer&#125; 在 sync 包中还有一个 RWMutex 锁：他能通过 RLock() 来允许同一时间多个线程对变量进行读操作，但是只能一个线程进行写操作。 包中还有一个方便的 Once 类型变量的方法 once.Do(call)，这个方法确保被调用函数只能被调用一次。","categories":[{"name":"golang标准库","slug":"golang标准库","permalink":"http://peapod.top/categories/golang%E6%A0%87%E5%87%86%E5%BA%93/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://peapod.top/tags/Go/"}],"author":"taweizhong"},{"title":"regexp包","slug":"regexp包","date":"2022-10-04T06:22:40.000Z","updated":"2022-10-06T03:24:50.000Z","comments":true,"path":"2022/10/04/regexp包/","link":"","permalink":"http://peapod.top/2022/10/04/regexp%E5%8C%85/","excerpt":"","text":"regexp 包正则表达式语法是一种字符串匹配模式或者规则，用来检索、替换那些符合特定规则的文本。 元字符 元字符 匹配内容 . 匹配除换行符以外的任意字符 \\w 匹配所有普通字符(数字、字母或下划线) \\s 匹配任意的空白符 \\d 匹配数字 \\n 匹配一个换行符 \\t 匹配一个制表符 \\b 匹配一个单词的结尾 ^ 匹配字符串的开始位置 $ 匹配字符串的结尾位置 \\W 匹配非字母或数字或下划线 \\D 匹配非数字 \\S 匹配非空白符 a|b 匹配字符 a 或字符 b () 正则表达式分组所用符号，匹配括号内的表达式，表示一个组。 […] 匹配字符组中的字符 [^…] 匹配除了字符组中字符的所有字符 量词 量词 用法说明 * 重复零次或者更多次 + 重复一次或者更多次 ？ 重复0次或者一次 {n} 重复n次 {n,} 重复n次或者更多次 {n,m} 重复n到m次 字符组 正则 待匹配字符 匹配结果 说明 [0123456789] 8 True 在一个字符组里枚举所有字符，字符组里的任意一个字符 和”待匹配字符”相同都视为可以匹配。 [0123456789] a False 由于字符组中没有 “a” 字符，所以不能匹配。 [0-9] 7 True 也可以用-表示范围，[0-9] 就和 [0123456789] 是一个意思。 [a-z] s True 同样的如果要匹配所有的小写字母，直接用 [a-z] 就可以表示。 [A-Z] B True [A-Z] 就表示所有的大写字母。 [0-9a-fA-F] e True 可以匹配数字，大小写形式的 a～f，用来验证十六进制字符。 贪婪匹配和非贪婪匹配正则表达式默认为贪婪匹配，也就是尽可能多的向后匹配字符，比如 {n,m} 表示匹配前面的内容出现 n 到 m 次（n 小于 m），在贪婪模式下，首先以匹配 m 次为目标，而在非贪婪模式是尽可能少的向后匹配内容，也就是说匹配 n 次即可。 元字符(贪婪模式) 非贪婪模式 * *? + +？ ？ ?? {n,m} {n,m}？ 实现12345678910111213141516171819202122232425262728package mainimport ( &quot;fmt&quot; &quot;regexp&quot; &quot;strconv&quot;)func main() &#123; //目标字符串 searchIn := &quot;John: 2578.34 William: 4567.23 Steve: 5632.18&quot; pat := &quot;[0-9]+.[0-9]+&quot; //正则 f := func(s string) string&#123; v, _ := strconv.ParseFloat(s, 32) return strconv.FormatFloat(v * 2, &#x27;f&#x27;, 2, 32) &#125; if ok, _ := regexp.Match(pat, []byte(searchIn)); ok &#123; fmt.Println(&quot;Match Found!&quot;) &#125; re, _ := regexp.Compile(pat) //将匹配到的部分替换为&quot;##.#&quot; str := re.ReplaceAllString(searchIn, &quot;##.#&quot;) fmt.Println(str) //参数为函数时 str2 := re.ReplaceAllStringFunc(searchIn, f) fmt.Println(str2)&#125;","categories":[{"name":"golang标准库","slug":"golang标准库","permalink":"http://peapod.top/categories/golang%E6%A0%87%E5%87%86%E5%BA%93/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://peapod.top/tags/Go/"}],"author":"taweizhong"},{"title":"Go标准库 输入输出","slug":"Go标准库-输入输出","date":"2022-09-27T01:26:09.000Z","updated":"2024-02-27T10:54:33.299Z","comments":true,"path":"2022/09/27/Go标准库-输入输出/","link":"","permalink":"http://peapod.top/2022/09/27/Go%E6%A0%87%E5%87%86%E5%BA%93-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/","excerpt":"","text":"输入输出io-基本的IO接口io包为I&#x2F;O原语提供了基本的接口。包装了原语的已有实现。 只要满足Reader和Writer接口，就可以使用IO包的功能。 Reader接口定义： 123type Reader interface &#123; Read(p []byte) (n int, err error)&#125; Read将len(p)个字节读取到p中。返回读取的字节数n和遇到的错误。 Reader接口的方法集只包含了一个Read方法，所有实现了Read方法的类型都可以满足io.Reader接口。 12345678910111213141516func ReadFrom(reader io.Reader, num int) ([]byte, error) &#123; p := make([]byte, num) n, err := reader.Read(p) if n &gt; 0 &#123; return p[:n], nil &#125; return p, err&#125;// 从标准输入读取data, err = ReadFrom(os.Stdin, 11)// 从普通文件读取，其中 file 是 os.File 的实例data, err = ReadFrom(file, 9)// 从字符串读取data, err = ReadFrom(strings.NewReader(&quot;from string&quot;), 12) 传递的参数是个接口，在函数中调用了这个接口变量的Read方法，只需要在向ReadFrom函数传递实参的时候传递一个实现了该接口的对象，这样就把对象赋值给了接口。 Writer 接口定义： 123type Write interface &#123; Write(p byte[]) (n int, err error)&#125; 所有实现了Write方法的类型都实现了 io.Writer 接口。 实现了io.Reader接口或io.Writer接口的类型 os.File 同时实现了 io.Reader 和 io.Writer strings.Reader 实现了 io.Reader bufio.Reader&#x2F;Writer 分别实现了 io.Reader 和 io.Writer bytes.Buffer 同时实现了 io.Reader 和 io.Writer bytes.Reader 实现了 io.Reader encoding&#x2F;csv.Reader&#x2F;Writer 分别实现了 io.Reader 和 io.Writer net&#x2F;conn 分别实现了 io.Reader 和 io.Writer(Conn接口定义了Read&#x2F;Write) 常用的类型有：os.File、strings.Reader、bufio.Reader&#x2F;Writer、bytes.Buffer、bytes.Reader Go 中接口的命名约定：接口名以 er 结尾。 ReaderAt 和 WriterAt 接口ReaderAt 接口的定义：123type ReaderAt interface &#123; ReadAt(p []byte, off int64) (n int, err error)&#125; ReadAt 从基本输入源的偏移量 off 处开始，将 len(p) 个字节读取到 p 中。它返回读取的字节数 n（0 &lt;&#x3D; n &lt;&#x3D; len(p)）以及任何遇到的错误。 123456789reader := strings.NewReader(&quot;Go语言中文网&quot;)p := make([]byte, 6)n, err := reader.ReadAt(p, 2)if err != nil &#123; panic(err)&#125;fmt.Printf(&quot;%s, %d\\n&quot;, p, n)// 语言, 6 WriterAt 接口的定义：123type WriterAt interface &#123; WriteAt(p []byte, off int64) (n int, err error)&#125; WriteAt 从 p 中将 len(p) 个字节写入到偏移量 off 处的基本数据流中。它返回从 p 中被写入的字节数 n（0 &lt;&#x3D; n &lt;&#x3D; len(p)）以及任何遇到的引起写入提前停止的错误。 1234567891011file, err := os.Create(&quot;writeAt.txt&quot;)if err != nil &#123; panic(err)&#125;defer file.Close()file.WriteString(&quot;Golang中文社区——这里是多余&quot;)n, err := file.WriteAt([]byte(&quot;Go语言中文网&quot;), 24)if err != nil &#123; panic(err)&#125;fmt.Println(n) ReaderFrom 和 WriterTo 接口ReaderFrom 的定义:123type ReaderFrom interface &#123; ReadFrom(r Reader) (n int64, err error)&#125; ReadFrom 从 r 中读取数据，直到 EOF 或发生错误。其返回值 n 为读取的字节数。 12345678file, err := os.Open(&quot;writeAt.txt&quot;)if err != nil &#123; panic(err)&#125;defer file.Close()writer := bufio.NewWriter(os.Stdout)writer.ReadFrom(file)writer.Flush() WriterTo的定义:123type WriterTo interface &#123; WriteTo(w Writer) (n int64, err error)&#125; WriteTo 将数据写入 w 中，直到没有数据可写或发生错误。其返回值 n 为写入的字节数。 12reader := bytes.NewReader([]byte(&quot;Go语言中文网&quot;))reader.WriteTo(os.Stdout) ioutil — 方便的IO操作函数集ReadAll 函数Go 提供了 ReadAll 这个函数，用来从io.Reader 中一次读取所有数据。 1func ReadAll(r io.Reader) ([]byte, error) 它是通过 bytes.Buffer 中的 ReadFrom 来实现读取所有数据的。 ReadDri 函数读取目录并返回排好序的文件和子目录名（ []os.FileInfo ）。 1fileInfos, err := ioutil.ReadDir(path) ReadFile 和 WriteFile 函数ReadFile 读取整个文件的内容。 ReadFile 的实现和ReadAll 类似，不过，ReadFile 会先判断文件的大小，给 bytes.Buffer 一个预定义容量，避免额外分配内存。 1func ReadFile(filename string) ([]byte, error) ReadFile 从 filename 指定的文件中读取数据并返回文件的内容。 WriteFile 函数： 1func WriteFile(filename string, data []byte, perm os.FileMode) error WriteFile 将data写入filename文件中，当文件不存在时会根据perm指定的权限进行创建一个,文件存在时会先清空文件内容。 TempDir 和 TempFile 函数TempDir 创建临时目录。 1b.work, err = ioutil.TempDir(&quot;&quot;, &quot;go-build&quot;) 第一个参数如果为空，表明在系统默认的临时目录（ os.TempDir ）中创建临时目录；第二个参数指定临时目录名的前缀，该函数返回临时目录的路径。 TempFile 用于创建临时文件。 1f1, err := ioutil.TempFile(&quot;&quot;, &quot;gofmt&quot;) 第一个参数如果为空，表明在系统默认的临时目录（ os.TempDir ）中创建临时文件；第二个参数指定临时文件名的前缀，该函数返回临时文件的路径。 创建者创建的临时文件和临时目录要负责删除这些临时目录和文件。 如删除临时文件： 1234defer func() &#123; f.Close() os.Remove(f.Name()) &#125;() fmt — 格式化IOPrintingSample12345678910111213141516171819202122232425262728293031type user struct &#123; name string&#125;func main() &#123; u := user&#123;&quot;tang&quot;&#125; //Printf 格式化输出 fmt.Printf(&quot;% + v\\n&quot;, u) //格式化输出结构 fmt.Printf(&quot;%#v\\n&quot;, u) //输出值的 Go 语言表示方法 fmt.Printf(&quot;%T\\n&quot;, u) //输出值的类型的 Go 语言表示 fmt.Printf(&quot;%t\\n&quot;, true) //输出值的 true 或 false fmt.Printf(&quot;%b\\n&quot;, 1024) //二进制表示 fmt.Printf(&quot;%c\\n&quot;, 11111111) //数值对应的 Unicode 编码字符 fmt.Printf(&quot;%d\\n&quot;, 10) //十进制表示 fmt.Printf(&quot;%o\\n&quot;, 8) //八进制表示 fmt.Printf(&quot;%q\\n&quot;, 22) //转化为十六进制并附上单引号 fmt.Printf(&quot;%x\\n&quot;, 1223) //十六进制表示，用a-f表示 fmt.Printf(&quot;%X\\n&quot;, 1223) //十六进制表示，用A-F表示 fmt.Printf(&quot;%U\\n&quot;, 1233) //Unicode表示 fmt.Printf(&quot;%b\\n&quot;, 12.34) //无小数部分，两位指数的科学计数法6946802425218990p-49 fmt.Printf(&quot;%e\\n&quot;, 12.345) //科学计数法，e表示 fmt.Printf(&quot;%E\\n&quot;, 12.34455) //科学计数法，E表示 fmt.Printf(&quot;%f\\n&quot;, 12.3456) //有小数部分，无指数部分 fmt.Printf(&quot;%g\\n&quot;, 12.3456) //根据实际情况采用%e或%f输出 fmt.Printf(&quot;%G\\n&quot;, 12.3456) //根据实际情况采用%E或%f输出 fmt.Printf(&quot;%s\\n&quot;, &quot;wqdew&quot;) //直接输出字符串或者[]byte fmt.Printf(&quot;%q\\n&quot;, &quot;dedede&quot;) //双引号括起来的字符串 fmt.Printf(&quot;%x\\n&quot;, &quot;abczxc&quot;) //每个字节用两字节十六进制表示，a-f表示 fmt.Printf(&quot;%X\\n&quot;, &quot;asdzxc&quot;) //每个字节用两字节十六进制表示，A-F表示 fmt.Printf(&quot;%p\\n&quot;, 0x123) //0x开头的十六进制数表示&#125; 占位符 占位符 说明 %v 相应值的默认格式。“加号”标记（%+v）会添加字段名 %#v 相应值的Go语法表示 %T 相应值的类型的Go语法表示 %% 字面上的百分号，并非值的占位符 %t true 或 false。 %b 二进制表示 %c 相应Unicode码点所表示的字符 %d 十进制表示 %o 八进制表示 %q 单引号围绕的字符字面值，由Go语法安全地转义 %x 十六进制表示，字母形式为小写 a-f %X 十六进制表示，字母形式为大写 A-F %s 输出字符串表示（string类型或[]byte) %p 十六进制表示，前缀 0x %f 有小数点而无指数，例如 123.456 %e 科学计数法，例如 -1234.456e+78 %g 根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出 %G 根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出 %E 科学计数法，例如 -1234.456E+78 对数值而言，宽度为该数值占用区域的最小宽度；精度为小数点之后的位数。 ScanningScan、Scanf 和 Scanln 从 os.Stdin 中读取； Fscan、Fscanf 和 Fscanln 从指定的 io.Reader 中读取； Sscan、Sscanf 和 Sscanln 从实参字符串中读取。 Scanf、Fscanf 和 Sscanf 需要输入换行符来匹配格式中的换行符；其它函数则将换行符视为空格。 Scanf、Fscanf 和 Sscanf 根据格式字符串解析实参。 宽度被解释为输入的文本（%5s 意为最多从输入中读取5个 rune 来扫描成字符串），而扫描函数则没有精度的语法（没有 %5.2f，只有 %5f）。 Print 序列函数Fprint&#x2F;Fprintf&#x2F;Fprintln 函数的第一个参数接收一个io.Writer类型，会将内容输出到 io.Writer 中去。 Print&#x2F;Printf&#x2F;Println 函数是将内容输出到标准输出中。 Sprint&#x2F;Sprintf&#x2F;Sprintln 是格式化内容为 string 类型，而并不输出到某处，需要格式化字符串并返回时。 Scan 序列函数Fscan&#x2F;Fscanf&#x2F;Fscanln 函数的第一个参数接收一个 io.Reader 类型，从其读取内容并赋值给相应的实参。 Scan&#x2F;Scanf&#x2F;Scanln 正是从标准输入获取内容。 Sscan&#x2F;Sscanf&#x2F;Sscanln 则直接从字符串中获取内容。 bufio — 缓存IOReader 类型和方法bufio.Reader 结构包装了一个 io.Reader 对象，提供缓存功能，同时实现了 io.Reader 接口。 12345678910type Reader struct &#123; buf []byte // 缓存 rd io.Reader // 底层的io.Reader // r:从buf中读走的字节（偏移）；w:buf中填充内容的偏移； // w - r 是buf中可被读的长度（缓存数据的大小），也是Buffered()方法的返回值 r, w int err error // 读过程中遇到的错误 lastByte int // 最后一次读到的字节（ReadByte/UnreadByte) lastRuneSize int // 最后一次读到的Rune的大小 (ReadRune/UnreadRune) &#125; 实列化bufio 包提供了两个实例化 bufio.Reader 对象的函数：NewReader 和 NewReaderSize。其中，NewReader 函数是调用 NewReaderSize 函数实现的： 1234func NewReader(rd io.Reader) *Reader &#123; // 默认缓存大小：defaultBufSize=4096 return NewReaderSize(rd, defaultBufSize) &#125; NewReaderSize的源码： 123456789101112131415161718func NewReaderSize(rd io.Reader, size int) *Reader &#123; // 已经是bufio.Reader类型，且缓存大小不小于 size，则直接返回 b, ok := rd.(*Reader) if ok &amp;&amp; len(b.buf) &gt;= size &#123; return b &#125; // 缓存大小不会小于 minReadBufferSize （16字节） if size &lt; minReadBufferSize &#123; size = minReadBufferSize &#125; // 构造一个bufio.Reader实例 return &amp;Reader&#123; buf: make([]byte, size), rd: rd, lastByte: -1, lastRuneSize: -1, &#125; &#125;","categories":[{"name":"golang标准库","slug":"golang标准库","permalink":"http://peapod.top/categories/golang%E6%A0%87%E5%87%86%E5%BA%93/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://peapod.top/tags/Go/"}],"author":"taweizhong"},{"title":"JSON 指南","slug":"JSON-指南","date":"2022-09-26T12:32:19.000Z","updated":"2022-10-07T03:39:24.000Z","comments":true,"path":"2022/09/26/JSON-指南/","link":"","permalink":"http://peapod.top/2022/09/26/JSON-%E6%8C%87%E5%8D%97/","excerpt":"","text":"JSON 基础轻量级的、基于文本的、开放的数据交换格式，最受欢迎的、使用最广泛的交换格式之一。 JSON是一种纯字符串形式的数据，本身不提供任何方法，适合在网络中进行传输。 在JSON中，使用两种方式表示数据： Object（对象）：键值对的集合，使用&#123;&#125;定义。 如&#123;&quot;name&quot;:&quot;taweizhong&quot;,&quot;age&quot;:&quot;22&quot;&#125; Array（数组）：值的有序集合，使用[]定义。 &quot;Article&quot;:[ &quot;JSON 是什么？&quot;, &quot;JSONP 是什么？&quot;, &quot;JSON 语法规则&quot; ] JSON的存储 JSON可以存储在.JSON格式的文件中，也可以以字符串的形式存储在数据库、Cookie、Session中。 JSON的使用 定义接口 Web开发领域 使用Ajax异步加载 RPC远程调用 前后端分离 开发API 序列化：将内存中的数据保存起来的过程称为序列化。 生成Token：直接使用Token读取保存的用户的信息。 配置文件：作为程序的配置文件。 JSON语法规则JSON中的键JSON 数据是以键&#x2F;值对（名称&#x2F;值）的形式书写的，键表示数据的名称，需要以字符串的形式定义（在双引号中定义），后面紧跟一个冒号，最后是值。 1&quot;name&quot;:&quot;C语言中文网&quot; JSON中的值JSON 中的值可以是以下数据类型： 数字（整数或浮点数）； 字符串（需要在双引号中定义）； 布尔值（true 或 false）； 数组（在方括号中定义）； 对象（在花括号中定义）； null（空）。 JSON 中每个键都必须是一个字符串","categories":[{"name":"实用","slug":"实用","permalink":"http://peapod.top/categories/%E5%AE%9E%E7%94%A8/"}],"tags":[{"name":"JSON","slug":"JSON","permalink":"http://peapod.top/tags/JSON/"}],"author":"taweizhong"},{"title":"Hyperledger Fabric 私有数据","slug":"Hyperledger-Fabric-私有数据","date":"2022-09-23T09:19:56.000Z","updated":"2022-09-24T02:25:50.000Z","comments":true,"path":"2022/09/23/Hyperledger-Fabric-私有数据/","link":"","permalink":"http://peapod.top/2022/09/23/Hyperledger-Fabric-%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE/","excerpt":"","text":"私有数据Fabric 提供了创建私有数据集合的功能，它允许在通道上定义的组织子集能够背书、提交或查询私有数据，而无需创建单独的通道。 私有数据集合集合是两个元素的组合: 实际的私有数据，通过 Gossip 协议点对点地发送给授权可以看到它的组织。 该数据的 hash 值，该 hash 值被背书、排序之后写入通道上每个节点的账本。 下面的图表说明了被授权和未被授权拥有私有数据的节点的账本内容。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://peapod.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"Hyperledger Fabric","slug":"Hyperledger-Fabric","permalink":"http://peapod.top/tags/Hyperledger-Fabric/"}],"author":"taweizhong"},{"title":"Hyperledger Fabric 排序服务","slug":"Hyperledger-Fabric-排序服务","date":"2022-09-23T09:19:46.000Z","updated":"2022-09-24T02:25:10.000Z","comments":true,"path":"2022/09/23/Hyperledger-Fabric-排序服务/","link":"","permalink":"http://peapod.top/2022/09/23/Hyperledger-Fabric-%E6%8E%92%E5%BA%8F%E6%9C%8D%E5%8A%A1/","excerpt":"","text":"排序服务排序排序节点使交易有序，并与其他排序节点一起形成一个排序服务。 本不会像其他分布式的以及无需许可的区块链中那样产生分叉。 排序节点还将链码执行的背书（发生在节点）与排序分离。 排序节点和通道配置排序节点还维护着允许创建通道的组织列表。 列表本身保存在“排序节点系统通道”（也称为“排序系统通道”）的配置中。 排序节点还对通道执行基本访问控制，限制谁可以读写数据，以及谁可以配置数据。 谁有权修改通道中的配置元素取决于相关管理员在创建联盟或通道时设置的策略。 排序节点和身份节点、应用程序、管理员和排序节点，都从它们的数字证书和成员服务提供者（MSP）定义中获取它们的组织身份。 与 Peer 节点一样，排序节点属于组织。也应该像 Peer 节点一样为每个组织使用单独的证书授权中心（CA）。 排序节点与交易流程提案客户端应用程序将交易提案发送给一组节点 节点将调用智能合约来生成一个账本更新提案，然后背书该结果。 背书节点将向客户端应用程序返回一个提案响应。 打包应用程序客户端把包含已背书交易提案响应的交易提交到排序服务节点。 排序服务创建交易区块，这些交易区块最终将分发给通道上的所有 Peer 节点 排序节点的第一个角色是打包提案的账本更新。 一个区块中交易的顺序不一定与排序服务接收的顺序相同，因为可能有多个排序服务节点几乎同时接收交易。 在 Hyperledger Fabric 中，由排序服务生成的区块是最终的。一旦一笔交易被写进一个区块，它在账本中的地位就得到了保证。 Hyperledger Fabric 的最终性意味着没有账本分叉，也就是说，经过验证的交易永远不会被重写或删除。 验证和提交每个节点将独立地以确定的方式验证区块，以确保账本保持一致。 无效的交易仍然保留在排序节点创建的区块中，但是节点将它们标记为无效，并且不更新账本的状态。 排序服务的实现几种不同的实现可以在排序服务节点之间就严格的交易排序达成共识。 Raft (推荐) 作为 v1.4.1 的新特性，Raft 是一种基于 etcd 中 Raft 协议实现的崩溃容错（Crash Fault Tolerant，CFT）排序服务。Raft 遵循“领导者跟随者”模型，这个模型中，在每个通道上选举领导者节点，其决策被跟随者复制。Raft 排序服务会比基于 Kafka 的排序服务更容易设置和管理，它的设计允许不同的组织为分布式排序服务贡献节点。 RaftFabric 实现了使用“领导者跟随者”模型的 Raft 协议，领导者是在一个通道的排序节点中动态选择的（这个集合的节点称为“共识者集合（consenter set）”），领导者将信息复制到跟随者节点。 Raft 被称为“崩溃容错”是因为系统可以承受节点的损失，包括领导者节点，前提是要剩余大量的排序节点（称为“法定人数（quorum）”）。 使用 Raft，所有内容都会嵌入到您的排序节点中。Raft 更容易设置。 使用 Raft，每个组织都可以有自己的排序节点参与排序服务，从而形成一个更加分散的系统。 Raft 是原生支持的，Raft 允许用户指定哪个排序节点要部署到哪个通道。 Raft 是向开发拜占庭容错（BFT）排序服务迈出的第一步。 日志条目（Log entry）Raft 排序服务中的主要工作单元是一个“日志条目”，该项的完整序列称为“日志”。 大多数成员（换句话说是一个法定人数）同意条目及其顺序，则我们认为条目是一致的，然后将日志复制到不同排序节点上。 共识者集合（Consenter set）主动参与给定通道的共识机制并接收该通道的日志副本的排序节点。 有限状态机（Finite-State Machine，FSM）Raft 中的每个排序节点都有一个 FSM，它们共同用于确保各个排序节点中的日志序列是确定（以相同的顺序编写）。 法定人数（Quorum）描述需要确认提案的最小同意人数。 对于每个共识者集合，这是大多数节点。 领导者通道的共识者集合都选择一个节点作为领导者，领导者负责接收新的日志条目，将它们复制到跟随者的排序节点，并在认为提交了某个条目时进行管理。 跟随者跟随者从领导者那里接收日志并复制它们，确保日志保持一致。 交易中的Raft在 Raft 中，交易（以提案或配置更新的形式）由接收交易的排序节点自动路由到该通道的当前领导者。 架构说明Raft 是如何选举领导者节点总是处于以下三种状态之一：跟随者、候选人或领导者。 所有节点最初都是作为跟随者开始的。 在一段时间内没有接收到日志条目或心跳（例如，5秒），节点将自己提升到候选状态。 在候选状态中，节点从其他节点请求选票。如果候选人获得法定人数的选票，那么他就被提升为领导者。 快照Raft 使用了一个称为“快照”的过程，在这个过程中，用户可以定义日志中要保留多少字节的数据。这个数据量将决定区块的数量。 快照中只存储完整的区块","categories":[{"name":"区块链","slug":"区块链","permalink":"http://peapod.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"Hyperledger Fabric","slug":"Hyperledger-Fabric","permalink":"http://peapod.top/tags/Hyperledger-Fabric/"}],"author":"taweizhong"},{"title":"Hyperledger Fabric 账本","slug":"Hyperledger-Fabric-账本","date":"2022-09-23T09:19:33.000Z","updated":"2022-09-24T02:24:44.000Z","comments":true,"path":"2022/09/23/Hyperledger-Fabric-账本/","link":"","permalink":"http://peapod.top/2022/09/23/Hyperledger-Fabric-%E8%B4%A6%E6%9C%AC/","excerpt":"","text":"账本账本、事实和状态账本储存的其实并不是业务对象本身，而是与业务对象相关的事实信息。 与业务对象当前状态相关的事实可能会发生改变，但是与之相关的事实历史是不可变的。 账本账本由“世界状态“和”区块链“这两部分组成，它们彼此不同但却相互关联。 世界状态是一个数据库，它存储了一组账本状态的当前值。 通过世界状态，程序可以直接访问一个账本状态的当前值，不需要遍历整个交易日志来计算当前值。 区块链是交易日志，它记录了促成当前世界状态的所有改变。 世界状态 W 由区块链 B 决定。 Fabric 网络维护着一个账本的多个副本，这些副本通过名为共识的过程来与其他副本保持一致。分布式账本技术（DLT） 世界状态世界状态将业务对象属性的当前值保存为唯一的账本状态。 世界状态包含两个状态。第一个状态是： key&#x3D;CAR1 和 value&#x3D;Audi。第二个状态中有一个更复杂的值：key&#x3D;CAR2 和 value&#x3D;{model:BMW, color&#x3D;red, owner&#x3D;Jane} 。 账本状态记录了一组与特定业务对象有关的事实。我们的示例展示的是 CAR1 和 CAR2 这两辆车的账本状态，二者都各有一个值和一个键。 世界状态被作为数据库来实现。 （所有被提交的交易，无论有效与否，都会被收进区块链）。 关键设计在于，只有那些受到相关背书组织签名的交易才会更新世界状态。 首次创建账本时，世界状态是空的。 个人理解：这个世界状态相当于比特币中的UTXO。 区块链世界状态存储了与业务对象当前状态相关的事实信息，而区块链是一种历史记录，它记录了这些业务对象是如何到达各自当前状态的相关事实。 区块链记录了每个账本状态之前的所有版本以及状态是如何被更改的。 区块排序以及区块内的交易排序，这一机制是在 Hyperledger Fabric 的排序服务组件首次创建区块时被建立起来的。 区块链总是以文件实现，而与之相反的是，世界状态以数据库实现。 区块链 B 包含了 B0、B1、B2、B3这四个区块。B0 是该区块链的第一个区块，也叫创世区块。 创世区块包含了一个配置交易，该交易含有网络配置（未显示）的初始状态。 区块区块结构： 区块头 包含三个字段，这些字段是在创建一个区块时候被写入的。 区块编号：编号从0（初始区块）开始，每在区块链上增加一个新区块，编号的数字都会加1。 当前区块的哈希值：当前区块中包含的所有交易的哈希值。 前一个区块头的哈希值：区块链中前一个区块头的哈希值。 区块数据：包含了一个有序的交易列表。区块数据是在排序服务创建区块时被写入的。 区块元数据：包含了区块被写入的时间，还有区块写入者的证书、公钥以及签名。 交易交易记录了世界状态发生的更新。 T4包括的内容如下：交易头 H4，一个交易签名 S4，一个交易提案 P4，一个交易响应 R4 和一系列背书 E4。 头 这部分用 H4 表示，它记录了关于交易的一些重要元数据，比如，相关链码的名字以及版本。 签名 这部分用 S4 表示，它包含了一个由客户端应用程序创建的加密签名。该字段是用来检查交易细节是否未经篡改，因为交易签名的生成需要用到应用程序的私钥。 提案 这部分用 P4 表示，它负责对应用程序供给智能合约的输入参数进行编码，随后该智能合约生成提案账本更新。在智能合约运行时，这个提案提供了一套输入参数，这些参数同当前的世界状态一起决定了新的账本世界状态。 响应 这部分用 R4 表示，它是以读写集 （RW-set）的形式记录下世界状态之前和之后的值。交易响应是智能合约的输出，如果交易验证成功，那么该交易会被应用到账本上，从而更新世界状态。 背书 就像 E4 显示的那样，它指的是一组签名交易响应，这些签名都来自背书策略规定的相关组织，并且这些组织的数量必须满足背书策略的要求。 世界状态数据库的选择世界状态是以数据库的形式实现的，旨在提供简单有效的账本状态存储和检索。 世界状态数据库的选项包括 LevelDB 和 CouchDB 。 LevelDB 是世界状态数据库的默认选项，当账本状态是简单的键值对时，使用 LevelDB 非常合适。 当账本状态结构为 JSON 文档时，以 CouchDB 来实现世界状态非常合适，这是因为业务交易涉及的数据类型通常十分丰富，而 CouchDB 可支持对这些数据类型进行各种形式的查询和更新。 在实现方面，CouchDB 是在单独的操作系统进程中运行的，但是节点和 CouchDB 实例之间仍然存在1:1的关系。 命名空间每个链码都有自己的世界状态，并且与所有其他链码的世界状态分离。 世界状态位于一个命名空间中，因此只有位于同一链码中的智能合约才能访问一个给定的命名空间。 区块链没有命名空间。它包含来自许多不同智能合约命名空间的交易。 通道每个通道都有一个完全独立的账本。这意味着完全独立的区块链和完全独立的世界状态，包括命名空间。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://peapod.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"Hyperledger Fabric","slug":"Hyperledger-Fabric","permalink":"http://peapod.top/tags/Hyperledger-Fabric/"}],"author":"taweizhong"},{"title":"Hyperledger Fabric 智能合约","slug":"Hyperledger-Fabric-智能合约","date":"2022-09-23T09:19:19.000Z","updated":"2022-09-24T02:24:26.000Z","comments":true,"path":"2022/09/23/Hyperledger-Fabric-智能合约/","link":"","permalink":"http://peapod.top/2022/09/23/Hyperledger-Fabric-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/","excerpt":"","text":"智能合约和链码账本包含了与一组业务对象的当前和历史状态有关的事实，而智能合约定义了生成这些被添加到账本中的新事实的可执行逻辑。 管理员通常使用链码将相关的智能合约组织起来进行部署，并且链码也可以用于 Fabric 的底层系统编程。 智能合约在各业务彼此进行交互之前，必须先定义一套通用的合约，其中包括通用术语、数据、规则、概念定义和流程。 智能合约用可执行的代码定义了不同组织之间的规则。 应用程序调用智能合约来生成被记录到账本上的交易。 组织 ORG1 和 ORG2 是如何通过定义一个 car 智能合约来实现 查询、转移 和 更新 汽车的。 可以将智能合约看成交易的管理者，而链码则管理着如何将智能合约打包以便用于部署。 一个智能合约定义在一个链码中。而多个智能合约也可以定义在同一个链码中。当一个链码部署完毕，该链码中的所有智能合约都可供应用程序使用。 vehicle 链码包含了以下三个智能合约：cars、boats 和 trucks；而 insurance 链码包含了以下四个智能合约：policy、liability、syndication 和 securitization。 账本智能合约以编程方式访问账本两个不同的部分： 一个是区块链（记录所有交易的历史，且记录不可篡改） 一个是世界状态（保存这些状态当前值的缓存，是经常需要用到的对象的当前值）。 智能合约主要在世界状态中将状态写入（put）、读取（get）和删除（delete），还可以查询不可篡改的区块链交易记录。 读取（get） 操作一般代表的是查询，目的是获取关于交易对象当前状态的信息。 写入（put） 操作通常生成一个新的业务对象或者对账本世界状态中现有的业务对象进行修改。 删除（delete） 操作代表的是将一个业务对象从账本的当前状态中移除，但不从账本的历史中移除。 开发智能合约是应用程序开发的重点。 智能合约的核心是一组 交易 定义。 例如，在 fabcar.js 中，创建了一辆新车的智能合约交易： 123456789101112async createCar(ctx, carNumber, make, model, color, owner) &#123; const car = &#123; color, docType: &#x27;car&#x27;, make, model, owner, &#125;; await ctx.stub.putState(carNumber, Buffer.from(JSON.stringify(car)));&#125; 背书每个链码都有一个背书策略与之相关联，该背书策略适用于此链码中定义的所有智能合约。 背书策略非常重要，它指明了区块链网络中哪些组织必须对一个给定的智能合约所生成的交易进行签名，以此来宣布该交易有效。 一个示例背书策略可能这样定义：参与区块链网络的四个组织中有三个必须在交易被认为有效之前签署该交易。所有的交易，无论是有效的还是无效的，都会被添加到分布式账本中，但只有有效交易会更新世界状态。 交易必须由 Fabric 网络中受信任的组织验证。 例如，一个政府组织必须签署一个有效的 issueIdentity 交易，或者一辆车的 买家 和 卖家 都必须签署一个 车辆 转移交易。 有效交易智能合约提取一组名为交易提案的输入参数，并将其与程序逻辑结合起来使用以读写账本。对世界状态的更改被捕获为交易提案响应（或简称交易响应），该响应包含一个读写集，其中既含有已读取的状态，也含有还未书写的新状态（如果交易有效的话）。 在执行智能合约时世界状态没有更新！ 所有交易，无论是否有效，都会被记录在区块链上，但仅有效交易会更新世界状态。 各节点通过两个阶段对其进行验证。 根据背书策略检查交易，确保该交易已被足够的组织签署。 该交易在受到背书节点签名时它的交易读集与世界状态的当前值匹配，并且中间过程中没有被更新。 交易通过了这两个测试，它就被标记为有效。 通道 通道在一群组织之间提供了一种完全独立的通信机制。当链码定义被提交到通道上时，该通道上所有的应用程序都可以使用此链码中的智能合约。 链码定义是一种包含了许多参数的结构，这些参数管理着链码的运行方式，包含着链码名、版本以及背书策略。各通道成员批准各自组织的一个链码定义，以表示其对该链码的参数表示同意。 链码的定义为通道成员提供了一种他们在通道上使用智能合约来交易之前，同意对于一个链码的管理的方式。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://peapod.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"Hyperledger Fabric","slug":"Hyperledger-Fabric","permalink":"http://peapod.top/tags/Hyperledger-Fabric/"}],"author":"taweizhong"},{"title":"Hyperledger Fabric 节点","slug":"Hyperledger-Fabric-节点","date":"2022-09-23T09:19:11.000Z","updated":"2022-09-24T02:23:54.000Z","comments":true,"path":"2022/09/23/Hyperledger-Fabric-节点/","link":"","permalink":"http://peapod.top/2022/09/23/Hyperledger-Fabric-%E8%8A%82%E7%82%B9/","excerpt":"","text":"节点Peer 是网络的基本元素，因为他们存储了账本和智能合约。 Peer 节点可以被创建、启动、停止、重新配置甚至删除。 暴露了一系列的 API，这就可以让管理者和应用程序同这些 API 提供的服务互动。 账本和链码Peer 节点在维护账本和链码。 Peer 节点维护的是账本及链码的实例。 应用程序及管理员访问这些资源，他们必须要和 Peer 节点进行交互。 多账本 大多数的 Peer 节点将会至少安装一个链码，用来查询或更新 Peer 节点的账本实例。 多链码 应用程序和节点当应用程序需要访问账本和链码的时候，他们总是需要连接到 Peer 节点。 Hyperledger Fabric SDK 将这个操作变得非常简单，它的 API 使应用程序能够连接到 Peer 节点，调用链码生成交易，提交交易到网络。 查询过程： A 连接到了 P1 且调用了链码 S1 来查询账本 L1 P1 调用了链码 S1 来生成提案响应（响应包含了查询结果） A 接收到了提案的响应 更新过程： A 连接到了 P1 且调用了链码 S1 来更新账本 L1 P1 调用了链码 S1 来生成提案响应（账本更新的提案） A 接收到了提案的响应 A 会从所有的响应中创建一笔交易 交易发送给排序节点 O1 进行排序。 区块分发到所有 Peer 节点上。 当 L1 被更新之后，P1 会生成一个事件，该事件会被 A 接收到，来标识这个过程结束了。 一个独立的 Peer 节点目前是不能进行账本更新的，因为其他的 Peer 节点必须首先要同意这个变动（即达成共识）。 因此，Peer 节点会返回给应用程序一个被提案过的更新，这个 Peer 节点会依据其他节点之前的协议来应用这个更新。 通道与节点 通道允许区块链网络中特定的一些 Peer 节点以及应用程序来彼此交互。 组织与节点 有一个工作原则：如果组织不为这个网络贡献他们的资源，这个网络是不会存在的。更关键的是，这个网络会随着这些互相合作的组织提供的资源而增长或者萎缩。 身份与节点Peer 节点会有一个身份信息被分给他们，这是通过一个特定的证书认证机构颁发的数字证书来实现的。 在网络中的每个 Peer 节点都会被所属组织的管理员分配一个数字证书。 当 Peer 节点连接到一个通道的时候，它的数字证书会通过通道 MSP 来识别它的所属组织。 P1 和 P2 具有由 CA1 颁发的身份信息。 通道 C 通过在它的通道配置中的策略来决定来自 CA1 的身份信息应该使用 ORG1.MSP 被关联到 Org1。 在通道配置中的策略会使用 Peer 节点的身份信息来确定它的权利。 关于身份信息和组织的映射是由成员服务提供者（MSP）来提供的，它决定了一个 Peer 节点如何在指定的组织中分配到特定的角色以及得到访问区块链资源的相关权限。 Peer 节点只能被一个组织所有，因此也就只能被关联到一个单独的 MSP。 Peer节点和排序节点一个单独的 Peer 节点不能够由它自己来更新账本——更新需要网络中其他节点的同意。 Peer 节点会请求网络中的其他 Peer 节点来批准这次更新。这个过程被称为共识。 更新账本的应用程序会被引入到一个三阶段的流程，确保 Peer 节点都彼此保持着一致的账本。 在第一个阶段，应用程序会跟背书节点的子集一起工作，其中的每个节点都会向应用程序为提案的账本更新提供背书，但是不会将提案的更新应用到他们的账本副本上。 在第二个阶段，这些分散的背书会被搜集到一起当做交易被打包进区块中。 在最后一个阶段，这些区块会被分发回每个 Peer 节点，在这些 Peer 节点上每笔交易在被应用到 Peer 节点的账本副本之前会被验证。 提案第一阶段只在乎应用程序询问不同组织的背书节点同意链码调用的提案结果。 应用程序会生成一笔交易的提案，它会把这个提案发送给一系列的被要求的节点来获得背书。 每一个背书节点接下来都会独立地使用交易提案来执行链码，以此来生成这个交易提案的响应。 简单地为它提供签名然后将它返回给应用程序。当应用程序接收到有效数量的被签过名的提案响应之后，交易流程中的第一个阶段就结束了。 应用程序 A1 生成了交易 T1 和提案 P 应用程序会将交易及提案发送给通道 C 上的 Peer 节点 P1 和 Peer 节点 P2 P1 使用交易 T1 和 提案 P 来执行链码 S1，这会生成对交易 T1 的响应 R1，它会提供背书 E1。 P2 使用交易 T1 提案 P 执行了链码 S1，这会生成对于交易 T1 的响应 R2，它会提供背书 E2。 应用程序 A1 对于交易 T1 接收到了两个背书响应，称为 E1 和 E2。 Peer 节点通过向提案的响应添加自己的数字签名的方式提供背书，并且使用它的私钥为整个的负载提供签名。 排序和将交易打包到区块排序节点是这个过程的关键——它接收交易，这些交易中包含了来自很多个应用的已经背书过的交易提案，并且将交易排序并打包进区块。 验证和提交在每个 Peer 节点上，区块中的每笔交易都会被验证，以确保它在被提交到账本之前，已经被所有相关的组织一致地背书过了。 排序节点 O1 将区块 B2 分发给了 Peer 节点 P1 和 Peer 节点 P2。 Peer P1 处理了区块 B2，产生了一个会被添加到 P1 的账本 L1 中的新区块。 peer P2 处理了区块 B2，产生了一个会被添加到 P2 的账本 L1 中的新区块。 阶段三是从排序节点将区块分发到所有与它连接的 Peer 节点开始的。Peer 节点会和通道中的排序节点相连，所有跟这个排序节点相连的 Peer 节点将会收到一个新的区块的副本。 不是每个 Peer 节点都需要连接到排序节点——Peer 节点可以使用 gossip 协议将区块的信息发送给其他 Peer 节点，其他 Peer 节点也可以独立地处理这些区块。 链码仅仅需要在背书节点中有效，而不需要在区块链网络的所有部分都要有。 当区块被提交到 Peer 节点的账本的时候，那个 Peer 节点会生成一个合适的事件。 应用程序可以对这些事件类型进行注册，所以在这些事件发生的时候他们能够被通知到。这些通知结束了交易流程的第三以及最后的阶段。 排序节点和共识整个交易处理流程被称为共识，因为所有 Peer 节点在由排序节点提供的流程中对交易的排序及内容都达成了一致。 排序节点理解为这样一些节点，它们从应用程序收集和分发账本更新提案以供 Peer 节点验证并写入账本中。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://peapod.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"Hyperledger Fabric","slug":"Hyperledger-Fabric","permalink":"http://peapod.top/tags/Hyperledger-Fabric/"}],"author":"taweizhong"},{"title":"Hyperledger Fabric 策略","slug":"Hyperledger-Fabric-策略","date":"2022-09-23T09:18:56.000Z","updated":"2022-09-24T02:23:36.000Z","comments":true,"path":"2022/09/23/Hyperledger-Fabric-策略/","link":"","permalink":"http://peapod.top/2022/09/23/Hyperledger-Fabric-%E7%AD%96%E7%95%A5/","excerpt":"","text":"策略策略是一组规则，用来定义如何做出决策和实现特定结果。 Fabric 策略表示成员如何同意或者拒绝网络、通道或者智能合约的变更。 策略是使 Hyperledger Fabric 不同于其他区块链系统的内容之一。 策略决定了那些组织可以访问或者更新 Fabric 网络，并且提供了强制执行这些决策的机制。 实现策略策略实现在 Fabric 网络的不同层次。 系统通道配置网络中必须有至少一个排序服务的排序系统通道，它是第一个被创建的通道。 该通道也包含着谁是排序服务（排序服务组织）以及在网络中交易（联盟组织）的成员。 策略治理着排序服务使用的共识，并定义了新区块如何被创建。 系统通道也治理着联盟中的哪些成员可以创建新通道。 应用通道配置应用 通道 用于向联盟中的组织间提供私有通信机制。 策略治理着从通道中添加和删除成员的能力。 治理着使用 Fabric 链码生命周期在链码定义和提交到通道前需要哪些组织同意。 权限从控制列表ACL 通过将资源和已有策略相关联的方式提供了资源访问配置的能力。 Fabric ACL 的默认集合在 configtx.yaml 文件的 Application: &amp;ApplicationDefaults 部分。 configtx.yaml 中定义的资源列表是 Fabric 当前定义的所有内部资源的完整集合。 智能合约背书策略每一个智能合约都有一个背书策略，该策略指明了需要通道中多少不同组织的成员根据指定智能合约执行和验证交易才能使一笔交易有效。 背书策略定义了必须“背书”（批准）提案执行的组织（的 Peer 节点）。 修改策略它是定义如何更新策略的策略。 策略作用域 系统通道配置为联盟成员提供了创建通道的能力。 应用通道和 ACL 是联盟组织用来从通道中添加或删除成员以及限制通道中智能合约和数据访问的机制。 写策略在 Hyperledger Fabric 中，策略中明确的签名使用 Signature 语法，隐含的签名使用 ImplicitMeta 语法。 签名策略Signature 策略定义了要满足策略就必须签名的特定用户类型，比如 Org1.Peer OR Org2.Peer。 例如，一个策略可以简单表达为使用 AND (Org1, Org2) ，表示满足该策略就同时需要 Org1 中的一个成员和 Org2 中的一个成员的签名。 隐元策略隐元策略只在通道配置上下文中有效，通道配置在配置树策略中是基于分层的层次结构。 应用通道分层的策略结构： 当满足配置层级中它的 Admins 子策略时，就代表也满足了其子策略的子策略条件。 隐元通道配置管理策略（称为 /Channel/Admins）。 在配置树中所有 Admins 策略都引用了的 Admin 子策略。 隐元策略比如 MAJORITY Admins 的主要优势在于当你向通道添加新组织的时候，你不必更新通道策略。 链码的生命周期configtx.yaml 文件中 Application 部分包含了默认的链码生命周期背书策略。 12345678910111213141516171819202122232425Application: &amp;ApplicationDefaults # Organizations is the list of orgs which are defined as participants on # the application side of the network Organizations: # Policies defines the set of policies at this level of the config tree # For Application policies, their canonical path is # /Channel/Application/&lt;PolicyName&gt; Policies: Readers: Type: ImplicitMeta Rule: &quot;ANY Readers&quot; Writers: Type: ImplicitMeta Rule: &quot;ANY Writers&quot; Admins: Type: ImplicitMeta Rule: &quot;MAJORITY Admins&quot; LifecycleEndorsement: Type: ImplicitMeta Rule: &quot;MAJORITY Endorsement&quot; Endorsement: Type: ImplicitMeta Rule: &quot;MAJORITY Endorsement&quot; LifecycleEndorsement 策略控制需要谁 批准链码定义 。 Endorsement 策略是 链码的默认背书策略 。 链码背书策略链码被批准并提交到通道时会指定一个背书策略。 批准阶段没有明确指明背书策略，就默认使用 Endorsement 策略 &quot;MAJORITY Endorsement&quot;。 要想使交易生效就需要大多数不同通道成员（组织）的执行并验证交易。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://peapod.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"Hyperledger Fabric","slug":"Hyperledger-Fabric","permalink":"http://peapod.top/tags/Hyperledger-Fabric/"}],"author":"taweizhong"},{"title":"Hyperledger Fabric MSP","slug":"Hyperledger-Fabric-MSP","date":"2022-09-23T04:46:20.000Z","updated":"2022-09-24T02:23:04.000Z","comments":true,"path":"2022/09/23/Hyperledger-Fabric-MSP/","link":"","permalink":"http://peapod.top/2022/09/23/Hyperledger-Fabric-MSP/","excerpt":"","text":"成员服务提供者（MSP）证书机构通过生成可以用来证实身份的由公钥和私钥形成的键值对来发放认证信息。 MSP是一个可让身份被信任和被网络中其他参与者公认的，而不需要暴露成员的私钥的机制。 MSP将一个身份(信用卡)转换为一个角色(在商店购买东西的能力)。 它给予组织、节点和通道建立MSPs的能力，使其确定谁可以在组织、节点和通道层次上运作。 加入一个需要许可的区块链网络： 拥有一个由网络信任的CA颁发的身份。 成为一个被网络成员认可和认可的 组织 的成员。MSP将身份与组织的成员资格联系在一起。成员资格是通过将成员的公钥添加到组织的MSP来实现的。 将MSP添加到网络上的一个联盟 或者通道。 确保MSP包括在网络中的策略 定义。 MSP通过标识参与者在节点或通道上拥有的特定特权，将身份转换为角色。 MSP域MSP 出现在两个位置： 在参与者节点本地（本地 MSP） 在通道配置中（通道 MSP） 本地MSP为客户端和节点(peer节点和排序节点)定义的。 本地MSPs定义节点的权限。(例如，谁是可以操作节点的peer节点管理员)。 每个节点都必须定义一个本地MSP，它定义了在该级别上谁拥有管理权或参与权。 通道MSP通道MSP在通道层面上定义了管理权和参与权。 本地MSP表现为文件系统上的文件夹结构，而通道MSP则在通道配置中被描述。 通道MSP识别谁在通道层次拥有权限。 每个参与通道的组织都必须为其定义一个MSP。 系统通道MSP包括参与排序服务的所有组织的MSP。 通道MSP也在通道中的每个节点的文件系统上实例化，并通过共识保持同步。 尽管每个节点的本地文件系统上都有每个通道MSP的副本，但从逻辑上讲，通道MSP存在并被维护于通道或网络上。 组织组织是一个逻辑上成员们的管理组。在单个MSP下管理其成员。 以组织的名字为前缀命名MSP。 组织单元（ou）一个组织也可以被划分为多个组织单元，每个单元都有一定的职责。 当CA颁发X.509证书时，证书中的OU字段指定该身份所属的业务流水线。 节点组织单元特殊类型的组织单元，有时称为节点组织单元，可用于授予角色以身份标识。 为了使用节点组织单元角色，通过在MSP目录下的配置文件config.yaml中启用“Node OUs”字段来实现: 1234567891011121314NodeOUs: Enable: true ClientOUIdentifier: Certificate: cacerts/ca.sampleorg-cert.pem OrganizationalUnitIdentifier: client PeerOUIdentifier: Certificate: cacerts/ca.sampleorg-cert.pem OrganizationalUnitIdentifier: peer AdminOUIdentifier: Certificate: cacerts/ca.sampleorg-cert.pem OrganizationalUnitIdentifier: admin OrdererOUIdentifier: Certificate: cacerts/ca.sampleorg-cert.pem OrganizationalUnitIdentifier: orderer MSP有4种节点组织单元角色: client peer admin orderer 联盟中的不同组织可以使用组织单元来区分彼此。在这种情况下，不同的组织必须为其信任链使用相同的根CA和中间CA，并分配OU字段来标识每个组织的成员们。 MSP结构本地MSP文件夹：","categories":[{"name":"区块链","slug":"区块链","permalink":"http://peapod.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"Hyperledger Fabric","slug":"Hyperledger-Fabric","permalink":"http://peapod.top/tags/Hyperledger-Fabric/"}],"author":"taweizhong"},{"title":"Hyperledger Fabric 身份\"","slug":"Hyperledger-Fabric-身份","date":"2022-09-23T04:09:28.000Z","updated":"2022-09-24T02:22:42.000Z","comments":true,"path":"2022/09/23/Hyperledger-Fabric-身份/","link":"","permalink":"http://peapod.top/2022/09/23/Hyperledger-Fabric-%E8%BA%AB%E4%BB%BD/","excerpt":"","text":"身份身份：确定了对资源的确切权限以及对参与者在区块链网络中拥有的信息的访问权限。 一个 MSP 是定义管理该组织有效身份规则的组件。 MSP 将可验证的身份转变为区块链网络的成员 。 Fabric 中默认的 MSP 实现使用 X.509 证书作为身份，采用传统的公钥基础结构（Public Key Infrastructure,PKI）分层模型。 PKI提供身份列表，MSP说哪些是参与网络的给定组织的成员。 PKI公钥基础结构（PKI）是一组互联网技术，可在网络中提供安全通信。 PKI 由向各方发布数字证书的证书授权中心组成。 PKI 有四个关键要素： 数字证书 公钥和私钥 证书授权中心 证书撤销列表 数字证书 数字证书是包含与证书持有者相关的属性的文档。 公钥是在证书中分发的，而私人签名密钥则不是。 只要对方信任证书颁发者，即证书授权中心（CA），密码学就允许 将证书提交给其他人以证明其身份。 CA 安全地保存某些加密信息（CA 的私钥），任何阅读证书的人都可以确定有关 Mary 的信息没有被篡改，它将始终具有 Mary Morris 的特定属性。 授权，公钥和私钥身份验证要求确保交换消息的各方创建特定消息的身份。 “完整性”的消息意味着在其传输期间不能被修改。 密钥之间唯一的数学关系使得私钥在消息上的签名，只有对应公钥在相同的消息上才可以与之匹配。 Mary 使用她的私钥对邮件进行签名。任何使用她的公钥查看签名消息的人都可以验证签名。 证书授权中心人员或节点能够通过由系统信任的机构为其发布的数字身份参与区块链网络。 数字身份：符合 X.509 标准并由证书授权中心（CA）颁发的经加密验证的数字证书。 证书授权中心向不同的参与者颁发证书。 证书由 CA 进行签名，并将参与者的公钥绑定在一起（并且可选是否具有全部属性列表）。 根 CA，中间 CA 和信任链 中间 CA 在跨多个组织颁发证书时提供了巨大的灵活性。 不同的组织可能使用不同的根 CA，或者使用具有不同中间 CA 的相同根 CA，这取决于网络的需求。 Fabric CA是一个私有根 CA 提供者，能够管理具有 X.509 证书形式的 Fabric 参与者的数字身份。 证书撤销列表是 CA 知道由于某些原因而被撤销的证书的引用列表。 当第三方想要验证另一方的身份时，它首先检查颁发 CA 的 CRL 以确保证书尚未被撤销。 MSP 发挥作用的地方——它确定了区块链网络特定组织的成员。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://peapod.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"Hyperledger Fabric","slug":"Hyperledger-Fabric","permalink":"http://peapod.top/tags/Hyperledger-Fabric/"}],"author":"taweizhong"},{"title":"Hyperledger Fabric网络架构","slug":"Hyperledger-Fabric网络架构","date":"2022-09-23T02:16:21.000Z","updated":"2022-09-24T02:22:20.000Z","comments":true,"path":"2022/09/23/Hyperledger-Fabric网络架构/","link":"","permalink":"http://peapod.top/2022/09/23/Hyperledger-Fabric%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/","excerpt":"","text":"区块链网络概念上描述组织以区块链网络的形式进行合作。 概念：区块链网络是一个为应用程序提供账本及智能合约服务的技术基础设施。 多个组织作为一个联盟形成一个网络，权限是由网络最初配置的时候联盟定义的规则实现。 实例网络 R4 被分配作为网络的初始者，它有权设置网络的初始版本。 网络是根据在网络配置 NC4 中指定的规则来进行管理 整个网络由组织 R1 和 R4 管理。 通道 C1 是根据在通道配置 CC1 中指定的规则来管理 排序服务 O4 作为这个网络 N 的一个网络管理员节点，并且使用系统通道。 每个组织都有一个首选的 CA。 创建网络 排序服务 O4 由一个单独的节点组成，是根据一个网络配置 NC4 来进行配置 证书颁发机构 CA4 被用来向管理员和组织 R4 的网络节点分配身份信息。 在定义 网络 N 的时候，第一件事情就是定义一个 排序服务 证书颁发机构CA4，它会被用来给管理者和网络节点颁发证书。 CA 颁发的证书也可以用来为交易提供签名，来表明一个组织对交易的结果进行背书。 每个组织会有一个 CA。 成员服务提供者将证书同成员组织进行匹配。 NC4使用MSP来分配在网络资源上的特殊权利。 个人理解： CA用来证明某一个成员属于那个组织，属于组织层面。 MSP表明某个成员在组织里的定位（如组织内的权限等），属于成员（组织内的成员）层面 X.509 证书被用于客户端应用的交易提案和智能合约的交易响应，来对交易进行数字签名。 添加网络管理员 使组织 R1 也成为了管理员。 R1 和 R4 在网络配置中便具有了相同的权限。 证书颁发机构 CA1 也被添加进来了，他用来标识 R1 组织的用户。 定义联盟 定义联盟 X1 联盟的定义被存储在了网络配置 NC4 为联盟创建通道 联盟 X1 为 R1 和 R2 创建的的通道 C1。 通道通过通道配置 CC1 来进行管理。 通道 C1 为联盟 X1 提供了一个私有的通信机制。 CC1 包含了赋予 R1 和 R2 在通道 C1 上的权利的规则。 被排序服务使用的特殊的系统通道。 节点和账本新增了两个组件，称作 Peer 节点 P1 和账本实例 L1。 物理上 P1 会存储账本 L1 的副本。 P1 和 O4 可以使用通道 C1 来进行通信。 Peer 节点是存储区块链账本副本的网络组件。 L1 会被物理地存储在 P1 上，但是 逻辑上 是存储在通道 C1 上。 CA1 颁发的 X.509 身份信息，它将 P1 和组织 R1 关联了起来。 使用排序 O4将P1 加入通道C1。 通道配置 CC1 来决定 P1 在这个通道中的权限。 个人理解： CA1将P1和R1连接起来。O4将P1和C1连接起来。 CA1：信息验证，CC1权限控制。 app和chaincode 智能合约 S5 被安装在了 P1 上。 组织 R1 中的客户端应用 A1 可以通过 Peer 节点 P1 使用 S5 来访问账本。 应用 A1 能够使用通道 C1 来连接指定的网络资源。 所有的访问都是由一个称为智能合约链码 S5 的特殊程序来管理的。 智能合约被用来帮助生成被分发到网络中每个节点的交易。 智能合约必须被安装，然后在通道中被定义。 作用：智能合约定义了交易逻辑，它控制了在世界状态中包含的一个业务对象的生命周期。 智能合约—&gt;打包—&gt;链码 链码部署到一个区块链网络中。 智能合约：管理交易。 链码：管理着智能合约应该如何被打包部署。 安装链码包组织 R1 中的管理员把S5安装到节点 P1 上。 定义链码链码安装在组织的 Peer 节点上。在一个通道范围内被管理和维护的。 每个组织需要批准一个链码定义，一系列参数来定义在一个通道中链码应该被如何使用。 管理员 R1 必须要批准 S5 的链码定义。 需要有效数量的组织来批准一个链码的定义（默认为大多数）。 R1 的管理员-&gt;提交 S5 的链码定义-&gt;通道 C1 定义提交后,S5 就可以被客户端应用 A1 调用了。 实际上是定义并提交了智能合约的接口到通道，而不是安装了智能合约的实现。 安装智能合约展示了我们是如何将它物理地存储在 Peer 节点上，实例化智能合约展示了我们是如何将它逻辑地存储在通道中。 背书策略链码定义提供的信息中最重要的部分就是背书策略。 它描述了在交易被其他的组织接受并存储在他们的账本副本上之前，哪些组织必须要同意此交易。 只有当 R1 和 R2 对交易进行背书之后，交易才能够被接受并存储到账本 L1 中。 调用智能合约客户端应用是通过发送交易提案给智能合约背书策略所指定的 Peer 的节点方式来调用智能合约的。 交易的提案会作为智能合约的输入 智能合约会使用它来生成一个背书交易响应 Peer 节点返回给客户端应用 完成网络将组织 R2 的基础设施添加到网络中。 生成并接受交易Peer 节点 存储智能合约; 节点只有在安装了智能合约之后才能够运行它 不存; 可以通过连接到通道来获取一个智能合约的接口信息。 带有智能合约的 Peer 节点：帮助生成交易。 所有的 Peer 节点：可以验证并接受或者拒绝交易存入他们的账本 L1 的副本中。 只有安装了智能合约的 Peer 节点才能够参与交易背书的流程。 Peer 节点的类型 提交节点：每个 Peer 节点都是一个提交节点。接收生成的区块，提交到 Peer 节点的账本副本中。 背书节点：安装了智能合约的 Peer 节点都可以作为一个背书节点。智能合约必须要被客户端应用使用，来生成一个被签名的交易响应。 Peer 节点的角色 主节点：负责将交易从排序节点分发到该组织中其他的提交节点。 锚节点：锚节点能够帮助很多不同的跨组织间的通信。 一般都会有一个主节点，至少一个背书节点和一个提交节点。 gossip 协议，可以容纳大量的 Peer 节点来支持这样的拓扑。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://peapod.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"Hyperledger Fabric","slug":"Hyperledger-Fabric","permalink":"http://peapod.top/tags/Hyperledger-Fabric/"}],"author":"taweizhong"},{"title":"Hyperledger Fabric 模型","slug":"Hyperledger-Fabric-模型","date":"2022-09-22T01:59:07.000Z","updated":"2022-09-24T02:21:52.000Z","comments":true,"path":"2022/09/22/Hyperledger-Fabric-模型/","link":"","permalink":"http://peapod.top/2022/09/22/Hyperledger-Fabric-%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"Hyperledger Fabric 模型简介模型： 资产 链码 账本 隐私 成员服务 共识 资产有形（房地产和硬件）到无形资产（合同和知识产权）。 提供使用链码交易来修改资产的功能。 资产在 Hyperledger Fabric 中表示为键值对的集合，状态更改记录为 Channel 账本上的交易。资产可以用二进制或 JSON 格式表示。 链码链码是定义单项或多项资产的软件，和能修改资产的交易指令；换句话说，它是业务逻辑。 强制执行读取或更改键值对或其他状态数据库信息的规则。 账本特点特点： 基于键的查找、范围查询和组合键查询来查询和更新账本； 富查询语言进行只读查询； 查询一个键的账本历史记录（数据溯源）； 交易包括链码读取键&#x2F;值（读集）以及链码写入键&#x2F;值（写集）； 交易包含每个背书节点的签名，并被提交给排序服务； 交易按顺序打包到区块，并被排序服务“分发”到通道上的节点； 节点根据背书策略验证交易并执行策略； 附加一个区块之前，会执行一次版本检查，以确保被读取的资产的状态自链码执行以来未发生更改； 一旦交易被验证并提交，就具有不变性； 一个通道的账本包含一个配置区块，用于定义策略、访问控制列表和其他相关信息； 通道包含MSP的实例，允许从不同的证书颁发机构（CA）生成加密材料 隐私当该通道上的组织子集需要对其交易数据保密时，私有数据集合用于将此数据隔离在私有数据库中，在逻辑上与通道账本分开，只有经授权的组织子集才能访问。 通道在更广泛的网络上保持交易的私密性，而集合则在通道上的组织子集之间保持数据的私密性。 进一步模糊数据：在将交易发送到排序服务并将区块附加到账本之前，可以使用诸如 AES 之类的通用加密算法对链码内的值进行加密（部分或全部）。 成员服务所有参与者都拥有已知的身份。 公钥基础设施（PKI）用于生成与组织、网络组件以及终端用户或客户端应用程序相关联的加密证书。 共识整个交易流程：从提案和背书到排序、验证和提交。 共识被定义为组成区块的一组交易的正确性的闭环验证。 背书策略：规定哪些特定成员必须背书某个交易类别。 系统链码：确保背书策略得到执行和维护。 提交之前，节点通过系统链码确保存在足够的背书，并且来自适当的实体。 共识并不仅仅局限于一批交易的商定顺序；相反，它的首要特征是交易从提案到提交的过程中不断进行核查而附带实现的。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://peapod.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"Hyperledger Fabric","slug":"Hyperledger-Fabric","permalink":"http://peapod.top/tags/Hyperledger-Fabric/"}],"author":"taweizhong"},{"title":"Hyperledger Fabric 简介","slug":"Hyperledger-Fabric-简介","date":"2022-09-22T01:10:34.000Z","updated":"2022-09-22T01:42:56.000Z","comments":true,"path":"2022/09/22/Hyperledger-Fabric-简介/","link":"","permalink":"http://peapod.top/2022/09/22/Hyperledger-Fabric-%E7%AE%80%E4%BB%8B/","excerpt":"","text":"简介比特币和以太坊属于同一类区块链，我们将其归类为公共非许可（Public Permissionless）区块链技术。 Hyperledger Fabric开源的企业级许可分布式账本技术平台。（DLT） Fabric 具有高度模块化和可配置的架构。 支持通用编程语言编写智能合约。 Fabric 平台也是许可的。 支持可插拔的共识协议。 模块化组成： 可插拔的排序服务 排序 广播 可插拔的成员服务提供者 将网络中的实体与加密身份相关联 智能合约（“链码”）隔离运行在容器环境 配置支持多种 DBMS 可插拔的背书和验证策略 许可和非许可非许可：基于“工作量证明（PoW）”的拜占庭容错共识许可： 崩溃容错（CFT）或拜占庭容错（BFT）共识协议 智能合约区块链应用的业务逻辑。关键点： 多个智能合约在网络中同时运行 动态部署 不被信任 执行-排序-验证为了解决顺序执行模型面临的弹性、灵活性、可伸缩性、性能和机密性问题 步骤： 执行交易并背书 共识协议排序 在提交到账本之前，背书策略验证交易 Fabric 在交易顺序达成最终一致前执行交易。 并行执行：每个交易只需要由满足交易的背书策略所必需的节点的子集来执行（背书）。第一阶段消除了任何非确定性。Fabric 是第一个能使用标准编程语言的区块链技术。 隐私和保密零知识证明（Zero Knowledge Proofs，ZKP）。通过其通道架构和私有数据特性实现保密。参与到通道的节点才有权访问智能合约（链码）和交易数据，以此保证了隐私性和保密性。 可插拔共识进行 CFT（崩溃容错）或 BFT（拜占庭容错）的排序。提供了一种基于etcd 库 中 Raft 协议 的 CFT 排序服务的实现。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://peapod.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"Hyperledger Fabric","slug":"Hyperledger-Fabric","permalink":"http://peapod.top/tags/Hyperledger-Fabric/"}],"author":"taweizhong"},{"title":"服务器安装Clash","slug":"服务器安装Clash","date":"2022-09-17T09:58:46.000Z","updated":"2022-09-17T10:30:42.000Z","comments":true,"path":"2022/09/17/服务器安装Clash/","link":"","permalink":"http://peapod.top/2022/09/17/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85Clash/","excerpt":"","text":"Clash安装教程下载地址（https://github.com/Dreamacro/clash） 找到对应的版本复制下载地址. 123456mkdir Clsahwget ‘包的地址’gunzip ‘下载下来的文件’ -d ./Clashcd Clashmv ‘文件名’ clashchmod +x clash 配置订阅信息123cd /Clashsudo wget -O config.yaml [订阅链接]sudo wget -O Country.mmdb https://www.sub-speeder.com/client-download/Country.mmdb 设置系统代理1vim /etc/profile 在最后面添加 12export http_proxy=&quot;http://127.0.0.1:7890&quot;export https_proxy=&quot;http://127.0.0.1:7890&quot; 保存退出后 1source /etc/profile 启动1./clash -d . 实现网络代理的切换首先启动clash 可以看到外部可以访问的端口为9090 记得配置服务器的端口，可以使外部访问9090端口 点击clash.razord.top进行配置 host 设置为服务器的IP，密码可以不用配置。 在代理中切换 在GUI界面中实现配置点击查看配置 clash for linux ，适用于ubuntu 20.04（更新于2021.11.6） - 知乎 (zhihu.com)","categories":[{"name":"实用","slug":"实用","permalink":"http://peapod.top/categories/%E5%AE%9E%E7%94%A8/"}],"tags":[{"name":"clash","slug":"clash","permalink":"http://peapod.top/tags/clash/"}],"author":"taweizhong"},{"title":"BeeGo实现文件的上传与下载","slug":"BeeGo实现文件的上传与下载","date":"2022-09-14T13:41:30.000Z","updated":"2022-09-14T14:11:20.000Z","comments":true,"path":"2022/09/14/BeeGo实现文件的上传与下载/","link":"","permalink":"http://peapod.top/2022/09/14/BeeGo%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/","excerpt":"","text":"beego实现文件的上传和下载文件的上传html的处理 1234&lt;form id=&quot;&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input id=&quot;myfile&quot; name=&quot;myfile&quot; type=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;保存&quot; /&gt;&lt;/form&gt; 控制器处理 123456789type ServiceController struct&#123; beego.Controller&#125;func (c *ServiceController) Post()&#123; f, h, _ := this.GetFile(&quot;myfile&quot;) //获取上传的文件 path := h.Filename //文件目录 f.Close() //关闭上传的文件 this.SaveToFile(&quot;myfile&quot;, path) &#125; 文件的下载123456789type FileOptDownloadController struct &#123; beego.Controller&#125;func (this *FileOptDownloadController) Get() &#123; //第一个参数是文件的地址，第二个参数是下载显示的文件的名称 this.Ctx.Output.Download(&quot;static/img/1.jpg&quot;,&quot;tu1.jpg&quot;)&#125;","categories":[{"name":"Web","slug":"Web","permalink":"http://peapod.top/categories/Web/"}],"tags":[{"name":"beego","slug":"beego","permalink":"http://peapod.top/tags/beego/"}],"author":"taweizhong"},{"title":"BeeGo教程","slug":"BeeGo教程","date":"2022-09-13T08:36:10.000Z","updated":"2022-09-13T12:42:56.000Z","comments":true,"path":"2022/09/13/BeeGo教程/","link":"","permalink":"http://peapod.top/2022/09/13/BeeGo%E6%95%99%E7%A8%8B/","excerpt":"","text":"Beego 框架1.beego框架 工作流程beego框架是一个使用Go语言快速开发API、Web及后端服务等各种应用的MVC框架。beego是一个完整的MVC框架，包括controller、model以及view等MVC必备模板。 HTTP请求从main函数进入框架 解析url路由，确定执行那个控制器 执行前请求过滤器 执行控制器 执行请求后的过滤器 输出结果 2.beego框架 安装 设置代理 12$ go env -w GO111MODULE=on$ go env -w GOPROXY=https://goproxy.cn,direct 安装beego和bee（项目工具） 1$ go get github.com/beego/beego 使用bee创建项目 1bee new 项目名称 项目结构 运行项目 1bee run 3.框架使用使用beego开发go语言项目，需要编写控制器、业务模型以及view等模块。 控制器controller 1234567891011121314// 定义一个控制器结构体// 一般一个模块定义一个控制器type MainController struct &#123; beego.Controller&#125;// 覆盖beego.Controller的Get方法，用于处理 RESTful 请求中的 get 请求// beego.Controller 默认支持多种 RESTful方法，例如：Post、Put、Delete等func (c *MainController) Get() &#123; // Data是继承过来的属性，是 map 类型，可以保存任意类型数据，主要用于保存请求响应数据 c.Data[&quot;Website&quot;] = &quot;&quot; c.Data[&quot;Email&quot;] = &quot;&quot; // 设置需要渲染的模板文件，框架会去 views 目录查找这个模板文件 c.TplName = &quot;index.html&quot;&#125; 设置路由Url 123456func init() &#123; // 使用 beego.Router 函数，注册路由规则。 // 第一个参数是url路由，第二个参数是控制器 // 这里的意思就是将访问 / 这个url的请求，交给controllers.MainController控制器处理。 beego.Router(&quot;/&quot;, &amp;controllers.MainController&#123;&#125;)&#125; 路由规则说明： ​ 只是定义了Url 由哪个控制器执行，但是没有说明 Url 请求由控制器的那个函数执行，一个控制器可以包含多个函数。 编写model业务逻辑 定义表结构 123456CREATE TABLE `users` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;自增ID&#x27;, `username` varchar(30) NOT NULL COMMENT &#x27;账号&#x27;, `password` varchar(100) NOT NULL COMMENT &#x27;密码&#x27;, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 初始化数据库连接 1234567891011121314151617181920212223package mainimport ( _ &quot;codebaoku/routers&quot; &quot;github.com/astaxie/beego&quot; &quot;github.com/astaxie/beego/orm&quot; _ &quot;github.com/go-sql-driver/mysql&quot;)func init() &#123; // 这里注册一个default默认数据库，数据库驱动是mysql. // 第三个参数是数据库dsn, 配置数据库的账号密码，数据库名等参数 // dsn参数说明： // username - mysql账号 // password - mysql密码 // db_name - 数据库名 // 127.0.0.1:3306 - 数据库的地址和端口 orm.RegisterDataBase(&quot;default&quot;, &quot;mysql&quot;, &quot;username:password@tcp(主机IP:端口号)/db_name?charset=utf8&quot;)&#125;func main() &#123; beego.Run()&#125; 创建model 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 定义User模型，绑定users表结构, 其实就是用来保存sql查询结果。type User struct &#123; Id int Username string Password string&#125;// 定义User 模型绑定那个表？func (u *User) TableName() string &#123; // 返回mysql表名 return &quot;users&quot;&#125;//初始化函数，可以用来向orm注册modelfunc init() &#123; // 向orm注册user模型 orm.RegisterModel(&amp;User&#123;&#125;)&#125;//初始化函数，可以用来向orm注册modelfunc init() &#123; // 向orm注册user模型 orm.RegisterModel(&amp;User&#123;&#125;)&#125;// 根据id查询用户信息func GetUserById(id int) *User &#123; if id == 0 &#123; return nil &#125; // 创建orm对象, 后面都是通过orm对象操作数据库 o := orm.NewOrm() // 初始化一个User模型对象 user := User&#123;&#125; // 设置查询参数 user.Id = id // 调用Read方法，根据user设置的参数，查询一条记录，结果保存到user结构体变量中 // 默认是根据主键进行查询 // 等价sql： SELECT `id`, `username`, `password` FROM `users` WHERE `id` = 1 err := o.Read(&amp;user) // 检测查询结果， if err == orm.ErrNoRows &#123; // 找不到记录 return nil &#125; else if err == orm.ErrMissPK &#123; // 找不到住建 return nil &#125; return &amp;user&#125; 控制器调用model 12345678910111213func (c *MainController) Get() &#123; c.Data[&quot;Website&quot;] = &quot;codebaoku.com&quot; c.Data[&quot;Email&quot;] = &quot;go@codebaoku.com&quot; // 调用model，查询用户id为1 的用户信息 user := models.GetUserById(1) // 然后将user数据保存到Data中, 将参数传给后面的 views 视图模板处理 c.Data[&quot;user&quot;] = user // 使用新的视图模板user.tpl c.TplName = &quot;user.tpl&quot;&#125; 编写view视图 项目打包 使用 bee 工具打包，bee 工具可以一键将项目需要的相关文件一起打包成一个压缩包，只需要到线上解压即可。 1bee pack 参数配置beego 默认使用了 INI 格式解析配置文件，通常在项目中会存在很多系统参数、业务参数配置，这些参数通常都是通过配置文件进行配置，而且不是写死在代码里面。 提示：修改配置文件后，需要重启应用，配置才生效，即使使用bee run运行项目也得重启。 系统参数 1234567# 这是注释#应用名称appname = codebaoku#http 服务端口httpport = 8080#运行模式，常用的运行模式有dev, test, prodrunmode = dev 参数名 默认值 说明 AppName beego 应用名 RunMode dev 程序运行模式，常用模式有dev、test、prod，一般用于区分不同的运行环境 RouterCaseSensitive true 是否路由忽略大小写匹配 ServerName beego beego 服务器默认在请求的时候输出 server 头的值。 RecoverPanic true 是否异常恢复，默认值为 true，即当应用出现异常的情况，通过 recover 恢复回来，而不会导致应用异常退出。 EnableGzip false 是否开启 gzip 支持 MaxMemory 64M 文件上传默认内存缓存大小，单位是字节 AutoRender true 是否模板自动渲染，对于 API 类型的应用，应用需要把该选项设置为 false，不需要渲染模板。 StaticDir static 静态文件目录设置 ViewsPath views 模板路径 Graceful false 是否开启热升级，默认是 false，关闭热升级。 ServerTimeOut 0 设置 HTTP 的超时时间，默认是 0，不超时。 HTTPAddr 应用监听地址，默认为空，监听所有的网卡 IP。 HTTPPort 8080 应用监听端口 EnableHTTPS false 是否启用 HTTPS，默认是 false 关闭。当需要启用时，先设置 EnableHTTPS &#x3D; true，并设置 HTTPSCertFile 和 HTTPSKeyFile HTTPSAddr https应用监听地址，默认为空，监听所有的网卡 IP。 HTTPSPort 10443 https应用监听端口 HTTPSCertFile 开启 HTTPS 后，ssl 证书路径 HTTPSKeyFile 开启 HTTPS 之后，SSL 证书 keyfile 的路径。 EnableAdmin false 是否开启进程内监控模块，默认 false 关闭。 AdminAddr localhost 监控程序监听的地址。 AdminPort 8088 监控程序监听的地址。 SessionOn false session 是否开启 SessionProvider memory session 的引擎， 详情参考session章节的教程 SessionName beegosessionID 存在客户端的 cookie 名称。 SessionGCMaxLifetime 3600 session 过期时间, 单位秒。 SessionProviderConfig 配置信息，根据不同的session引擎设置不同的配置信息，详细的配置请参考session章节的教程 SessionCookieLifeTime 3600 session 默认存在客户端的 cookie 的时间, 单位秒。 SessionDomain session cookie 存储域名。 自定义参数 可以自定义配置，然后通过beego.AppConfig对象的函数读取配置。 12345# 下面是关于mysql数据库的配置参数mysql_user = &quot;root&quot;mysql_password = &quot;123456&quot;mysql_host = &quot;127.0.0.1:3306&quot;mysql_dbname = &quot;codebaoku&quot; 读取配置代码: 1234beego.AppConfig.String(&quot;mysql_user&quot;)beego.AppConfig.String(&quot;mysql_password&quot;)beego.AppConfig.String(&quot;mysql_host&quot;)beego.AppConfig.String(&quot;mysql_dbname&quot;)","categories":[{"name":"Web","slug":"Web","permalink":"http://peapod.top/categories/Web/"}],"tags":[{"name":"beego","slug":"beego","permalink":"http://peapod.top/tags/beego/"}],"author":"taweizhong"},{"title":"匿名函数用作回调函数","slug":"匿名函数用作回调函数","date":"2022-09-09T07:32:30.000Z","updated":"2022-09-13T09:11:56.000Z","comments":true,"path":"2022/09/09/匿名函数用作回调函数/","link":"","permalink":"http://peapod.top/2022/09/09/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E7%94%A8%E4%BD%9C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/","excerpt":"","text":"匿名函数用作回调函数123456789101112131415package mainimport &quot;fmt&quot;func fun(list []int, f func(int))&#123; for _, v := range list &#123; f(v) &#125;&#125;func main() &#123; fun([]int&#123;1, 2, 3, 4, 5&#125;, func(n int) &#123; fmt.Printf(&quot;n: %v\\n&quot;, n) &#125;)&#125; 先执行fun()函数 在执行f(v)的时候回调 传值的匿名函数。会将参数v的值传递给匿名函数的形参，在你匿名函数实现打印。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://peapod.top/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://peapod.top/tags/Go/"}],"author":"taweizhong"},{"title":"Go设计模式","slug":"go工厂模式","date":"2022-09-09T00:54:08.000Z","updated":"2022-09-11T00:43:56.000Z","comments":true,"path":"2022/09/09/go工厂模式/","link":"","permalink":"http://peapod.top/2022/09/09/go%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"Go 设计模式工厂设计模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package maintype an interface&#123; eat() call()&#125;type cat struct&#123; name string&#125;type dog struct&#123; name string&#125;func (*cat)eat()&#123; fmt.Println(&quot;cat eat&quot;)&#125;func (*cat)call()&#123; fmt.Println(&quot;cat call&quot;)&#125;func (*dog)eat()&#123; fmt.Println(&quot;dog eat&quot;)&#125;func (*dog)call()&#123; fmt.Println(&quot;dog call&quot;)&#125;func fun(i int) an &#123; if i == 1 &#123; return &amp;cat&#123;&#125; &#125; else &#123; return &amp;dog&#123;&#125; &#125;&#125;// 多态 向上转型func main()&#123; cat := fun(1) cat.eat() cat.call() dog := fun(2) dog.eat() dog.call()&#125;``` &gt; 将实现接口的对象赋值与接口变量### 单例设计模式 一个类只有一个对象实例```gopackage mainimport ( &quot;fmt&quot; &quot;sync&quot;)type Sing interface &#123; do()&#125;type some struct &#123;&#125;func (*some) do() &#123; fmt.Println(&quot;do some&quot;)&#125;var ( once sync.Once s *some)func Fun() Sing &#123; once.Do( func() &#123; s = &amp;some&#123;&#125; &#125;, ) return s&#125;func main() &#123; s1 := Fun() fmt.Printf(&quot;s1: %p\\n&quot;, s1) s2 := Fun() fmt.Printf(&quot;s1: %p\\n&quot;, s2)&#125; 抽象工厂模式构建者模式","categories":[{"name":"笔记","slug":"笔记","permalink":"http://peapod.top/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://peapod.top/tags/Go/"}],"author":"taweizhong"},{"title":"部署测试","slug":"部署测试","date":"2022-09-08T12:21:54.000Z","updated":"2022-09-08T12:46:48.000Z","comments":true,"path":"2022/09/08/部署测试/","link":"","permalink":"http://peapod.top/2022/09/08/%E9%83%A8%E7%BD%B2%E6%B5%8B%E8%AF%95/","excerpt":"","text":"这是一个测试文件","categories":[],"tags":[{"name":"测试","slug":"测试","permalink":"http://peapod.top/tags/%E6%B5%8B%E8%AF%95/"}],"author":"taweizhong"},{"title":"Hello World","slug":"hello-world","date":"2022-09-08T07:27:58.000Z","updated":"2022-09-08T07:27:58.000Z","comments":true,"path":"2022/09/08/hello-world/","link":"","permalink":"http://peapod.top/2022/09/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"说明","slug":"说明","permalink":"http://peapod.top/categories/%E8%AF%B4%E6%98%8E/"}],"tags":[{"name":"说明","slug":"说明","permalink":"http://peapod.top/tags/%E8%AF%B4%E6%98%8E/"}],"author":"taweizhong"},{"title":"","slug":"Gin框架","date":"2022-09-05T13:45:23.000Z","updated":"2022-09-05T13:45:23.000Z","comments":true,"path":"2022/09/05/Gin框架/","link":"","permalink":"http://peapod.top/2022/09/05/Gin%E6%A1%86%E6%9E%B6/","excerpt":"","text":"第一个Gin项目12345678package mainimport ( &quot;github.com/gin-gonic/gin&quot;)func main()&#123; e := gin.Default() e.Run()//默认端口号8080&#125; Gin处理form表单go程序1234567891011121314151617181920212223package mainimport ( &quot;github.com/gin-gonic/gin&quot;)func gologin(c *gin.Context)&#123; c.HTML(200, &quot;login.html&quot;, nil)&#125;func login(c *gin.Context)&#123; username := c.PostForm(&quot;username&quot;) password := c.PostForm(&quot;password&quot;) c.HTML(200, &quot;index.html&quot;, gin.H&#123; &quot;username&quot;: username, &quot;password&quot;: password, &#125;)&#125;func main()&#123; e := gin.Default() e.Static(&quot;assets&quot;, &quot;./assets&quot;) e.LoadHTMLGlob(&quot;tempates/*&quot;) e.GET(&quot;/login&quot;, gologin) e.POST(&quot;/login&quot;, login) e.Run()&#125; index.html1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;主页&lt;/h1&gt; &#123;&#123;.name&#125;&#125; &#123;&#123;.password&#125;&#125;&lt;/body&gt;&lt;/html&gt; login.html123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./assets/css/login.css&quot;&gt; &lt;title&gt;login&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;form-container&quot;&gt; &lt;div class=&quot;formleft&quot;&gt; &lt;img src=&quot;./assets/img/touxiang.png&quot;&gt; &lt;/div&gt; &lt;div class=&quot;formright&quot;&gt; &lt;h1&gt;欢迎回来&lt;/h1&gt; &lt;p class=&quot;py-1&quot;&gt;请先登录&lt;/p&gt; &lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt; &lt;label&gt; &lt;p&gt;用户名&lt;/p&gt; &lt;input type=&quot;text&quot; name=&quot;user&quot; class=&quot;user-input&quot;&gt; &lt;/label&gt; &lt;label&gt; &lt;p&gt;密码&lt;/p&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; class=&quot;pw-input&quot;&gt; &lt;/label&gt; &lt;button class=&quot;login&quot; type=&quot;submit&quot;&gt;登录&lt;/button&gt; &lt;/form&gt; &lt;a href=&quot;./register&quot;&gt;&lt;button class=&quot;qiehuan&quot; type=&quot;submit&quot;&gt;注册&lt;/button&gt;&lt;/button&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 当有多选框时，使用c.PostFormArray(&quot;name&quot;)函数得到参数数组。 Gin获取请求参数GET请求参数12345678910111213141516package mainimport ( &quot;github.com/gin-gonic/gin&quot;)func login(c *gin.Context)&#123; key := c.Query(&quot;wd&quot;) // value := c.DefaultQuery(&quot;wd&quot;, &quot;世界&quot;) 查询不到用默认值 c.String(200, key)&#125;func main()&#123; e := gin.Default() e.GET(&quot;/login&quot;, login) e.Run()&#125; POST请求参数12345func fun(c *gin.Context)&#123; username := c.PostForm(&quot;username&quot;) password := c.DefaultPostForm(&quot;password&quot;) // 查询不到用默认值 c.String(200, username)&#125; 路径参数12345678910111213141516package mainimport ( &quot;github.com/gin-gonic/gin&quot;)func login(c *gin.Context)&#123; s := c.Param(&quot;username&quot;) c.String(200, s)&#125;func main()&#123; e := gin.Default() // localhost:8080/login/taweizhong e.GET(&quot;/login/:username&quot;, login) e.Run()&#125; Gin数据绑定POST和GET参数绑定123456789101112131415161718192021package mainimport &quot;github.com/gin-gonic/gin&quot;type User struct&#123; Uaername string `form:&quot;username&quot;` Password string `form:&quot;password&quot;`&#125;func login(c *gin.Context)&#123; var user User c.ShouldBind(&amp;user) // form表单绑定结构体 c.String(200, &quot;User:%s&quot;, user)&#125;func main() &#123; e := gin.Default() // localhost:8080/login?username=taweizhong&amp;password=111 可以绑定查询参数 e.POST(&quot;/login&quot;, login) e.Run()&#125; 路径绑定123456789101112131415161718192021package mainimport ( &quot;github.com/gin-gonic/gin&quot;)type User struct&#123; Uaername string `uri:&quot;username&quot;` Password string `uri:&quot;password&quot;`&#125;func login(c *gin.Context)&#123; var user User c.ShouldBindUri(&amp;user) c.String(200, &quot;User:%s&quot;, user)&#125;func main()&#123; e := gin.Default() // localhost:8080/login/taweizhong/111 e.GET(&quot;/login/:username/:password&quot;, login) e.Run()&#125; Gin访问静态文件和模板文件1234567891011121314151617181920212223package mainimport ( &quot;github.com/gin-gonic/gin&quot;)func gologin(c *gin.Context)&#123; c.HTML(200, &quot;login.html&quot;, nil)&#125;func login(c *gin.Context)&#123; username := c.PostForm(&quot;username&quot;) password := c.PostForm(&quot;password&quot;) c.HTML(200, &quot;index.html&quot;, gin.H&#123; &quot;username&quot;: username, &quot;password&quot;: password, &#125;)&#125;func main()&#123; e := gin.Default() e.Static(&quot;/assets&quot;, &quot;./assets&quot;) e.LoadHTMLGlob(&quot;tempates/*&quot;) e.GET(&quot;/login&quot;, gologin) e.POST(&quot;/login&quot;, login) e.Run()&#125; e.Static(&quot;/assets&quot;, &quot;./assets&quot;)读取css和js等静态文件 e.LoadHTMLGlob(&quot;tempates/*&quot;)读取html等模板文件 cookie123456789101112131415161718package mainimport &quot;github.com/gin-gonic/gin&quot;func login(c *gin.Context) &#123; s, err := c.Cookie(&quot;username&quot;) if err != nil &#123; s = &quot;taweizhong&quot; c.SetCookie(&quot;username&quot;, s, 60*60, &quot;/&quot;, &quot;localhost&quot;, false, true) //cookie的名称 值 存活时间 路径 域 安全访问 是否是HTTP &#125; c.String(200, &quot;test&quot;)&#125;func main() &#123; e := gin.Default() e.GET(&quot;/login&quot;, login) e.Run()&#125; session123456789101112131415161718192021222324252627282930package mainimport ( &quot;fmt&quot; &quot;github.com/gin-contrib/sessions&quot; &quot;github.com/gin-contrib/sessions/cookie&quot; &quot;github.com/gin-gonic/gin&quot;)func login(c *gin.Context) &#123; sessions := sessions.Default(c) fmt.Printf(&quot;sessions:----------- %v\\n&quot;, sessions) S := sessions.Get(&quot;name&quot;) fmt.Printf(&quot;S:---------- %v\\n&quot;, S) if sessions.Get(&quot;hello&quot;) != &quot;world&quot;&#123; sessions.Set(&quot;hello&quot;, &quot;world&quot;) sessions.Save() &#125; fmt.Printf(&quot;sessions:------- %v\\n&quot;, sessions)&#125;func main() &#123; e := gin.Default() store := cookie.NewStore([]byte(&quot;1&quot;)) e.Use(sessions.Sessions(&quot;name&quot;, store)) e.GET(&quot;/login&quot;, login) e.Run()&#125;","categories":[],"tags":[]},{"title":"Gin访问静态文件和模板文件","slug":"Gin访问静态文件和模板文件","date":"2022-09-05T03:26:27.000Z","updated":"2022-09-07T03:47:52.000Z","comments":true,"path":"2022/09/05/Gin访问静态文件和模板文件/","link":"","permalink":"http://peapod.top/2022/09/05/Gin%E8%AE%BF%E9%97%AE%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E5%92%8C%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6/","excerpt":"","text":"Gin访问静态文件和模板文件1234567891011121314151617181920212223package mainimport ( &quot;github.com/gin-gonic/gin&quot;)func gologin(c *gin.Context)&#123; c.HTML(200, &quot;login.html&quot;, nil)&#125;func login(c *gin.Context)&#123; username := c.PostForm(&quot;username&quot;) password := c.PostForm(&quot;password&quot;) c.HTML(200, &quot;index.html&quot;, gin.H&#123; &quot;username&quot;: username, &quot;password&quot;: password, &#125;)&#125;func main()&#123; e := gin.Default() e.Static(&quot;/assets&quot;, &quot;./assets&quot;) e.LoadHTMLGlob(&quot;tempates/*&quot;) e.GET(&quot;/login&quot;, gologin) e.POST(&quot;/login&quot;, login) e.Run()&#125; e.Static(&quot;/assets&quot;, &quot;./assets&quot;)读取css和js等静态文件 e.LoadHTMLGlob(&quot;tempates/*&quot;)读取html等模板文件","categories":[{"name":"Web","slug":"Web","permalink":"http://peapod.top/categories/Web/"}],"tags":[{"name":"Gin","slug":"Gin","permalink":"http://peapod.top/tags/Gin/"}],"author":"taweizhong"},{"title":"Gin数据绑定","slug":"Gin数据绑定","date":"2022-09-05T03:26:14.000Z","updated":"2022-09-07T03:49:06.000Z","comments":true,"path":"2022/09/05/Gin数据绑定/","link":"","permalink":"http://peapod.top/2022/09/05/Gin%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/","excerpt":"","text":"Gin数据绑定POST和GET参数绑定123456789101112131415161718192021package mainimport &quot;github.com/gin-gonic/gin&quot;type User struct&#123; Uaername string `form:&quot;username&quot;` Password string `form:&quot;password&quot;`&#125;func login(c *gin.Context)&#123; var user User c.ShouldBind(&amp;user) // form表单绑定结构体 c.String(200, &quot;User:%s&quot;, user)&#125;func main() &#123; e := gin.Default() // localhost:8080/login?username=taweizhong&amp;password=111 可以绑定查询参数 e.POST(&quot;/login&quot;, login) e.Run()&#125; 路径绑定123456789101112131415161718192021package mainimport ( &quot;github.com/gin-gonic/gin&quot;)type User struct&#123; Uaername string `uri:&quot;username&quot;` Password string `uri:&quot;password&quot;`&#125;func login(c *gin.Context)&#123; var user User c.ShouldBindUri(&amp;user) c.String(200, &quot;User:%s&quot;, user)&#125;func main()&#123; e := gin.Default() // localhost:8080/login/taweizhong/111 e.GET(&quot;/login/:username/:password&quot;, login) e.Run()&#125;","categories":[{"name":"Web","slug":"Web","permalink":"http://peapod.top/categories/Web/"}],"tags":[{"name":"Gin","slug":"Gin","permalink":"http://peapod.top/tags/Gin/"}],"author":"taweizhong"},{"title":"Gin获取请求参数","slug":"Gin获取请求参数","date":"2022-09-05T03:25:57.000Z","updated":"2022-09-07T03:48:40.000Z","comments":true,"path":"2022/09/05/Gin获取请求参数/","link":"","permalink":"http://peapod.top/2022/09/05/Gin%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0/","excerpt":"","text":"Gin获取请求参数GET请求参数12345678910111213141516package mainimport ( &quot;github.com/gin-gonic/gin&quot;)func login(c *gin.Context)&#123; key := c.Query(&quot;wd&quot;) // value := c.DefaultQuery(&quot;wd&quot;, &quot;世界&quot;) 查询不到用默认值 c.String(200, key)&#125;func main()&#123; e := gin.Default() e.GET(&quot;/login&quot;, login) e.Run()&#125; POST请求参数12345func fun(c *gin.Context)&#123; username := c.PostForm(&quot;username&quot;) password := c.DefaultPostForm(&quot;password&quot;) // 查询不到用默认值 c.String(200, username)&#125; 路径参数12345678910111213141516package mainimport ( &quot;github.com/gin-gonic/gin&quot;)func login(c *gin.Context)&#123; s := c.Param(&quot;username&quot;) c.String(200, s)&#125;func main()&#123; e := gin.Default() // localhost:8080/login/taweizhong e.GET(&quot;/login/:username&quot;, login) e.Run()&#125;","categories":[{"name":"Web","slug":"Web","permalink":"http://peapod.top/categories/Web/"}],"tags":[{"name":"Gin","slug":"Gin","permalink":"http://peapod.top/tags/Gin/"}],"author":"taweizhong"},{"title":"Gin处理form表单","slug":"Gin处理form表单","date":"2022-09-05T03:25:22.000Z","updated":"2023-12-16T09:25:10.000Z","comments":true,"path":"2022/09/05/Gin处理form表单/","link":"","permalink":"http://peapod.top/2022/09/05/Gin%E5%A4%84%E7%90%86form%E8%A1%A8%E5%8D%95/","excerpt":"","text":"Gin处理form表单go程序1234567891011121314151617181920212223package mainimport ( &quot;github.com/gin-gonic/gin&quot;)func gologin(c *gin.Context)&#123; c.HTML(200, &quot;login.html&quot;, nil)&#125;func login(c *gin.Context)&#123; username := c.PostForm(&quot;username&quot;) password := c.PostForm(&quot;password&quot;) c.HTML(200, &quot;index.html&quot;, gin.H&#123; &quot;username&quot;: username, &quot;password&quot;: password, &#125;)&#125;func main()&#123; e := gin.Default() e.Static(&quot;assets&quot;, &quot;./assets&quot;) e.LoadHTMLGlob(&quot;tempates/*&quot;) e.GET(&quot;/login&quot;, gologin) e.POST(&quot;/login&quot;, login) e.Run()&#125; index.html1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;主页&lt;/h1&gt; &#123;&#123;.name&#125;&#125; &#123;&#123;.password&#125;&#125;&lt;/body&gt;&lt;/html&gt; login.html123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./assets/css/login.css&quot;&gt; &lt;title&gt;login&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;form-container&quot;&gt; &lt;div class=&quot;formleft&quot;&gt; &lt;img src=&quot;./assets/img/touxiang.png&quot;&gt; &lt;/div&gt; &lt;div class=&quot;formright&quot;&gt; &lt;h1&gt;欢迎回来&lt;/h1&gt; &lt;p class=&quot;py-1&quot;&gt;请先登录&lt;/p&gt; &lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt; &lt;label&gt; &lt;p&gt;用户名&lt;/p&gt; &lt;input type=&quot;text&quot; name=&quot;user&quot; class=&quot;user-input&quot;&gt; &lt;/label&gt; &lt;label&gt; &lt;p&gt;密码&lt;/p&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; class=&quot;pw-input&quot;&gt; &lt;/label&gt; &lt;button class=&quot;login&quot; type=&quot;submit&quot;&gt;登录&lt;/button&gt; &lt;/form&gt; &lt;a href=&quot;./register&quot;&gt;&lt;button class=&quot;qiehuan&quot; type=&quot;submit&quot;&gt;注册&lt;/button&gt;&lt;/button&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 当有多选框时，使用c.PostFormArray(&quot;name&quot;)函数得到参数数组。","categories":[{"name":"Web","slug":"Web","permalink":"http://peapod.top/categories/Web/"}],"tags":[{"name":"Gin","slug":"Gin","permalink":"http://peapod.top/tags/Gin/"}],"author":"taweizhong"},{"title":"","slug":"css","date":"2022-08-31T09:04:27.000Z","updated":"2022-08-31T09:04:27.000Z","comments":true,"path":"2022/08/31/css/","link":"","permalink":"http://peapod.top/2022/08/31/css/","excerpt":"","text":"css选择器通用选择器通用选择器用星号*表示，它不匹配某个特定的 HTML 元素，而是匹配 HTML 文档中的每个元素。在开发中，我们通常使用通用选择器来清除 HTML 元素中默认的内外边距。 1234* &#123; margin: 0 auto; 设置一个元素所有外边距的宽度 padding: 0; 内边距&#125; 标签选择器标签选择器可以通过具体的标签名称来匹配文档内所有同名的标签。 123p &#123; color: blue;&#125; ID选择器ID 选择器用来匹配 HTML 文档中具有指定 ID 属性的标签，ID 选择器的定义需要用到井号#，后面紧跟 ID 属性的值。 123#nav &#123; color: red;&#125; 类选择器根据标签的 class 属性匹配具体的 HTML 标签，所有符合条件的标签都会根据选择器内的样式进行格式化。类选择器的定义需要用到一个英文的句号.，后面紧跟 class 属性的值。 1234567891011121314151617.black &#123; color: black;&#125;p.black &#123; color: black;&#125;.info &#123; font-weight:bold;&#125;.selected &#123; color: red;&#125;.info.selected &#123; background: blue;&#125;多类选择器 后代选择器123ul li a &#123; text-decoration: none;&#125; background 背景background-color设置元素的背景颜色； 值 描述 color_name 使用具体颜色名称为元素设置背景颜色（例如 red） hex_number 使用十六进制码为元素设置背景颜色（例如 #ff0000） rgb_number 使用 rgb() 函数为元素设置背景颜色（例如 rgb(255,0,0)） transparent 默认值，设置背景颜色为透明，大多数情况下我们并不会用到它。但如果您不希望某个元素拥有背景颜色，或者不希望用户对浏览器的设置（比如开启夜间模式、护眼模式）影响到您的设计，那么就可以使用 transparent 来将颜色设置为透明的 inherit 从父元素继承对背景颜色的设置 background-image设置元素的背景图像； 值 描述 url(‘URL’) 指向图像的路径，可以将 url() 看作是一个函数，括号中的 URL 为图像的具体路径 none 默认值，不显示背景图像 inherit 从父元素继承背景图像的设置 background-repeat控制背景图像是否重复； 值 描述 repeat 默认值，背景图像将在垂直方向和水平方向上重复 repeat-x 背景图像仅在水平方向上重复 repeat-y 背景图像仅在垂直方向上重复 no-repeat 背景图像仅显示一次，不在任何方向上重复 inherit 从父元素继承 background-repeat 属性的设置 background-attachment控制背景图像是否跟随窗口滚动； 值 描述 scroll 默认值，背景图像随着页面元素的滚动而移动 fixed 当页面的其余部分滚动时，背景图像固定不动 inherit 从父元素继承 background-attachment 属性的设置 background-size设置背景图像的尺寸； 值 描述 xpos ypos 使用像素（px）或其它 CSS 单位来设置背景图像的高度和宽度，xpos 表示宽度，ypos 表示高度，如果只设置第一个值，那么第二个值将被设置为默认值 auto（自动） x% y% 使用百分比表示背景图像相对于所在元素宽度与高度的百分比，x% 表示宽度，y% 表示高度，如果只设置第一个值，那么第二个值将被设置为默认值 auto（自动） cover 保持背景图像的横纵比例并将图像缩放至足够大，使背景图像可以完全覆盖元素所在的区域，这么做可能会导致背景图像的某些部分超出元素区域而无法显示 contain 保持背景图像的横纵比例并将图像缩放至足够大，使背景图像可以完整的显示在元素所在区域，背景图像可能无法完全覆盖整个元素区域 background-position设置背景图像的起始位置 值 描述 left top（左上）、 left center（左中）、 left bottom（左下）、 right top（右上）、 right center（右中）、 right bottom（右下）、 center top（中上）、 center center（居中）、 center bottom（中下） 使用一些关键词表示背景图像的位置，如果您仅设置第一个关键词，那么第二个将默认为 center x% y% 使用百分比表示背景图像距离元素左上角的距离，x% 为水平方向，y% 为垂直方向，左上角为 0% 0%，右下角是 100% 100%，如果您仅设置第一个值，那么另一个值将是 50%，默认值为 0% 0% xpos ypos 使用像素（px）或者其它 CSS 单位表示背景图像距离元素左上角的距离，xpos 为水平方向，ypos 为垂直方向，左上角为 0px 0px，右下角视元素的尺寸而定，百分比和单位的形式可以混用，如果您仅设置第一个值，那么另一个值将默认为 50% CSS字体样式（font） font-family：设置字体； font-style：设置字体的风格，例如倾斜、斜体等； font-weight：设置字体粗细； font-size：设置字体尺寸； font-variant：将小写字母转换为小型大写字母； font-stretch：对字体进行伸缩变形（使用较少，并且主流浏览器都不支持）； font：字体属性的缩写，可以在一个声明中设置多个字体属性。 CSS文本格式化 text-align：设置文本的水平对齐方式； text-decoration：设置文本的装饰； text-transform：设置文本中英文的大小写转换方式； text-indent：设置文本的缩进方式； line-height：设置行高； letter-spacing：设置字符间距； word-spacing：设置单词与单词之间的间距（对中文无效）； text-shadow：设置文本阴影； vertical-align：设置文本的垂直对齐方式； white-space：设置文本中空白的处理方式； direction：设置文本方向。 css链接链接有四种不同的状态，分别是 link、visited、active 和 hover。 可以通过以下伪类选择器来为链接的四种状态设置不同的样式： :link：定义普通或未访问链接的样式； :visited：定义已经访问过链接的样式； :hover：定义当鼠标经过或悬停在链接上时的样式； :active：定义点击链接时的样式。 边框CSS 中的边框是围绕着元素内容和内边距的一条或多条线段，您可以自定义这些线段的样式、宽度以及颜色。您可以通过下面几个属性分别定义边框的样式、宽度和颜色： border-style：设置边框的样式，例如实线、虚线等； border-width：设置边框的宽度（厚度）； border-color：设置边框的颜色； border：上面三个边框属性的缩写。 列表 CSS 中也提供了几种专门用来设置和格式化列表的属性，如下所示： list-style-type：设置列表项前面标记的形状（外观）； list-style-position：设置标记和列表中文本之间的距离； list-style-image：使用图像代替默认的标记； list-style：统一设置上面的三个属性。 响应式布局要实现响应式布局，常用的方式有以下几种： 使用 CSS 中的媒体查询（最简单）； 使用 JavaScript（使用成本比较高）； 使用第三方开源框架（例如 bootstrap，可以很好的支持各种浏览器）。 CSS resize（调整元素大小）该属性允许用户通过拖动的方式来自由缩放元素的尺寸。 语法说明如下： none：用户无法调整元素的尺寸； both：用户可调整元素的高度和宽度； horizontal：用户可调整元素的宽度； vertical：用户可调整元素的高度。 在使用 resize 属性时还需要注意以下几点： 单独设置 resize 属性是无效的，resize 属性需要与 overflow 属性结合使用才有效，并且 overflow 属性的值需要设置为 auto、hidden 或 scroll； 并不是所有的元素都可以设置 resize 属性，比如 img 和 table 属性就没办法使用 resize 属性。 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; div &#123; border: 1px solid; width: 300px; resize: both; overflow: auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;通过 resize 属性您可以调整元素在水平和垂直方向的大小&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; CSS flex布局（弹性布局&#x2F;弹性盒子）可以简便、完整、响应式地实现各种页面布局，当页面需要适应不同的屏幕大小以及设备类型时非常适用。 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称“容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称“项目”。 1) flex-directionflex-direction 属性用来决定主轴的方向（即项目的排列方向），属性的可选值如下： 值 描述 row 默认值，主轴沿水平方向从左到右 row-reverse 主轴沿水平方向从右到左 column 主轴沿垂直方向从上到下 column-reverse 主轴沿垂直方向从下到上 initial 将此属性设置为属性的默认值 inherit 从父元素继承此属性的值 2) flex-wrapflex-wrap 属性用来设置当弹性盒子的子元素（项目）超出父容器时是否换行，属性的可选值如下： 值 描述 nowrap 默认值，表示项目不会换行 wrap 表示项目会在需要时换行 wrap-reverse 表示项目会在需要时换行，但会以相反的顺序 initial 将此属性设置为属性的默认值 inherit 从父元素继承属性的值 3) justify-contentjustify-content 属性用于设置弹性盒子中元素在主轴（横轴）方向上的对齐方式，属性的可选值如下： 值 描述 flex-start 默认值，左对齐 flex-end 右对齐 center 居中 space-between 两端对齐，项目之间的间隔是相等的 space-around 每个项目两侧的间隔相等 initial 将此属性设置为属性的默认值 inherit 从父元素继承属性的值 4) align-itemsalign-items 属性用来设置弹性盒子中元素在侧轴（纵轴）方向上的对齐方式，属性的可选值如下： 值 描述 stretch 默认值，项目将被拉伸以适合容器 center 项目位于容器的中央 flex-start 项目位于容器的顶部 flex-end 项目位于容器的底部 baseline 项目与容器的基线对齐 initial 将此属性设置为属性的默认值 inherit 从父元素继承属性的值 5) orderorder 属性用来设置项目在容器中出现的顺序，您可以通过具体的数值来定义项目在容器中的位置，属性的语法格式如下： 1order: number; 其中 number 就是项目在容器中的位置，默认值为 0。 CSS box-sizing：改变盒子模型box-sizing 属性来改变默认的盒子模型，通过 box-sizing 属性可以将元素的内边距和外边距在元素内容区内绘制，以使元素呈现的宽度和高度与设置的宽度和高度相同。 box-sizing 属性的可选值如下： 值 描述 content-box 默认值，元素的实际宽度或高度等于元素内容区的宽度或高度、内边距和边框的和 border-box 在元素的内容区内绘制内边距或边框，内边距或边框不会影响元素的实际宽度或高度 inherit 从父元素继承 box-sizing 属性的值。 CSS column（多列布局）CSS3 中提供了一系列实现多列布局的属性，如下表所示： 属性 说明 column-count 指定元素应该分为几列 column-fill 指定如何填充每个列 column-gap 指定列与列之间的间隙 column-rule 所有 column-rule-* 属性的简写形式 column-rule-color 指定列与列之间边框的颜色 column-rule-style 指定列与列之间边框的样式 column-rule-width 指定列与列之间边框的宽度 column-span 指定元素应该横跨多少列 column-width 指定列的宽度 columns column-width 与 column-count 属性的简写属性 CSS transition（过渡效果）可以将元素从一种样式在指定时间内平滑的过渡到另一种样式，类似于简单的动画。 CSS 中提供了 5 个有关过渡的属性，如下所示： transition-property：设置元素中参与过渡的属性； transition-duration：设置元素过渡的持续时间； transition-timing-function：设置元素过渡的动画类型； transition-delay：设置过渡效果延迟的时间，默认为 0； transition：简写属性，用于同时设置上面的四个过渡属性。 要成功实现过渡效果，必须定义以下两项内容： 元素中参数与过渡效果的属性； 过渡效果持续的时间。 transition-propertytransition-property 属性用来设置元素中参与过渡的属性名称，语法格式如下： transition-property: none | all | property; 参数说明如下： none：表示没有属性参与过渡效果； all：表示所有属性都参与过渡效果； property：定义应用过渡效果的 CSS 属性名称列表，多个属性名称之间使用逗号,进行分隔。 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; div &#123; width: 100px; height: 100px; border: 3px solid black; margin: 10px 0px 0px 10px; transition-property: width, background; &#125; div:hover &#123; width: 200px; background-color: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; CSS动画（animation）@keyframes 规则要创建 CSS 动画，您首先需要了解 @keyframes 规则，@keyframes 规则用来定义动画各个阶段的属性值，类似于 flash 动画中的关键帧，语法格式如下： 1234567891011121314151617181920212223@keyframes animationName &#123; from &#123; properties: value; &#125; percentage &#123; properties: value; &#125; to &#123; properties: value; &#125;&#125;// 或者@keyframes animationName &#123; 0% &#123; properties: value; &#125; percentage &#123; properties: value; &#125; 100% &#123; properties: value; &#125;&#125; 语法说明如下： animationName：表示动画的名称； from：定义动画的开头，相当于 0%； percentage：定义动画的各个阶段，为百分比值，可以添加多个； to：定义动画的结尾，相当于 100%； properties：不同的样式属性名称，例如 color、left、width 等等。 1234567@keyframes ball &#123; 0% &#123; top: 0px; left: 0px;&#125; 25% &#123; top: 0px; left: 350px;&#125; 50% &#123; top: 200px; left: 350px;&#125; 75% &#123; top: 200px; left: 0px;&#125; 100% &#123; top: 0px; left: 0px;&#125; &#125; 要将动画应用到指定的 HTML 元素需要借助 CSS 属性，CSS 中提供了如下所示的动画属性： animation-name：设置需要绑定到元素的动画名称； animation-duration：设置完成动画所需要花费的时间，单位为秒或毫秒，默认为 0； animation-timing-function：设置动画的速度曲线，默认为 ease； animation-fill-mode：设置当动画不播放时（动画播放完或延迟播放时）的状态； animation-delay：设置动画开始之前的延迟时间，默认为 0； animation-iteration-count：设置动画被播放的次数，默认为 1； animation-direction：设置是否在下一周期逆向播放动画，默认为 normal； animation-play-state：设置动画是正在运行还是暂停，默认是 running； animation：所有动画属性的简写属性。 animation-name12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; @keyframes ball &#123; 0% &#123; top: 0px; left: 0px;&#125; 25% &#123; top: 0px; left: 350px;&#125; 50% &#123; top: 200px; left: 350px;&#125; 75% &#123; top: 200px; left: 0px;&#125; 100% &#123; top: 0px; left: 0px;&#125; &#125; div &#123; width: 100px; height: 100px; border-radius: 50%; border: 3px solid black; position: relative; animation-name: ball; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 注意：要想让动画成功播放，您还需要定义 animation-duration 属性，否则会因为 animation-duration 属性的默认值为 0，导致动画并不会播放。 CSS阴影效果1. text-shadow使用 CSS 的 text-shadow 属性我们可以为文本设置阴影效果，属性的语法格式如下： 1text-shadow: offset-x offset-y blur color; 语法说明如下： offset-x：必填参数，设置阴影的水平偏移量，可以为负值； offset-y：必填参数，设置阴影的垂直偏移量，可以为负值； blur：可选参数，设置模糊的半径，值越大，模糊越大，阴影的边缘越模糊，不允许使用负值； color：可选参数，设置阴影的颜色，如果省略或未指定该值，则采用 color 属性的值。 2. box-shadow使用 CSS 的 box-shadow 属性我们可以为 HTML 元素设置阴影效果，属性的语法格式如下： 1box-shadow: h-shadow v-shadow blur spread color inset; 语法说明如下： h-shadow：必填参数，设置阴影水平方向的偏移量，可以为负值； v-shadow：必填参数，设置阴影垂直方向的偏移量，可以为负值； blur：可选参数，设置模糊的半径，值越大，模糊越大，阴影的边缘越模糊，不允许使用负值； spread：可选参数，设置阴影的尺寸； color：可选参数，设置阴影的颜色； inset：可选参数，将默认的外部阴影 (outset) 改为内部阴影。 提示：与 text-shadow 属性相似，box-shadow 属性也可以同时设定多组阴影效果，每组之间使用逗号分隔，定义的多组阴影效果会按照定义顺序依次罗列，第一个阴影在最上面，以此类推。 CSS渐变色线性渐变线性渐变指的是颜色沿一条直线进行渐变（例如右上到下，从左到右等），要创建线性渐变，您至少需要定义两个色标（色标指的是想要平滑过渡的颜色），若要创建更加复杂的渐变效果，则需要定义更多的色标。创建线性渐变的基本语法如下： 1linear-gradient(direction, color-stop1, color-stop2, ...); 参数说明如下： direction 可选值，定义渐变的方向（例如从左到右，从上到下），可以是具体角度（例如 90deg），也可以通过 to 加 left、right、top、bottom 等关键字来表示渐变方向，例如： to left：表示从右到左，相当于 270deg； to right：表示从左到右，相当于 90deg； to top：表示从下到上，相当于 0deg； to bottom：默认值，表示从上到下，相当于 180deg； to right bottom：表示从左上到右下； to right top：表示从左下到右上； to left bottom：表示从右上到左下； to left top：表示从右下到左上。 color-stop1、color-stop2、…：表示定义的多个色标，在每个色标中除了可以定义颜色外，还可以通过数值加单位或者百分比的形式定义颜色的起止位置。 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; div &#123; width: 210px; height: 50px; float: left; margin: 10px; &#125; .one &#123; background: linear-gradient(to right bottom, red, blue 70px); &#125; .two &#123; background: linear-gradient(190deg, #000, #FFF); &#125; .three &#123; background: linear-gradient(red, green, blue); &#125; .four &#123; background: linear-gradient(to right, red, orange, yellow, green, blue, indigo, violet); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;one&quot;&gt;&lt;/div&gt; &lt;div class=&quot;two&quot;&gt;&lt;/div&gt; &lt;div class=&quot;three&quot;&gt;&lt;/div&gt; &lt;div class=&quot;four&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; CSS圆角（border-radius）CSS3 中提供了一系列属性来设置元素的圆角效果，如下所示： border-top-left-radius：为元素左上角设置圆角效果； border-top-right-radius：为元素右上角设置圆角效果； border-bottom-right-radius：为元素右下角设置圆角效果； border-bottom-left-radius：为元素左下角设置圆角效果； border-radius：上面四个属性的简写形式，可以同时为元素的四个角设置圆角效果。 border-radius 属性的格式如下： 1border-radius：[ &lt;length&gt; | &lt;percentage&gt; ]&#123;1,4&#125; [ / [ &lt;length&gt; | &lt;percentage&gt; ]&#123;1,4&#125; ]? CSS透明度（opacity）CSS 中提供了一个 opacity 属性用来设置元素的透明度，它不仅对颜色有效，对图像或者页面中其它的元素也有效。其语法格式如下： 1opacity: number; 其中 number 为一个 0~1 之间的浮点数（小数），用来表示元素的透明度，值越小则越透明（0 表示完全透明，1 表示完全不透明）。","categories":[],"tags":[]},{"title":"css简介","slug":"css简介","date":"2022-08-27T07:48:03.000Z","updated":"2022-09-08T12:00:58.000Z","comments":true,"path":"2022/08/27/css简介/","link":"","permalink":"http://peapod.top/2022/08/27/css%E7%AE%80%E4%BB%8B/","excerpt":"","text":"css简介CSS 是“Cascading Style Sheet”的缩写，中文意思为“层叠样式表”，它是一种标准的样式表语言，用于描述网页的表现形式（例如网页元素的位置、大小、颜色等）。 CSS 的主要作用是定义网页的样式（美化网页），对网页中元素的位置、字体、颜色、背景等属性进行精确控制。 css特点在网页中实现各式各样的效果，例如： 为任何元素设置不同的边框，以及边框与元素之间的内外间距； 改变文字的大小、颜色、字体，为文字添加修饰（例如下划线、删除线）； 为网页设置背景颜色或者背景图片等等。 可以对同一个 HTML 元素多次定义 CSS 样式，后面定义的样式会覆盖前面定义的样式。 css语法规则CSS 样式规则由三个部分组成，分别是选择器、属性和值： 选择器：由 HTML 元素的 id、class 属性或元素名本身以及一些特殊符号构成，用来指定要为哪个 HTML 元素定义样式，例如选择器p就表示为页面中的所有&lt;p&gt;标签定义样式； 属性：给 HTML 元素设置的样式名称，由一系列关键词组成，例如 color（颜色）、border（边框）、font（字体）等，CSS 中提供了众多属性，您可以通过 W3C 官网查看； 值：由数值和单位或者关键字组成，用来控制某个属性的显示效果，例如 color 属性的值可以是 red 或 #F1F1F1 等。 在 CSS 的语法规则中，属性和值之间需要使用冒号:进行分隔，每个属性和值的组合可以看作一个声明，每个声明的末尾都需要使用分号;作为结尾，属于同一选择器的声明需要使用花括号&#123; &#125;包裹起来。","categories":[{"name":"前端","slug":"前端","permalink":"http://peapod.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"css","slug":"css","permalink":"http://peapod.top/tags/css/"}],"author":"taweizhong"},{"title":"vim常用命令","slug":"vim常用命令","date":"2022-08-27T04:23:00.000Z","updated":"2022-09-07T03:51:28.000Z","comments":true,"path":"2022/08/27/vim常用命令/","link":"","permalink":"http://peapod.top/2022/08/27/vim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"vim常用命令命令模式 快捷键 功能描述 gg 光标移动到文档首行 G 光标移动到文档尾行 ctrl+b或pageUp键 翻屏操作，向上翻 ctrl+f或pageDn键 翻屏操作，向下翻 数字+G 快速将光标移动到指定行 shift+6 光标移动到行首 shift+4 光标移动到行尾 数字+上下方向键 以当前光标为准，向上&#x2F;下移动n行 数字+左右方向键 以当前光标为准，向左&#x2F;右移动n个字符 ctrl+v + 方向键+yy ctrl+v，并按方向键选中区块，按下yy复制 p 将剪贴板中的内容粘贴到光标后 dd 删除光标所在行，删除之后，下一行上移 D 删除光标位置到行尾的内容，删除之后，下一行不上移 :a1,a2d 删除从 a1 行到 a2 行的文本内容 u 撤销 ctrl+r 恢复 末行模式 命令 功能描述 :wq 保存并退出 Vim 编辑器 :wq! 保存并强制退出 Vim 编辑器 :q 不保存就退出 Vim 编辑器 :q! 不保存，且强制退出 Vim 编辑器 &#x2F;abc 从光标所在位置向前查找字符串 abc &#x2F;^abc 查找以 abc 为行首的行 &#x2F;abc$ 查找以 abc 为行尾的行 ?abc 从光标所在位置向后查找字符串 abc : set nu 行号显示 : syntax on&#x2F;off 代码颜色显示 更多点击查看更多","categories":[{"name":"实用","slug":"实用","permalink":"http://peapod.top/categories/%E5%AE%9E%E7%94%A8/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://peapod.top/tags/vim/"}],"author":"taweizhong"},{"title":"HTML标签","slug":"HTML标签","date":"2022-08-27T03:19:09.000Z","updated":"2022-09-08T07:19:30.000Z","comments":true,"path":"2022/08/27/HTML标签/","link":"","permalink":"http://peapod.top/2022/08/27/HTML%E6%A0%87%E7%AD%BE/","excerpt":"","text":"HTML标签标题标签HTML 中提供了从&lt;h1&gt;到&lt;h6&gt;六个级别的标题标签，&lt;h1&gt;标签的级别最高，&lt;h6&gt;标签的级别最低，通过这些标签可以定义网页中的标题（与 word 中的标题类似），合理使用标题可以使网页的层次结构更加清晰。 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;mate charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;h1 标题&lt;/h1&gt; &lt;h2&gt;h2 标题&lt;/h2&gt; &lt;h3&gt;h3 标题&lt;/h3&gt; &lt;h4&gt;h4 标题&lt;/h4&gt; &lt;h5&gt;h5 标题&lt;/h5&gt; &lt;h6&gt;h6 标题&lt;/h6&gt;&lt;/body&gt;&lt;/html&gt; 段落标签HTML 中可以使用段落标签 &lt;p&gt;来将文档中的内容分割为若干个段落。 1&lt;p&gt;段落中的内容。&lt;/p&gt; 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;mate charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;这是一个段落。&lt;a href=&quot;http://43.138.70.17:4000/&quot; target=&quot;_blank&quot;&gt;这是一个链接&lt;/a&gt;&lt;/p&gt; &lt;p&gt;这是第二个标签&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 超链接标签 标签的语法格式如下： 1&lt;a href=&quot;&quot; target=&quot;_blank&quot;&gt;这是一个链接&lt;/a&gt; href 属性指定链接的目标，也就是要跳转到什么位置。 target 是可选属性，用来指明新页面的打开方式。 属性值 说明 _self 默认，在现有窗口中打开新页面，原窗口将被覆盖。 _blank 在新窗口中打开新页面，原窗口将被保留。 _parent 在当前框架的上一层打开新页面。 _top 在顶层框架中打开新页面。 &lt;img标签&gt; 标签的语法格式如下： 1&lt;img src=&quot;url&quot; alt=&quot;text&quot;&gt; src 是必选属性，它是 source 的简称，用来指明图片的地址或者路径。 alt 是可选属性，用来定义图片的文字描述信息。 使用 width 和 height 属性来指定图片的宽度和高度。 12&lt;img src=&quot;./html5.png&quot; alt=&quot;HTML5 Logo&quot; width=&quot;100&quot; height=&quot;100&quot;&gt;&lt;img src=&quot;./html5.png&quot; alt=&quot;HTML5 Logo&quot; style=&quot;width: 150px; height: 150px;&quot;&gt; 表格标签12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;mate charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;table&gt; &lt;caption&gt;这是表格的标题&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;name &lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;taweizhong &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 列表标签有序列表12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;HTML有序列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;煮米饭的步骤：&lt;/p&gt; &lt;ol&gt; &lt;li&gt;将水煮沸&lt;/li&gt; &lt;li&gt;加入一勺米&lt;/li&gt; &lt;li&gt;搅拌均匀&lt;/li&gt; &lt;li&gt;继续煮10分钟&lt;/li&gt; &lt;/ol&gt;&lt;/body&gt;&lt;/html&gt; 无序列表12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;HTML无序列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;早餐的种类：&lt;/p&gt; &lt;ul&gt; &lt;li&gt;鸡蛋&lt;/li&gt; &lt;li&gt;牛奶&lt;/li&gt; &lt;li&gt;面包&lt;/li&gt; &lt;li&gt;生菜&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 定义列表12345678&lt;dl&gt; &lt;dt&gt;标题1&lt;dt&gt; &lt;dd&gt;描述文本2&lt;dd&gt; &lt;dt&gt;标题2&lt;dt&gt; &lt;dd&gt;描述文本2&lt;dd&gt; &lt;dt&gt;标题3&lt;dt&gt; &lt;dd&gt;描述文本3&lt;dd&gt;&lt;/dl&gt; 表单标签表单可以接收用户输入的信息，然后将其发送到后端应用程序。 语法如下所示： 123&lt;form action=&quot;URL&quot; method=&quot;GET|POST&quot;&gt; 表单中的其它标签&lt;/form&gt; action 属性用来指明将表单提交到哪个页面。 method 属性表示使用哪个方式提交数据，包括 GET 和 POST 两种方式。 表单属性 属性 可选值 描述 accept MIME_type HTML5 中不再支持，设置服务器要接收的文件类型 accept-charset character_set 设置表单数据的字符集（默认为 HTML 文档字符集） action URL 设置要将表单提交到何处（默认为当前页面） autocomplete on、off 设置是否启用表单的自动完成功能（默认开启） enctype application&#x2F;x-www-form-urlencoded、 multipart&#x2F;form-data、 text&#x2F;plain 设置在提交表单数据之前如何对数据进行编码（适用于 method&#x3D;”post” 的情况） method get、post 设置使用哪种 HTTP 方法来提交表单数据（默认为 get） name text 设置表单的名称 novalidate novalidate 如果使用该属性，则提交表单时不进行验证 target _blank、_self、_parent、_top 设置在何处打开 action 属性设定的链接（默认为 _self） 表单控件 控件&#x2F;标签 描述 &lt;input&gt; 定义输入框 &lt;textarea&gt; 定义文本域（一个可以输入多行文本的控件） &lt;label&gt; 为表单中的各个控件定义标题 &lt;fieldset&gt; 定义一组相关的表单元素，并使用边框包裹起来 &lt;legend&gt; 定义 &lt;fieldset&gt; 元素的标题 &lt;select&gt; 定义下拉列表 &lt;optgroup&gt; 定义选项组 &lt;option&gt; 定义下拉列表中的选项 &lt;button&gt; 定义一个可以点击的按钮 &lt;datalist&gt; 指定一个预先定义的输入控件选项列表 &lt;keygen&gt; 定义表单的密钥对生成器字段 &lt;output&gt; 定义一个计算结果 &amp;emsp HTML空格 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;HTML form表单演示&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;./userinfo.php&quot; method=&quot;POST&quot;&gt; &lt;!-- 文本输入框控件 --&gt; &lt;label&gt;用户名： &lt;/label&gt;&lt;input name=&quot;username&quot; type=&quot;text&quot;&gt;&lt;br&gt; &lt;!-- 密码框控件 --&gt; &lt;label&gt;密&amp;emsp;码： &lt;/label&gt;&lt;input name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;br&gt; &lt;!-- 下拉菜单控件 --&gt; &lt;label&gt;性&amp;emsp;别：&lt;/label&gt; &lt;select name=&quot;sex&quot;&gt; &lt;option value=&quot;1&quot;&gt;男&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;女&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;未知&lt;/option&gt; &lt;/select&gt; &lt;br&gt; &lt;!-- 复选框控件 --&gt; &lt;label&gt;爱&amp;emsp;好：&lt;/label&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;1&quot;&gt;听音乐 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;2&quot;&gt;看电影 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;3&quot;&gt;打游戏 &lt;br&gt; &lt;!-- 单选按钮控件 --&gt; &lt;label&gt;学&amp;emsp;历：&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;education&quot; value=&quot;1&quot;&gt;小学 &lt;input type=&quot;radio&quot; name=&quot;education&quot; value=&quot;2&quot;&gt;中学 &lt;input type=&quot;radio&quot; name=&quot;education&quot; value=&quot;3&quot;&gt;本科 &lt;input type=&quot;radio&quot; name=&quot;education&quot; value=&quot;4&quot;&gt;硕士 &lt;input type=&quot;radio&quot; name=&quot;education&quot; value=&quot;5&quot;&gt;博士 &lt;br&gt; &lt;!-- 按钮 --&gt; &lt;input type=&quot;submit&quot; value=&quot;提 交&quot;&gt;&amp;emsp;&amp;emsp; &lt;input type=&quot;reset&quot; value=&quot;重 置&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 块级元素和内联元素块级元素块级元素最主要的特点是它们自己独占一行，块级元素中最具代表性的就是&lt;div&gt;，此外还有&lt;p&gt;、&lt;nav&gt;、&lt;aside&gt;、&lt;header&gt;、&lt;footer&gt;、&lt;section&gt;、&lt;article&gt;、&lt;ul&gt;、&lt;address&gt;、&lt;h1&gt;~&#96;&#96;等。 主要特征如下所示： 块级元素总是在新行上开始； 宽度、高度以及外边距和内边距等都可以控制； 省略块级元素的宽度，那么它的宽度默认为当前浏览器窗口的宽度； 包含其它的内联元素和块级元素。 内联元素内联元素也可以称为行内元素，行内元素中最常用的是&lt;span&gt;，此外还有&lt;b&gt;、&lt;i&gt;、&lt;u&gt;。 主要特征如下所示： 和其他元素会在同一行上显示； 宽、高以及外边距和内边距都不可以改变； 宽度就是其中内容的宽度，且不可以改变； 只能容纳文本或者其他内联元素。 可以通过 line-height 来设置行高； 可以设置 margin 外边距，但只对左右外边距有效，上下无效； 设置 padding 内边距时，只有左右 padding 有效，上下则无效 标签&lt;div&gt;&lt;div&gt;是非常重要的块级标记，在网页布局（Layout）方面发挥着重要的作用，使用&lt;div&gt;我们可以定义页面的各个部分，通过与 CSS 相结合可以实现各种各样的效果。 &lt;div&gt; 标签及其包围的内容可以看做网页的一个板块， 标签本身并没有什么特殊的显示效果，需要借助 CSS 样式对外边距、内边距、背景、边框等进行设置，从而达到对板块布局的目的。 &lt;span&gt;标签HTML 中的&lt;span&gt;标签是一个内联元素，可以对 HTML 文档中的内容进行修饰，此标签不会为文档内容提供任何视觉效果，但可以与 CSS 结合使用来美化网页。 布局HTML5 提出了多个专门用于布局的标签，它们用来定义网页的不同部分，语义更加明确。 标签 说明 &lt;header&gt; 用于定义网页的头部，头部中一般包含一些介绍性的内容，例如网站名称、logo 或者作者的信息。 &lt;nav&gt; 用于定义网页中的导航栏。 &lt;section&gt; 用于在网页中定义一个单独的部分，其中可以包含文本、图像、表格等等。 &lt;section&gt; 代表 HTML 文档中的“节”或“段”，“段”可以理解为一篇文章里按照主题的分段，“节”则可以理解为一个页面里的分组。其主要作用就是对页面的内容进行分块或者对文章的内容进行分段。 &lt;article&gt; 用于定义文章或者其它独立的信息，代表一个页面中自成一体的内容，例如论坛的帖子、博客上的文章、一篇用户的评论等。 &lt;aside&gt; 用于定义网页内容以外的部分，例如网页的侧边栏。 &lt;footer&gt; 用于定义网页的底部，例如作者、版权等信息。 &lt;details&gt; 用于定义一些详细信息，并且可以根据需要隐藏或显示这些详细信息。 &lt;summary&gt; 用于为&lt;details&gt;标签定义标题。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://peapod.top/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://peapod.top/tags/HTML/"}],"author":"taweizhong"},{"title":"HTML标签的属性","slug":"HTML标签的属性","date":"2022-08-26T10:59:55.000Z","updated":"2022-09-08T07:20:48.000Z","comments":true,"path":"2022/08/26/HTML标签的属性/","link":"","permalink":"http://peapod.top/2022/08/26/HTML%E6%A0%87%E7%AD%BE%E7%9A%84%E5%B1%9E%E6%80%A7/","excerpt":"","text":"HTML属性属性包含了标签的额外信息，例如： href 属性可以为 标签提供链接地址； src 属性可以为 标签提供图像的路径； style 属性可以为几乎所有标签定义 CSS 样式。 属性需要添加在开始标签中，语法格式为： 12attr=&quot;value&quot;attr 表示属性名，value 表示属性值。属性值必须使用双引号&quot; &quot;或者单引号&#x27; &#x27;包围。 说明： 标签中的 src 属性用来定义图像的路径，alt 属性用来定义图像的描述信息，当图像出现异常无法正常显示时就会显示 alt 中的信息。 标签的 href 属性用来定义链接的地址，target 属性用来定义新页面在浏览器中的打开方式。 通用属性1) idid 属性用来赋予某个标签唯一的名称（标识符），当我们使用 CSS 或者 JavaScript 来操作这个标签时，就可以通过 id 属性来找到这个标签。 2) class与 id 属性类似，class 属性也可以为标签定义名称（标识符），不同的是 class 属性在整个 HTML 文档中不必是唯一的，我们可以为多个标签定义相同的 class 属性值。另外，还可以为一个 HTML 标签定义多个 class 属性值。 3) titletitle 属性用来对标签内容进行描述说明，当鼠标移动到该标签上方时会显示出 title 属性的值。 4) style使用 style 属性我们可以在 HTML 标签内部为标签定义 CSS 样式","categories":[{"name":"笔记","slug":"笔记","permalink":"http://peapod.top/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://peapod.top/tags/HTML/"}],"author":"taweizhong"},{"title":"HTML标签的语法格式","slug":"HTML标签的语法格式","date":"2022-08-26T10:59:38.000Z","updated":"2022-09-08T07:22:22.000Z","comments":true,"path":"2022/08/26/HTML标签的语法格式/","link":"","permalink":"http://peapod.top/2022/08/26/HTML%E6%A0%87%E7%AD%BE%E7%9A%84%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F/","excerpt":"","text":"标签的语法格式一个 HTML 标签由开始标签、属性、内容和结束标签组成，标签的名称不区分大小写。 注意： 所有 HTML 标签都必须放在尖括号&lt; &gt;内； HTML 中不同的标签可以实现不同的效果； 如果使用了某个标签，则必须使用对应的结束标签来结尾（自闭和标签除外）。 自闭和标签12345&lt;img src=&quot;&quot; alt=&quot;&quot; /&gt;&lt;hr /&gt;&lt;br /&gt;&lt;input type=&quot;text&quot; /&gt;&lt;!-- --&gt; 表示 HTML 注释","categories":[{"name":"笔记","slug":"笔记","permalink":"http://peapod.top/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://peapod.top/tags/HTML/"}],"author":"taweizhong"},{"title":"HTML简介","slug":"HTML简介","date":"2022-08-26T10:59:12.000Z","updated":"2022-09-08T07:23:20.000Z","comments":true,"path":"2022/08/26/HTML简介/","link":"","permalink":"http://peapod.top/2022/08/26/HTML%E7%AE%80%E4%BB%8B/","excerpt":"","text":"HTML简介HTML 英文全称是 Hyper Text Markup Language，中文译为“超文本标记语言”，专门用来设计和编辑网页。 1) 超文本也即超越纯文本，这意味着 HTML 文档不仅能包含文本（文字），还能包含图片、音视频、表格、列表、链接、按钮、输入框等高级内容。 2) 标记语言HTML 是一种计算机语言，但它不能编程，只能用来标记网页中的内容。HTML 通过不同的标签来标记不同的内容、格式、布局等。 HTML标签HTML 是一种标记语言，使用各种标签来格式化内容，标签的特点如下所示： HTML 标签由尖括号包围的关键词构成，比如 ； 除了少数标签外，大多数 HTML 标签都是成对出现的； 成对出现的标签中，第一个标签称为开始标签，第二个标签称为结束标签（闭合标签）。 HTML文档结构123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;mate charset=&quot;utf8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;&lt;/p&gt; &lt;h1&gt;&lt;/h1&gt; &lt;input type=&quot;text&quot;/&gt; &lt;/body&gt;&lt;/html&gt; 说明： ：该标签是 HTML 页面的根标签，其他所有的标签都需要在 和 标签之间定义； ：该标签中用来定义 HTML 文档的一些信息，例如标题、编码格式等等； ：用来指明当前网页采用 UTF-8 编码，UTF-8 是全球通用的编码格式，绝大多数网页都采用 UTF-8 编码； ：该标签用来定义网页的标题，网页标题会显示在浏览器的标签栏； ：该标签用来定义网页中我们能通过浏览器看到的所有内容，例如段落、标题、图片、链接等等；","categories":[{"name":"笔记","slug":"笔记","permalink":"http://peapod.top/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://peapod.top/tags/HTML/"}]},{"title":"Go函数","slug":"Go函数","date":"2022-08-26T08:31:43.000Z","updated":"2022-09-08T07:38:44.000Z","comments":true,"path":"2022/08/26/Go函数/","link":"","permalink":"http://peapod.top/2022/08/26/Go%E5%87%BD%E6%95%B0/","excerpt":"","text":"第六章：函数简介函数是基本的代码块。函数编写的顺序是无关紧要的，最好把 main() 函数写在文件的前面。 简单的 return 语句也可以用来结束 for 死循环，或者结束一个协程（goroutine）。 Go里面的函数： 普通函数 匿名函数 方法 除了main()、init()函数外，其它所有类型的函数都可以有参数与返回值。 函数参数、返回值以及它们的类型被统称为函数签名。 函数是一等值（first-class value）：它们可以赋值给变量，就像 add := binOp 一样。 函数不能在其它函数里面声明（不能嵌套），不过我们可以通过使用匿名函数 函数参数与返回值函数定义时，它的形参一般是有名字的，不过我们也可以定义没有形参名的函数，只有相应的形参类型，就像这样：func f(int, int, float64)。 在函数调用时，像切片（slice）、字典（map）、接口（interface）、通道（channel）这样的引用类型都是默认使用引用传递（即使没有显式的指出指针）。 命名返回值 命名返回值作为结果形参（result parameters）被初始化为相应类型的零值，当需要返回的时候，我们只需要一条简单的不带参数的return语句。 123456func getX2AndX3_2(input int) (x2 int, x3 int) &#123; x2 = 2 * input x3 = 3 * input // return x2, x3 return&#125; 改变外部变量 传递指针给函数不但可以节省内存（因为没有复制变量的值），而且赋予了函数直接修改外部变量的能力，所以被修改的变量不再需要使用 return 返回。 1234567891011121314package mainimport ( &quot;fmt&quot;)// this function changes reply:func Multiply(a, b int, reply *int) &#123; *reply = a * b&#125;func main() &#123; n := 0 reply := &amp;n Multiply(10, 5, reply) fmt.Println(&quot;Multiply:&quot;, *reply) // Multiply: 50&#125; 变长参数函数的最后一个参数是采用 ...type 的形式，那么这个函数就可以处理一个变长的参数 123456789101112131415161718192021package mainimport &quot;fmt&quot;func main() &#123; x := min(1, 3, 2, 0) fmt.Printf(&quot;The minimum is: %d\\n&quot;, x) slice := []int&#123;7,9,3,5,1&#125; x = min(slice...) fmt.Printf(&quot;The minimum in the slice is: %d&quot;, x)&#125;func min(s ...int) int &#123; if len(s)==0 &#123; return 0 &#125; min := s[0] for _, v := range s &#123; if v &lt; min &#123; min = v &#125; &#125; return min&#125; 变长参数的类型不相同 使用结构体 使用空接口 使用默认的空接口 interface&#123;&#125;，这样就可以接受任何类型的参数 new 和 make 均是用于分配内存：new 用于值类型和用户定义的类型，如自定义结构，make 用于内置引用类型（切片、map 和管道）。 new(T) 分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针 make(T) 返回类型 T 的初始化之后的值，因此它比 new 进行更多的工作。 defer和追踪关键字 defer 允许我们推迟到函数返回之前（或任意位置执行 return 语句之后）一刻才执行某个语句或函数。 123456789101112package mainimport &quot;fmt&quot;func P()&#123; fmt.Print(&quot;P&quot;)&#125;func main()&#123; fmt.Print(&quot;111&quot;) defer P() fmt.Print(&quot;222&quot;)&#125; 当有多个 defer 行为被注册时，它们会以逆序执行 123456789101112package mianimport ( &quot;file&quot;)func main()&#123; //关闭文件 defer file.close() //解锁 mu.Lock() defer mu.Unlock() //关闭数据库连接 defer disconnectFromDB()&#125; 函数作为参数1234567891011package mainimport &quot;fmt&quot;func add(i,j int) int &#123; return i+j&#125;func b(c int, f func (i,j int) int )&#123; return f(c, 2)&#125;func main()&#123; fmt.Print(b(1, add))&#125; 闭包匿名函数的使用 12345678910package mainimport &quot;fmt&quot;func main ()&#123; // 匿名函数 func(i, j int) int &#123;return i+j&#125; // 将匿名函数赋值给变量 变量使用匿名函数 ter := func(i, j int) int &#123;return i+j&#125; ter(2,3) // 匿名函数直接的调用 func(a, b int) int &#123;return a-b&#125; (3, 2)&#125; 函数作为返回值123456789101112package mainimport &quot;fmt&quot;func add(j int) func (i int) int&#123; return func (i int) int&#123; return j +i &#125;&#125;func main()&#123; add(12)&#125; 12345678910111213141516171819package mainimport &quot;fmt&quot;func add() func(i int) int &#123; var x int fmt.Printf(&quot;x: %v\\n&quot;, x) return func(i int) int &#123; x += i return x &#125;&#125;func main() &#123; f := add() fmt.Printf(&quot;f(1): %v\\n&quot;, f(1)) fmt.Printf(&quot;f(2): %v\\n&quot;, f(20))&#125; 闭包函数保存并积累其中的变量的值，不管外部函数退出与否，它都能够继续操作外部函数中的局部变量。 计算函数的执行时间12345678910111213141516171819package mainimport ( &quot;fmt&quot; &quot;time&quot;)func add() &#123; for i := 0; i &lt; 100; i++ &#123; fmt.Printf(&quot;i: %v\\n&quot;, i) &#125;&#125;func main() &#123; start := time.Now() add() end := time.Now() fmt.Print(end.Sub(start))&#125;","categories":[{"name":"笔记","slug":"笔记","permalink":"http://peapod.top/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://peapod.top/tags/Go/"}],"author":"taweizhong"},{"title":"Go控制结构","slug":"Go控制结构","date":"2022-08-26T08:31:25.000Z","updated":"2022-09-08T07:37:16.000Z","comments":true,"path":"2022/08/26/Go控制结构/","link":"","permalink":"http://peapod.top/2022/08/26/Go%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/","excerpt":"","text":"第五章：控制结构if-else结构12345if condition &#123; //&#125; else &#123; //&#125; 当 if 结构内有 break、continue、goto 或者 return 语句时，Go 代码的常见写法是省略 else 部分 1234if condition &#123; return x&#125;return y 1234if err != nil &#123; fmt.Printf(&quot;Program stopping with error %v&quot;, err) os.Exit(1)&#125; swith结构它可以接受任意形式的表达式： 12345678switch var1 &#123; case val1: ... case val2: ... default: ...&#125; 变量 var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值。 一旦成功地匹配到某个分支，在执行完相应代码后就会退出整个 switch 代码块。 继续执行后续分支的代码，可以使用 fallthrough 关键字 12345switch i &#123; case 0: fallthrough case 1: f() // 当 i == 0 时函数也会被调用&#125; 可选的 default 分支可以出现在任何顺序，但最好将它放在最后。它的作用类似与 if-else 语句中的 else，表示不符合任何已给出条件时，执行相关语句。 switch 语句的第二种形式是不提供任何被判断的值（实际上默认为判断是否为 true），然后在每个 case 分支中进行测试不同的条件。 12345678switch &#123; case i &lt; 0: f1() case i == 0: f2() case i &gt; 0: f3()&#125; for结构基于计数器的迭代 1234567package mainimport &quot;fmt&quot;func main() &#123; for i := 0; i &lt; 5; i++ &#123; fmt.Printf(&quot;This is the %d iteration\\n&quot;, i) &#125;&#125; 基于条件判断的迭代 123456789package mainimport &quot;fmt&quot;func main() &#123; var i int = 5 for i &gt;= 0 &#123; i = i - 1 fmt.Printf(&quot;The variable i is now: %d\\n&quot;, i) &#125;&#125; for-range结构 for ix, val := range coll &#123; &#125;。 val 始终为集合中对应索引的值拷贝，因此它一般只具有只读性质，对它所做的任何修改都不会影响到集合中原有的值 123for pos, char := range str &#123;...&#125; 标签和gotofor、switch 或 select 语句都可以配合标签（label）形式的标识符使用，即某一行第一个以冒号（:） 12345678910111213package mainimport &quot;fmt&quot;func main() &#123;LABEL1: // 一般建议使用全部大写字母 for i := 0; i &lt;= 5; i++ &#123; for j := 0; j &lt;= 5; j++ &#123; if j == 4 &#123; continue LABEL1 &#125; fmt.Printf(&quot;i is: %d, and j is: %d\\n&quot;, i, j) &#125; &#125;&#125;","categories":[{"name":"笔记","slug":"笔记","permalink":"http://peapod.top/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://peapod.top/tags/Go/"}],"author":"taweizhong"},{"title":"Go基本数据类型","slug":"Go基本数据类型","date":"2022-08-26T08:31:00.000Z","updated":"2024-02-27T10:46:52.683Z","comments":true,"path":"2022/08/26/Go基本数据类型/","link":"","permalink":"http://peapod.top/2022/08/26/Go%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"第四章（下）：基本数据类型常量常量使用关键字 const 定义，用于存储不会改变的数据。 存储在常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。 1const Pi = 3.14 常量的值必须是能够在编译时就能够确定的。 因为在编译期间自定义函数均属于未知，因此无法用于常量的赋值，但内置函数可以使用，如：len()。 12const Ln2 = 0.693147180559945309417232121458\\ 176568075500134360255254120680009 反斜杠 \\ 可以在常量表达式中作为多行的连接符使用。 常量并行赋值 1const beef,two,c = &quot;eat&quot;,2,&quot;vag&quot; iota 可以被用作枚举值： 12345const ( a = iota b = iota c = iota) 简单地讲，每遇到一次 const 关键字，iota 就重置为 0。. 变量声明变量的一般形式是使用 var 关键字：var identifier type。 123456789var a intvar b boolvar str stringvar ( a int b bool str string) 变量的命名规则遵循骆驼命名法。 全局变量希望能够被外部包所使用，则需要将首个单词的首字母也大写。 变量可以编译期间就被赋值，赋值给变量使用运算符等号 =，可以在运行时对变量进行赋值操作。 12345var a intvar b boola = 15b = true 声明与赋值（初始化）语句也可以组合起来。 12var a int = 15var b bool = false 自动类型推断 12345678910var a = 15var b = falsevar ( a = 15 b = false str = &quot;Go says hello to the world!&quot; numShips = 50 city string) 在函数体内声明局部变量时，应使用简短声明语法 :=，例如： 1a := 1 实例： 123456789101112package mainimport ( &quot;fmt&quot; &quot;runtime&quot; &quot;os&quot;)func main ()&#123; goos := runtime.GOOS fmt.Printf(&quot;%s\\n&quot;,goos) var path string = os.Getenv(&quot;PATH&quot;) fmt.Printf(&quot;%s\\n&quot;,path)&#125; 值类型和引用类型 int、float、bool 和 string 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值。 数组和结构体这些复合类型是值类型。 指针、切片、映射和通道是引用类型。被引用的变量会存储在堆中，以便进行垃圾回收，且比栈拥有更大的内存空间。 函数 fmt.Sprintf 与 Printf 的作用是完全相同的，不过前者将格式化后的字符串以返回值的形式返回给调用者。 在相同的代码块中，我们不可以再次对于相同名称的变量使用初始化声明，例如：a := 20 就是不被允许的。 1a, b, c := 5, 7, &quot;abc&quot; 交换两个变量的值，则可以简单地使用 a, b = b, a。 init函数 变量除了可以在全局声明中初始化，也可以在 init 函数中初始化。 每个源文件都只能包含一个 init 函数。初始化总是以单线程执行，并且按照包的依赖关系顺序执行。 用途是在开始执行程序之前对数据进行检验或修复，以保证程序状态的正确性。 123456package transimport &quot;math&quot;var Pi float64func init()&#123; Pi = 4*math.Atan(1)&#125; 123456789package mainimport ( &quot;fmt&quot; &quot;./trans&quot;)var twoPi = 2*trams.Pifunc main()&#123; fmt.Printf(twoPi)&#125; init 函数也经常被用在当一个程序开始之前调用后台执行的 goroutine。 1234func init() &#123; // setup preparations go backend()&#125; 基本类型与运算符bool类型只有两个类型相同的值才可以进行比较，如果值的类型是接口，它们也必须都实现了相同的接口。 布尔型的常量和变量也可以通过和逻辑运算符（非 !、和 &amp;&amp;、或 ||）结合来产生另外一个布尔值。 ！非运算符用于取得和布尔值相反的结果。 &amp;&amp;两边的值都为 true 的时候，结果才是 true。 ||两边的值都为 false 的时候，结果才是 false。 在格式化输出时，你可以使用 %t 来表示你要输出的值为布尔型。 数字类型Go 语言支持整型和浮点型数字，并且原生支持复数，其中位的运算采用补码。 Go 也有基于架构的类型，例如：int、uint 和 uintptr。 这些类型的长度都是根据运行程序所在的操作系统类型所决定的： int 和 uint 在 32 位操作系统上，它们均使用 32 位（4 个字节），在 64 位操作系统上，它们均使用 64 位（8 个字节）。 uintptr 的长度被设定为足够存放一个指针即可。 Go 语言中没有 float 类型。（Go语言中只有 float32 和 float64）没有double类型。 int 型是计算最快的一种类型。 float32 精确到小数点后 7 位，float64 精确到小数点后 15 位。 尽可能地使用 float64，因为 math 包中所有有关数学运算的函数都会要求接收这个类型。 前缀 0 来表示 8 进制数（如：077），增加前缀 0x 来表示 16 进制数（如：0xFF），以及使用 e 来表示 10 的连乘（如： 1e3 &#x3D; 1000，或者 6.022e23 &#x3D; 6.022 x 1e23）。 可以使用 a := uint64(0) 来同时完成类型转换和赋值操作，这样 a 的类型就是 uint64。 Go 中不允许不同类型之间的混合使用，但是对于常量的类型限制非常少，因此允许常量之间的混合使用： 12345678package mainfunc main()&#123; var a int var b int32 a = 15 b = a+a //编译错误 b = b+5 //5是常量，可以编译&#125; 格式化说明符 %d 用于格式化整数（%x 和 %X 用于格式化 16 进制表示的数字），%g 用于格式化浮点型（%f 输出浮点数，%e 输出科学计数表示法），%0nd 用于规定输出长度为n的整数，其中开头的数字 0 是必须的。 %n.mg 用于表示数字 n 并精确到小数点后 m 位，除了使用 g 之外，还可以使用 e 或者 f，例如：使用格式化字符串 %5.2e 来输出 3.4 的结果为 3.40e+00。 / 对于整数运算而言，结果依旧为整数，例如：9 / 4 -&gt; 2。 取余运算符只能作用于整数：9 % 4 -&gt; 1。 对于整数和浮点数，你可以使用一元运算符 ++（递增）和 --（递减），但只能用于后缀。 ++ 和 -- 的只能作为语句，而非表达式，因此 n = i++ 这种写法是无效的。 随机数 rand 包实现了伪随机数的生成。 123456789101112131415161718192021package mainimport ( &quot;fmt&quot; &quot;math/rand&quot; &quot;time&quot;)func main()&#123; for i:=0; i&lt;5; i++&#123; a := rand.Int() fmt.Printf(&quot;%d\\n&quot;,r) &#125; for i := 0; i &lt; 5; i++ &#123; r := rand.Intn(8) fmt.Printf(&quot;%d / &quot;, r) &#125; times := int64(time.Now().Nanosecond()) rand.Seed(times) for i := 0; i &lt; 10; i++ &#123; fmt.Printf(&quot;%2.2f / &quot;, 100*rand.Float32()) &#125;&#125; 函数 rand.Intn 返回介于 [0, n) 之间的伪随机数。 类型别名在 type TZ int 中，TZ 就是 int 类型的新名称（用于表示程序中的时区），然后就可以使用 TZ 来操作 int 类型的数据。 新类型不会拥有原类型所附带的方法。 字符类型byte 类型是 uint8 的别名。 Go 同样支持 Unicode（UTF-8），因此字符同样称为 Unicode 代码点或者 runes，并在内存中使用 int 来表示。 rune 也是 Go 当中的一个类型，并且是 int32 的别名。 1var ch byte = 65 或 var ch byte = &#x27;\\x41&#x27; var ch byte = &#39;A&#39;；字符使用单引号括起来。 Unicode 至少占用 2 个字节，所以我们使用 int16 或者 int 类型来表示。如果需要使用到 4 字节，则会加上 \\U 前缀；前缀 \\u 则总是紧跟着长度为 4 的 16 进制数，前缀 \\U 紧跟着长度为 8 的 16 进制数。 123456789101112var ch int = &#x27;\\u0041&#x27;var ch2 int = &#x27;\\u03B2&#x27;var ch3 int = &#x27;\\U00101234&#x27;fmt.Printf(&quot;%d - %d - %d\\n&quot;, ch, ch2, ch3) // integerfmt.Printf(&quot;%c - %c - %c\\n&quot;, ch, ch2, ch3) // characterfmt.Printf(&quot;%X - %X - %X\\n&quot;, ch, ch2, ch3) // UTF-8 bytesfmt.Printf(&quot;%U - %U - %U&quot;, ch, ch2, ch3) // UTF-8 code point65 - 946 - 1053236A - β - r41 - 3B2 - 101234U+0041 - U+03B2 - U+101234 判断是否为字母：unicode.IsLetter(ch) 判断是否为数字：unicode.IsDigit(ch) 判断是否为空白符号：unicode.IsSpace(ch) 包 utf8 拥有更多与 rune 类型相关的函数。 字符串字符串是一种值类型，且值不可变，字符串是字节的定长数组。 Go 中的字符串是根据长度限定，而非特殊字符\\0。 函数 len() 来获取字符串所占的字节长度。 在循环中使用加号 + 拼接字符串并不是最高效的做法，更好的办法是使用函数 strings.Join()。 使用字节缓冲（bytes.Buffer）拼接更加给力。 strings和strconv包Go 中使用 strings 包来完成对字符串的主要操作。 12345678910111213141516171819202122232425262728293031strings.HasPrefix(s, prefix string) bool// 判断字符串 s 是否以 prefix 开头strings.HasSuffix(s, suffix string) bool// 判断字符串 s 是否以 suffix 结尾strings.Contains(s, substr string) bool// 判断字符串 s 是否包含 substrstrings.Index(s, str string) int// Index 返回字符串 str 在字符串 s 中的索引strings.LastIndex(s, str string) int// LastIndex 返回字符串 str 在字符串 s 中最后出现位置的索引strings.IndexRune(s string, r rune) int// 非 ASCII 编码的字符在父字符串中的位置strings.Replace(str, old, new, n) string// Replace 用于将字符串 str 中的前 n 个字符串 old 替换为字符串 new，并返回一个新的字符串，如果 n = -1 则替换所有字符串 old 为字符串 newstrings.Count(s, str string) int// Count 用于计算字符串 str 在字符串 s 中出现的非重叠次数strings.Repeat(s, count int) string// Repeat 用于重复 count 次字符串 s 并返回一个新的字符串strings.TrimSpace(s) 来剔除字符串开头和结尾的空白符号；如果你想要剔除指定字符，则可以使用 strings.Trim(s, &quot;cut&quot;) 来将开头和结尾的 cut 去除掉。strings.Split(s, sep) 用于自定义分割符号来对指定字符串进行分割，同样返回 slice。strings.Join(sl []string, sep string) string// Join 用于将元素类型为 string 的 slice 使用分割符号来拼接组成一个字符串 与字符串相关的类型转换都是通过 strconv 包实现的。 12345678910strconv.Itoa(i int) string// 返回数字 i 所表示的字符串类型的十进制数。strconv.FormatFloat(f float64, fmt byte, prec int, bitSize int) string // 将 64 位浮点型的数字转换为字符串strconv.Atoi(s string) (i int, err error) // 将字符串转换为 int 型。strconv.ParseFloat(s string, bitSize int) (f float64, err error) // 将字符串转换为 float64 型。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://peapod.top/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://peapod.top/tags/Go/"}],"author":"taweizhong"},{"title":"Go基本结构","slug":"Go基本结构","date":"2022-08-26T08:30:29.000Z","updated":"2022-09-08T07:38:28.000Z","comments":true,"path":"2022/08/26/Go基本结构/","link":"","permalink":"http://peapod.top/2022/08/26/Go%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/","excerpt":"","text":"第四章（上）：基本结构文件名、关键字与标识符文件名均由小写字母组成，如 scanner.go 。如果文件名由多个部分组成，则使用下划线 _ 对它们进行分隔，scanner_test.go 。 有效的标识符必须以字母（可以使用任何 UTF-8 编码的字符或 _）开头。 _ 本身就是一个特殊的标识符，被称为空白标识符。 程序一般由关键字、常量、变量、运算符、类型和函数组成。 程序的基本结构和要素包、导入与可见性包是结构化代码的一种方式：每个程序都由包（通常简称为 pkg）的概念组成，可以使用自身的包或者从其它包中导入内容。 每个 Go 文件都属于且仅属于一个包。一个包可以由许多以 .go 为扩展名的源文件组成，因此文件名和包名一般来说都是不相同的。 package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。 所有的包名都应该使用小写字母。 属于同一个包的源文件必须全部被一起编译，一个包即是编译时的一个单元，因此根据惯例，每个目录都只包含一个包。 每一段代码只会被编译一次 导入包的方式 1234567891011import &quot;fmt&quot;import &quot;os&quot;import &quot;fmt&quot;;import &quot;os&quot;import ( &quot;fmt&quot; &quot;os&quot;)import (&quot;fmt&quot;;&quot;os&quot;) 可见性规则 当标识符以一个大写字母开头，就可以被外部包的代码所使用，这被称为导出；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用。 可以像面向对象语言那样使用点标记来调用：pack1.Thing 函数1func functionname() main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。 函数简短 1func Sum(a,b int) int &#123;return a+b&#125; 只有当某个函数需要被外部包调用的时候才使用大写字母开头。 注释注释不会被编译，但可以通过 godoc 来使用。 以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾 每一个包应该有相关注释，在 package 语句之前的块注释将被默认认为是这个包的文档说明。 几乎所有全局作用域的类型、常量、变量、函数和被导出的对象都应该有一个合理的注释。如果这种注释（称为文档注释）出现在函数前面，例如函数 Abcd，则要以 &quot;Abcd...&quot; 作为开头。 12345// enterOrbit causes Superman to fly into low Earth orbit, a position// that presents several possibilities for planet salvation.func enterOrbit() error &#123; ...&#125; 类型类型可以是基本类型，如：int、float、bool、string；结构化的（复合的），如：struct、array、slice、map、channel；只描述类型的行为的，如：interface。 结构化的类型没有真正的值，它使用 nil 作为默认值。Go 语言中不存在类型继承。 函数也可以是一个确定的类型，就是以函数作为返回类型。 一个函数可以拥有多返回值，返回类型之间需要使用逗号分割，并使用小括号 () 将它们括起来，如： 1func Functionname (a int,b int) (c int,d int) type 关键字可以定义你自己的类型，你可能想要定义一个结构体，但是也可以定义一个已经存在的类型的别名，如： 1type IZ int 并不是真正意义上的别名，使用这种方法定义之后的类型可以拥有更多的特性，且在类型转换时必须显式转换。 多个类型定义： 12345type ( IZ int FZ float64 STR string) 程序的一般结构 在完成包的 import 之后，开始对常量、变量和类型的定义或声明。 如果存在 init 函数的话，则对该函数进行定义。 如果当前包是 main 包，则定义 main 函数。 然后定义其余的函数，首先是类型的方法，接着是按照 main 函数中先后调用的顺序来定义相关函数。 123456789101112131415161718192021package mainimport ( &quot;fmt&quot;)const PI = 3.14var h float32 = 4type Yuan struct&#123; r float32&#125;func init()&#123;&#125;func main()&#123; y :=&amp;Yuan&#123;9&#125; Fun(y.mianji() * h)&#125;func (y Yuan) mianji() float32&#123; return PI * y.r * y.r&#125;func Fun(v float32)&#123; fmt.Printf(&quot;mianji%f&quot;,v)&#125; 类型转换 Go 语言不存在隐式类型转换，因此所有的转换都必须显式说明。 类型 B 的值 &#x3D; 类型 B(类型 A 的值) 12a := 5.0b := int(5.0)","categories":[{"name":"笔记","slug":"笔记","permalink":"http://peapod.top/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://peapod.top/tags/Go/"}],"author":"taweizhong"},{"title":"Go编辑与调试","slug":"Go编辑与调试","date":"2022-08-26T08:29:58.000Z","updated":"2024-02-27T10:57:09.724Z","comments":true,"path":"2022/08/26/Go编辑与调试/","link":"","permalink":"http://peapod.top/2022/08/26/Go%E7%BC%96%E8%BE%91%E4%B8%8E%E8%B0%83%E8%AF%95/","excerpt":"","text":"第三章：编辑与调试编辑器与调试器编辑器：**Sublime Text、LiteIDE、GoClipse** 调试器：可用的调试器是 gdb。 基本调试： 在合适的位置使用打印语句输出相关变量的值。 在 fmt.Printf 中使用下面的说明符 %+v 打印包括字段在内的实例的完整信息 %#v 打印包括字段和限定类型名称在内的实例的完整信息。 %T 打印某个类型的完整说明 构建格式化工具 gofmt 并保存格式化后的源文件。 构建应用程序： go build 编译自身包和依赖包。 go install 编译并安装自身包和依赖包。 格式化代码go fmt（gofmt）。这个工具可以将你的源代码格式化成符合官方统一标准的风格，属于语法风格层面上的小型重构。 gofmt –w program.go 会格式化该源文件的代码然后将格式化后的代码覆盖原始内容。 gofmt -w *.go 会格式化并重写所有 Go 源文件。 gofmt map1 会格式化并重写 map1 目录及其子目录下的所有 Go 源文件。。 gofmt 也可以通过在参数 -r 后面加入用双引号括起来的替换规则实现代码的简单重构，规则的格式：&lt;原始内容&gt; -&gt; &lt;替换内容&gt;。 1gofmt -r &#x27;(a) -&gt; a&#x27; -w *.go 生成代码文档go doc 工具会从 Go 程序和包文件中提取顶级声明的首行注释以及每个对象的相关注释，并生成相关文档。 一般用法 go doc package获取包的文档注释 go doc package/subpackage 获取子包的文档注释 go doc package function 获取某个函数在某个包中的文档注释","categories":[{"name":"笔记","slug":"笔记","permalink":"http://peapod.top/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://peapod.top/tags/Go/"}],"author":"taweizhong"},{"title":"Go安装与运行","slug":"Go安装与运行","date":"2022-08-26T08:29:40.000Z","updated":"2022-09-08T07:39:32.000Z","comments":true,"path":"2022/08/26/Go安装与运行/","link":"","permalink":"http://peapod.top/2022/08/26/Go%E5%AE%89%E8%A3%85%E4%B8%8E%E8%BF%90%E8%A1%8C/","excerpt":"","text":"第二章：安装与运行环境架构2个版本的编译器：Go 原生编译器 gc 和非原生编译器 gccgo，这两款编译器都是在类 Unix 系统下工作 。 Go从1.5版本开始已经实现自举。 Go 语言源文件的扩展名很显然就是 .go。 创建目录时，文件夹名称永远不应该包含空格，而应该使用下划线 “_” 或者其它一般符号代替。 环境变量 $GOROOT 表示 Go 在你的电脑上的安装位置 $GOARCH 表示目标机器的处理器架构 $GOBIN 表示编译器和链接器的安装位置 $GOPATH三个规定的目录：src、pkg 和 bin，这三个目录分别用于存放源码文件、包文件和可执行文件。 Go 编译器支持交叉编译，可以使用 $GOHOSTOS 和 $GOHOSTARCH 设置本地机器的操作系统名称和编译体系结构。 安装目录 /bin：包含可执行文件 /doc：包含示例程序，代码工具，本地文档等 /lib：包含文档模版 /src：包含源代码构建脚本和标准库的包的完整源代码 Go运行时（runtime）代码仍旧运行在 Go 的 runtime当中。似 Java 和 .NET 语言所用到的虚拟机，它负责管理包括内存分配、垃圾回收）、栈处理、goroutine、channel、切片（slice）、map 和反射（reflection）等等。 垃圾回收器Go 拥有简单却高效的标记-清除回收器。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://peapod.top/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://peapod.top/tags/Go/"}],"author":"taweizhong"},{"title":"Go起源与发展","slug":"Go起源与发展","date":"2022-08-26T08:29:16.000Z","updated":"2022-09-08T07:36:44.000Z","comments":true,"path":"2022/08/26/Go起源与发展/","link":"","permalink":"http://peapod.top/2022/08/26/Go%E8%B5%B7%E6%BA%90%E4%B8%8E%E5%8F%91%E5%B1%95/","excerpt":"","text":"第一章：起源于发展起源与发展Go 语言起源 2007 年，并于 2009 年正式对外发布。 时间轴： 2007 年 9 月 21 日：雏形设计 2009 年 11 月 10日：首次公开发布 2010 年 1 月 8 日：当选 2009 年年度语言 2010 年 5 月：谷歌投入使用 2011 年 5 月 5 日：Google App Engine 支持 Go 语言 主要特性发展目标：将静态语言的安全性和高效性与动态语言的易开发性进行有机结合。是对于网络通信、并发和并行编程的极佳支持，从而更好地利用大量的分布式和多核的计算机。 Go 语言是一门类型安全和内存安全的编程语言。虽然 Go 语言中仍有指针的存在，但并不允许进行指针运算。 重要的特性： 构建速度（编译和链接到机器代码的速度）快。 使用包模式的依赖管理更加的清晰。 执行速度快。 没有类和继承的概念，通过接口（interface）的概念来实现多态性。 使用静态类型，所以它是类型安全的一门语言。 强类型语言，隐式的类型转换是不被允许。 动态语言的特性（通过关键字 var）。 支持交叉编译。 LALR 是 Go 语言的语法标准。 Go语言的用途： 应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。 实现所谓的复杂事件处理（CEP）。 Go 语言不适合用来开发对实时性要求很高的软件。 通过 recover 和 panic 来替代异常机制","categories":[{"name":"笔记","slug":"笔记","permalink":"http://peapod.top/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://peapod.top/tags/Go/"}],"author":"taweizhong"},{"title":"Git入门指南","slug":"Git入门指南","date":"2022-08-25T14:06:50.000Z","updated":"2022-09-08T07:40:00.000Z","comments":true,"path":"2022/08/25/Git入门指南/","link":"","permalink":"http://peapod.top/2022/08/25/Git%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/","excerpt":"","text":"Git入门指南创建仓库1git init 添加12git add *git add &lt;file&gt; 提交1git commit -m &quot;提交信息&quot; 推送1git push origin master","categories":[{"name":"笔记","slug":"笔记","permalink":"http://peapod.top/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://peapod.top/tags/Git/"}],"author":"taweizhong"},{"title":"服务器部署","slug":"服务器部署","date":"2022-08-25T12:10:38.000Z","updated":"2022-09-06T13:39:44.000Z","comments":true,"path":"2022/08/25/服务器部署/","link":"","permalink":"http://peapod.top/2022/08/25/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"使用指南","slug":"使用指南","date":"2022-08-25T10:11:34.000Z","updated":"2022-09-08T07:35:42.000Z","comments":true,"path":"2022/08/25/使用指南/","link":"","permalink":"http://peapod.top/2022/08/25/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","excerpt":"","text":"说明front-matter配置 Key Type Description cover string 封面 layout stirng 页面类型(只有在page页面下生效) subtitle string 小标题&#x2F;描述(只有在page页面生效) toc boolean 是否开启TOC功能(只有在post页面下生效) aplayer boolean 是否启用aplayer播放器(只有在post,page页面下生效) dplayer boolean 是否启用dplayer播放器(只有在post,page页面下生效) tags string 标签（不适用于分页） categories string 分类（不适用于分页） 媒体使用方法image1234&#123;% image url=&quot;https://qiniu.sukoshi.xyz/src/images/68686407_p0.jpg&quot; title=&quot;带描述带图片&quot;%&#125; aplayer 12345678&#123;% aplayer url=&quot;https://qiniu.sukoshi.xyz/public/music/鹿乃 - アイロニ.mp3&quot; name=&quot;アイロニ&quot; artist=&quot;鹿乃&quot; cover=&quot;https://qiniu.sukoshi.xyz/public/music/鹿乃 - アイロニ.jpg&quot; lrc=&quot;https://qiniu.sukoshi.xyz/public/music/鹿乃 - アイロニ.lrc&quot; lrcType=&quot;3&quot;%&#125; dplayer 1234&#123;% dplayer url=&quot;https://qiniu.sukoshi.xyz/video/%E7%BE%8E.mp4&quot; pic=&quot;https://qiniu.sukoshi.xyz/video/%E7%BE%8E.mp4?vframe/jpg/offset/10&quot;%&#125;","categories":[],"tags":[{"name":"说明","slug":"说明","permalink":"http://peapod.top/tags/%E8%AF%B4%E6%98%8E/"}],"author":"taweizhong"},{"title":"","slug":"Go入门指南","date":"2022-08-14T04:24:34.000Z","updated":"2022-08-14T04:24:34.000Z","comments":true,"path":"2022/08/14/Go入门指南/","link":"","permalink":"http://peapod.top/2022/08/14/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/","excerpt":"","text":"第一部分：学习Go语言第一章：起源于发展起源与发展Go 语言起源 2007 年，并于 2009 年正式对外发布。 时间轴： 2007 年 9 月 21 日：雏形设计 2009 年 11 月 10日：首次公开发布 2010 年 1 月 8 日：当选 2009 年年度语言 2010 年 5 月：谷歌投入使用 2011 年 5 月 5 日：Google App Engine 支持 Go 语言 主要特性发展目标：将静态语言的安全性和高效性与动态语言的易开发性进行有机结合。是对于网络通信、并发和并行编程的极佳支持，从而更好地利用大量的分布式和多核的计算机。 Go 语言是一门类型安全和内存安全的编程语言。虽然 Go 语言中仍有指针的存在，但并不允许进行指针运算。 重要的特性： 构建速度（编译和链接到机器代码的速度）快。 使用包模式的依赖管理更加的清晰。 执行速度快。 没有类和继承的概念，通过接口（interface）的概念来实现多态性。 使用静态类型，所以它是类型安全的一门语言。 强类型语言，隐式的类型转换是不被允许。 动态语言的特性（通过关键字 var）。 支持交叉编译。 LALR 是 Go 语言的语法标准。 Go语言的用途： 应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。 实现所谓的复杂事件处理（CEP）。 Go 语言不适合用来开发对实时性要求很高的软件。 通过 recover 和 panic 来替代异常机制 第二章：安装与运行环境架构2个版本的编译器：Go 原生编译器 gc 和非原生编译器 gccgo，这两款编译器都是在类 Unix 系统下工作 。 Go从1.5版本开始已经实现自举。 Go 语言源文件的扩展名很显然就是 .go。 创建目录时，文件夹名称永远不应该包含空格，而应该使用下划线 “_” 或者其它一般符号代替。 环境变量 $GOROOT 表示 Go 在你的电脑上的安装位置 $GOARCH 表示目标机器的处理器架构 $GOBIN 表示编译器和链接器的安装位置 $GOPATH三个规定的目录：src、pkg 和 bin，这三个目录分别用于存放源码文件、包文件和可执行文件。 Go 编译器支持交叉编译，可以使用 $GOHOSTOS 和 $GOHOSTARCH 设置本地机器的操作系统名称和编译体系结构。 安装目录 /bin：包含可执行文件 /doc：包含示例程序，代码工具，本地文档等 /lib：包含文档模版 /src：包含源代码构建脚本和标准库的包的完整源代码 Go运行时（runtime）代码仍旧运行在 Go 的 runtime当中。似 Java 和 .NET 语言所用到的虚拟机，它负责管理包括内存分配、垃圾回收）、栈处理、goroutine、channel、切片（slice）、map 和反射（reflection）等等。 垃圾回收器Go 拥有简单却高效的标记-清除回收器。 第三章：编辑与调试编辑器与调试器编辑器：**Sublime Text、LiteIDE、GoClipse** 调试器：可用的调试器是 gdb。 基本调试： 在合适的位置使用打印语句输出相关变量的值。 在 fmt.Printf 中使用下面的说明符 %+v 打印包括字段在内的实例的完整信息 %#v 打印包括字段和限定类型名称在内的实例的完整信息。 %T 打印某个类型的完整说明 构建格式化工具 gofmt 并保存格式化后的源文件。 构建应用程序： go build 编译自身包和依赖包。 go install 编译并安装自身包和依赖包。 格式化代码go fmt（gofmt）。这个工具可以将你的源代码格式化成符合官方统一标准的风格，属于语法风格层面上的小型重构。 gofmt –w program.go 会格式化该源文件的代码然后将格式化后的代码覆盖原始内容。 gofmt -w *.go 会格式化并重写所有 Go 源文件。 gofmt map1 会格式化并重写 map1 目录及其子目录下的所有 Go 源文件。。 gofmt 也可以通过在参数 -r 后面加入用双引号括起来的替换规则实现代码的简单重构，规则的格式：&lt;原始内容&gt; -&gt; &lt;替换内容&gt;。 1gofmt -r &#x27;(a) -&gt; a&#x27; -w *.go 生成代码文档go doc 工具会从 Go 程序和包文件中提取顶级声明的首行注释以及每个对象的相关注释，并生成相关文档。 一般用法 go doc package获取包的文档注释 go doc package/subpackage 获取子包的文档注释 go doc package function 获取某个函数在某个包中的文档注释 第四章：基本结构和基本数据类型文件名、关键字与标识符文件名均由小写字母组成，如 scanner.go 。如果文件名由多个部分组成，则使用下划线 _ 对它们进行分隔，scanner_test.go 。 有效的标识符必须以字母（可以使用任何 UTF-8 编码的字符或 _）开头。 _ 本身就是一个特殊的标识符，被称为空白标识符。 程序一般由关键字、常量、变量、运算符、类型和函数组成。 程序的基本结构和要素包、导入与可见性包是结构化代码的一种方式：每个程序都由包（通常简称为 pkg）的概念组成，可以使用自身的包或者从其它包中导入内容。 每个 Go 文件都属于且仅属于一个包。一个包可以由许多以 .go 为扩展名的源文件组成，因此文件名和包名一般来说都是不相同的。 package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。 所有的包名都应该使用小写字母。 属于同一个包的源文件必须全部被一起编译，一个包即是编译时的一个单元，因此根据惯例，每个目录都只包含一个包。 每一段代码只会被编译一次 导入包的方式 1234567891011import &quot;fmt&quot;import &quot;os&quot;import &quot;fmt&quot;;import &quot;os&quot;import ( &quot;fmt&quot; &quot;os&quot;)import (&quot;fmt&quot;;&quot;os&quot;) 可见性规则 当标识符以一个大写字母开头，就可以被外部包的代码所使用，这被称为导出；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用。 可以像面向对象语言那样使用点标记来调用：pack1.Thing 函数1func functionname() main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。 函数简短 1func Sum(a,b int) int &#123;return a+b&#125; 只有当某个函数需要被外部包调用的时候才使用大写字母开头。 注释注释不会被编译，但可以通过 godoc 来使用。 以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾 每一个包应该有相关注释，在 package 语句之前的块注释将被默认认为是这个包的文档说明。 几乎所有全局作用域的类型、常量、变量、函数和被导出的对象都应该有一个合理的注释。如果这种注释（称为文档注释）出现在函数前面，例如函数 Abcd，则要以 &quot;Abcd...&quot; 作为开头。 12345// enterOrbit causes Superman to fly into low Earth orbit, a position// that presents several possibilities for planet salvation.func enterOrbit() error &#123; ...&#125; 类型类型可以是基本类型，如：int、float、bool、string；结构化的（复合的），如：struct、array、slice、map、channel；只描述类型的行为的，如：interface。 结构化的类型没有真正的值，它使用 nil 作为默认值。Go 语言中不存在类型继承。 函数也可以是一个确定的类型，就是以函数作为返回类型。 一个函数可以拥有多返回值，返回类型之间需要使用逗号分割，并使用小括号 () 将它们括起来，如： 1func Functionname (a int,b int) (c int,d int) type 关键字可以定义你自己的类型，你可能想要定义一个结构体，但是也可以定义一个已经存在的类型的别名，如： 1type IZ int 并不是真正意义上的别名，使用这种方法定义之后的类型可以拥有更多的特性，且在类型转换时必须显式转换。 多个类型定义： 12345type ( IZ int FZ float64 STR string) 程序的一般结构 在完成包的 import 之后，开始对常量、变量和类型的定义或声明。 如果存在 init 函数的话，则对该函数进行定义。 如果当前包是 main 包，则定义 main 函数。 然后定义其余的函数，首先是类型的方法，接着是按照 main 函数中先后调用的顺序来定义相关函数。 123456789101112131415161718192021package mainimport ( &quot;fmt&quot;)const PI = 3.14var h float32 = 4type Yuan struct&#123; r float32&#125;func init()&#123;&#125;func main()&#123; y :=&amp;Yuan&#123;9&#125; Fun(y.mianji() * h)&#125;func (y Yuan) mianji() float32&#123; return PI * y.r * y.r&#125;func Fun(v float32)&#123; fmt.Printf(&quot;mianji%f&quot;,v)&#125; 类型转换 Go 语言不存在隐式类型转换，因此所有的转换都必须显式说明。 类型 B 的值 &#x3D; 类型 B(类型 A 的值) 12a := 5.0b := int(5.0) 常量常量使用关键字 const 定义，用于存储不会改变的数据。 存储在常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。 1const Pi = 3.14 常量的值必须是能够在编译时就能够确定的。 因为在编译期间自定义函数均属于未知，因此无法用于常量的赋值，但内置函数可以使用，如：len()。 12const Ln2 = 0.693147180559945309417232121458\\ 176568075500134360255254120680009 反斜杠 \\ 可以在常量表达式中作为多行的连接符使用。 常量并行赋值 1const beef,two,c = &quot;eat&quot;,2,&quot;vag&quot; iota 可以被用作枚举值： 12345const ( a = iota b = iota c = iota) 简单地讲，每遇到一次 const 关键字，iota 就重置为 0。. 变量声明变量的一般形式是使用 var 关键字：var identifier type。 123456789var a intvar b boolvar str stringvar ( a int b bool str string) 变量的命名规则遵循骆驼命名法。 全局变量希望能够被外部包所使用，则需要将首个单词的首字母也大写。 变量可以编译期间就被赋值，赋值给变量使用运算符等号 =，可以在运行时对变量进行赋值操作。 12345var a intvar b boola = 15b = true 声明与赋值（初始化）语句也可以组合起来。 12var a int = 15var b bool = false 自动类型推断 12345678910var a = 15var b = falsevar ( a = 15 b = false str = &quot;Go says hello to the world!&quot; numShips = 50 city string) 在函数体内声明局部变量时，应使用简短声明语法 :=，例如： 1a := 1 实例： 123456789101112package mainimport ( &quot;fmt&quot; &quot;runtime&quot; &quot;os&quot;)func main ()&#123; goos := runtime.GOOS fmt.Printf(&quot;%s\\n&quot;,goos) var path string = os.Getenv(&quot;PATH&quot;) fmt.Printf(&quot;%s\\n&quot;,path)&#125; 值类型和引用类型 int、float、bool 和 string 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值。 数组和结构体这些复合类型是值类型。 指针、切片、映射和通道是引用类型。被引用的变量会存储在堆中，以便进行垃圾回收，且比栈拥有更大的内存空间。 函数 fmt.Sprintf 与 Printf 的作用是完全相同的，不过前者将格式化后的字符串以返回值的形式返回给调用者。 在相同的代码块中，我们不可以再次对于相同名称的变量使用初始化声明，例如：a := 20 就是不被允许的。 1a, b, c := 5, 7, &quot;abc&quot; 交换两个变量的值，则可以简单地使用 a, b = b, a。 init函数 变量除了可以在全局声明中初始化，也可以在 init 函数中初始化。 每个源文件都只能包含一个 init 函数。初始化总是以单线程执行，并且按照包的依赖关系顺序执行。 用途是在开始执行程序之前对数据进行检验或修复，以保证程序状态的正确性。 123456package transimport &quot;math&quot;var Pi float64func init()&#123; Pi = 4*math.Atan(1)&#125; 123456789package mainimport ( &quot;fmt&quot; &quot;./trans&quot;)var twoPi = 2*trams.Pifunc main()&#123; fmt.Printf(twoPi)&#125; init 函数也经常被用在当一个程序开始之前调用后台执行的 goroutine。 1234func init() &#123; // setup preparations go backend()&#125; 基本类型与运算符bool类型只有两个类型相同的值才可以进行比较，如果值的类型是接口，它们也必须都实现了相同的接口。 布尔型的常量和变量也可以通过和逻辑运算符（非 !、和 &amp;&amp;、或 ||）结合来产生另外一个布尔值。 ！非运算符用于取得和布尔值相反的结果。 &amp;&amp;两边的值都为 true 的时候，结果才是 true。 ||两边的值都为 false 的时候，结果才是 false。 在格式化输出时，你可以使用 %t 来表示你要输出的值为布尔型。 数字类型Go 语言支持整型和浮点型数字，并且原生支持复数，其中位的运算采用补码。 Go 也有基于架构的类型，例如：int、uint 和 uintptr。 这些类型的长度都是根据运行程序所在的操作系统类型所决定的： int 和 uint 在 32 位操作系统上，它们均使用 32 位（4 个字节），在 64 位操作系统上，它们均使用 64 位（8 个字节）。 uintptr 的长度被设定为足够存放一个指针即可。 Go 语言中没有 float 类型。（Go语言中只有 float32 和 float64）没有double类型。 int 型是计算最快的一种类型。 float32 精确到小数点后 7 位，float64 精确到小数点后 15 位。 尽可能地使用 float64，因为 math 包中所有有关数学运算的函数都会要求接收这个类型。 前缀 0 来表示 8 进制数（如：077），增加前缀 0x 来表示 16 进制数（如：0xFF），以及使用 e 来表示 10 的连乘（如： 1e3 &#x3D; 1000，或者 6.022e23 &#x3D; 6.022 x 1e23）。 可以使用 a := uint64(0) 来同时完成类型转换和赋值操作，这样 a 的类型就是 uint64。 Go 中不允许不同类型之间的混合使用，但是对于常量的类型限制非常少，因此允许常量之间的混合使用： 12345678package mainfunc main()&#123; var a int var b int32 a = 15 b = a+a //编译错误 b = b+5 //5是常量，可以编译&#125; 格式化说明符 %d 用于格式化整数（%x 和 %X 用于格式化 16 进制表示的数字），%g 用于格式化浮点型（%f 输出浮点数，%e 输出科学计数表示法），%0nd 用于规定输出长度为n的整数，其中开头的数字 0 是必须的。 %n.mg 用于表示数字 n 并精确到小数点后 m 位，除了使用 g 之外，还可以使用 e 或者 f，例如：使用格式化字符串 %5.2e 来输出 3.4 的结果为 3.40e+00。 / 对于整数运算而言，结果依旧为整数，例如：9 / 4 -&gt; 2。 取余运算符只能作用于整数：9 % 4 -&gt; 1。 对于整数和浮点数，你可以使用一元运算符 ++（递增）和 --（递减），但只能用于后缀。 ++ 和 -- 的只能作为语句，而非表达式，因此 n = i++ 这种写法是无效的。 随机数 rand 包实现了伪随机数的生成。 123456789101112131415161718192021package mainimport ( &quot;fmt&quot; &quot;math/rand&quot; &quot;time&quot;)func main()&#123; for i:=0; i&lt;5; i++&#123; a := rand.Int() fmt.Printf(&quot;%d\\n&quot;,r) &#125; for i := 0; i &lt; 5; i++ &#123; r := rand.Intn(8) fmt.Printf(&quot;%d / &quot;, r) &#125; times := int64(time.Now().Nanosecond()) rand.Seed(times) for i := 0; i &lt; 10; i++ &#123; fmt.Printf(&quot;%2.2f / &quot;, 100*rand.Float32()) &#125;&#125; 函数 rand.Intn 返回介于 [0, n) 之间的伪随机数。 类型别名在 type TZ int 中，TZ 就是 int 类型的新名称（用于表示程序中的时区），然后就可以使用 TZ 来操作 int 类型的数据。 新类型不会拥有原类型所附带的方法。 字符类型byte 类型是 uint8 的别名。 Go 同样支持 Unicode（UTF-8），因此字符同样称为 Unicode 代码点或者 runes，并在内存中使用 int 来表示。 rune 也是 Go 当中的一个类型，并且是 int32 的别名。 1var ch byte = 65 或 var ch byte = &#x27;\\x41&#x27; var ch byte = &#39;A&#39;；字符使用单引号括起来。 Unicode 至少占用 2 个字节，所以我们使用 int16 或者 int 类型来表示。如果需要使用到 4 字节，则会加上 \\U 前缀；前缀 \\u 则总是紧跟着长度为 4 的 16 进制数，前缀 \\U 紧跟着长度为 8 的 16 进制数。 123456789101112var ch int = &#x27;\\u0041&#x27;var ch2 int = &#x27;\\u03B2&#x27;var ch3 int = &#x27;\\U00101234&#x27;fmt.Printf(&quot;%d - %d - %d\\n&quot;, ch, ch2, ch3) // integerfmt.Printf(&quot;%c - %c - %c\\n&quot;, ch, ch2, ch3) // characterfmt.Printf(&quot;%X - %X - %X\\n&quot;, ch, ch2, ch3) // UTF-8 bytesfmt.Printf(&quot;%U - %U - %U&quot;, ch, ch2, ch3) // UTF-8 code point65 - 946 - 1053236A - β - r41 - 3B2 - 101234U+0041 - U+03B2 - U+101234 判断是否为字母：unicode.IsLetter(ch) 判断是否为数字：unicode.IsDigit(ch) 判断是否为空白符号：unicode.IsSpace(ch) 包 utf8 拥有更多与 rune 类型相关的函数。 字符串字符串是一种值类型，且值不可变，字符串是字节的定长数组。 Go 中的字符串是根据长度限定，而非特殊字符\\0。 函数 len() 来获取字符串所占的字节长度。 在循环中使用加号 + 拼接字符串并不是最高效的做法，更好的办法是使用函数 strings.Join()。 使用字节缓冲（bytes.Buffer）拼接更加给力。 strings和strconv包Go 中使用 strings 包来完成对字符串的主要操作。 12345678910111213141516171819202122232425262728293031strings.HasPrefix(s, prefix string) bool// 判断字符串 s 是否以 prefix 开头strings.HasSuffix(s, suffix string) bool// 判断字符串 s 是否以 suffix 结尾strings.Contains(s, substr string) bool// 判断字符串 s 是否包含 substrstrings.Index(s, str string) int// Index 返回字符串 str 在字符串 s 中的索引strings.LastIndex(s, str string) int// LastIndex 返回字符串 str 在字符串 s 中最后出现位置的索引strings.IndexRune(s string, r rune) int// 非 ASCII 编码的字符在父字符串中的位置strings.Replace(str, old, new, n) string// Replace 用于将字符串 str 中的前 n 个字符串 old 替换为字符串 new，并返回一个新的字符串，如果 n = -1 则替换所有字符串 old 为字符串 newstrings.Count(s, str string) int// Count 用于计算字符串 str 在字符串 s 中出现的非重叠次数strings.Repeat(s, count int) string// Repeat 用于重复 count 次字符串 s 并返回一个新的字符串strings.TrimSpace(s) 来剔除字符串开头和结尾的空白符号；如果你想要剔除指定字符，则可以使用 strings.Trim(s, &quot;cut&quot;) 来将开头和结尾的 cut 去除掉。strings.Split(s, sep) 用于自定义分割符号来对指定字符串进行分割，同样返回 slice。strings.Join(sl []string, sep string) string// Join 用于将元素类型为 string 的 slice 使用分割符号来拼接组成一个字符串 与字符串相关的类型转换都是通过 strconv 包实现的。 12345678910strconv.Itoa(i int) string// 返回数字 i 所表示的字符串类型的十进制数。strconv.FormatFloat(f float64, fmt byte, prec int, bitSize int) string // 将 64 位浮点型的数字转换为字符串strconv.Atoi(s string) (i int, err error) // 将字符串转换为 int 型。strconv.ParseFloat(s string, bitSize int) (f float64, err error) // 将字符串转换为 float64 型。 第五章：控制结构if-else结构12345if condition &#123; //&#125; else &#123; //&#125; 当 if 结构内有 break、continue、goto 或者 return 语句时，Go 代码的常见写法是省略 else 部分 1234if condition &#123; return x&#125;return y 1234if err != nil &#123; fmt.Printf(&quot;Program stopping with error %v&quot;, err) os.Exit(1)&#125; swith结构它可以接受任意形式的表达式： 12345678switch var1 &#123; case val1: ... case val2: ... default: ...&#125; 变量 var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值。 一旦成功地匹配到某个分支，在执行完相应代码后就会退出整个 switch 代码块。 继续执行后续分支的代码，可以使用 fallthrough 关键字 12345switch i &#123; case 0: fallthrough case 1: f() // 当 i == 0 时函数也会被调用&#125; 可选的 default 分支可以出现在任何顺序，但最好将它放在最后。它的作用类似与 if-else 语句中的 else，表示不符合任何已给出条件时，执行相关语句。 switch 语句的第二种形式是不提供任何被判断的值（实际上默认为判断是否为 true），然后在每个 case 分支中进行测试不同的条件。 12345678switch &#123; case i &lt; 0: f1() case i == 0: f2() case i &gt; 0: f3()&#125; for结构基于计数器的迭代 1234567package mainimport &quot;fmt&quot;func main() &#123; for i := 0; i &lt; 5; i++ &#123; fmt.Printf(&quot;This is the %d iteration\\n&quot;, i) &#125;&#125; 基于条件判断的迭代 123456789package mainimport &quot;fmt&quot;func main() &#123; var i int = 5 for i &gt;= 0 &#123; i = i - 1 fmt.Printf(&quot;The variable i is now: %d\\n&quot;, i) &#125;&#125; for-range结构 for ix, val := range coll &#123; &#125;。 val 始终为集合中对应索引的值拷贝，因此它一般只具有只读性质，对它所做的任何修改都不会影响到集合中原有的值 123for pos, char := range str &#123;...&#125; 标签和gotofor、switch 或 select 语句都可以配合标签（label）形式的标识符使用，即某一行第一个以冒号（:） 12345678910111213package mainimport &quot;fmt&quot;func main() &#123;LABEL1: // 一般建议使用全部大写字母 for i := 0; i &lt;= 5; i++ &#123; for j := 0; j &lt;= 5; j++ &#123; if j == 4 &#123; continue LABEL1 &#125; fmt.Printf(&quot;i is: %d, and j is: %d\\n&quot;, i, j) &#125; &#125;&#125; 第六章：函数简介函数是基本的代码块。函数编写的顺序是无关紧要的，最好把 main() 函数写在文件的前面。 简单的 return 语句也可以用来结束 for 死循环，或者结束一个协程（goroutine）。 Go里面的函数： 普通函数 匿名函数 方法 除了main()、init()函数外，其它所有类型的函数都可以有参数与返回值。 函数参数、返回值以及它们的类型被统称为函数签名。 函数是一等值（first-class value）：它们可以赋值给变量，就像 add := binOp 一样。 函数不能在其它函数里面声明（不能嵌套），不过我们可以通过使用匿名函数 函数参数与返回值函数定义时，它的形参一般是有名字的，不过我们也可以定义没有形参名的函数，只有相应的形参类型，就像这样：func f(int, int, float64)。 在函数调用时，像切片（slice）、字典（map）、接口（interface）、通道（channel）这样的引用类型都是默认使用引用传递（即使没有显式的指出指针）。 命名返回值 命名返回值作为结果形参（result parameters）被初始化为相应类型的零值，当需要返回的时候，我们只需要一条简单的不带参数的return语句。 123456func getX2AndX3_2(input int) (x2 int, x3 int) &#123; x2 = 2 * input x3 = 3 * input // return x2, x3 return&#125; 改变外部变量 传递指针给函数不但可以节省内存（因为没有复制变量的值），而且赋予了函数直接修改外部变量的能力，所以被修改的变量不再需要使用 return 返回。 1234567891011121314package mainimport ( &quot;fmt&quot;)// this function changes reply:func Multiply(a, b int, reply *int) &#123; *reply = a * b&#125;func main() &#123; n := 0 reply := &amp;n Multiply(10, 5, reply) fmt.Println(&quot;Multiply:&quot;, *reply) // Multiply: 50&#125; 变长参数函数的最后一个参数是采用 ...type 的形式，那么这个函数就可以处理一个变长的参数 123456789101112131415161718192021package mainimport &quot;fmt&quot;func main() &#123; x := min(1, 3, 2, 0) fmt.Printf(&quot;The minimum is: %d\\n&quot;, x) slice := []int&#123;7,9,3,5,1&#125; x = min(slice...) fmt.Printf(&quot;The minimum in the slice is: %d&quot;, x)&#125;func min(s ...int) int &#123; if len(s)==0 &#123; return 0 &#125; min := s[0] for _, v := range s &#123; if v &lt; min &#123; min = v &#125; &#125; return min&#125; 变长参数的类型不相同 使用结构体 使用空接口 使用默认的空接口 interface&#123;&#125;，这样就可以接受任何类型的参数 new 和 make 均是用于分配内存：new 用于值类型和用户定义的类型，如自定义结构，make 用于内置引用类型（切片、map 和管道）。 new(T) 分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针 make(T) 返回类型 T 的初始化之后的值，因此它比 new 进行更多的工作。 defer和追踪关键字 defer 允许我们推迟到函数返回之前（或任意位置执行 return 语句之后）一刻才执行某个语句或函数。 123456789101112package mainimport &quot;fmt&quot;func P()&#123; fmt.Print(&quot;P&quot;)&#125;func main()&#123; fmt.Print(&quot;111&quot;) defer P() fmt.Print(&quot;222&quot;)&#125; 当有多个 defer 行为被注册时，它们会以逆序执行 123456789101112package mianimport ( &quot;file&quot;)func main()&#123; //关闭文件 defer file.close() //解锁 mu.Lock() defer mu.Unlock() //关闭数据库连接 defer disconnectFromDB()&#125; 函数作为参数1234567891011package mainimport &quot;fmt&quot;func add(i,j int) int &#123; return i+j&#125;func b(c int, f func (i,j int) int )&#123; return f(c, 2)&#125;func main()&#123; fmt.Print(b(1, add))&#125; 闭包匿名函数的使用 12345678910package mainimport &quot;fmt&quot;func main ()&#123; // 匿名函数 func(i, j int) int &#123;return i+j&#125; // 将匿名函数赋值给变量 变量使用匿名函数 ter := func(i, j int) int &#123;return i+j&#125; ter(2,3) // 匿名函数直接的调用 func(a, b int) int &#123;return a-b&#125; (3, 2)&#125; 函数作为返回值123456789101112package mainimport &quot;fmt&quot;func add(j int) func (i int) int&#123; return func (i int) int&#123; return j +i &#125;&#125;func main()&#123; add(12)&#125; 12345678910111213141516171819package mainimport &quot;fmt&quot;func add() func(i int) int &#123; var x int fmt.Printf(&quot;x: %v\\n&quot;, x) return func(i int) int &#123; x += i return x &#125;&#125;func main() &#123; f := add() fmt.Printf(&quot;f(1): %v\\n&quot;, f(1)) fmt.Printf(&quot;f(2): %v\\n&quot;, f(20))&#125; 闭包函数保存并积累其中的变量的值，不管外部函数退出与否，它都能够继续操作外部函数中的局部变量。 计算函数的执行时间12345678910111213141516171819package mainimport ( &quot;fmt&quot; &quot;time&quot;)func add() &#123; for i := 0; i &lt; 100; i++ &#123; fmt.Printf(&quot;i: %v\\n&quot;, i) &#125;&#125;func main() &#123; start := time.Now() add() end := time.Now() fmt.Print(end.Sub(start))&#125; 第七章：数组与切片数组12345678package mainimport &quot;fmt&quot;func main()&#123; var a [10]int //声明 for i := 0; i&lt;10 ; i++ &#123; fmt.Print(a[i]) &#125;&#125; 数组是 可变的。 Go 语言中的数组是一种 值类型，所以可以通过 new() 来创建： 123a := new([10]int)var b = new([10]int)var c [10]int b的类型是*[10]int, c的类型是[10]int。 初始化 1234567package mainimport &quot;fmt&quot;func main()&#123; var a = [10]int&#123;1,2,3,4&#125; var b = [...]int&#123;5,6,7,8&#125; var c = [10]string&#123;1:&quot;ta&quot;, 2:&quot;wei&quot;&#125; // key: value 语法&#125; 切片切片（slice）是对数组一个连续片段的引用，所以切片是一个引用类型。切片是一个 长度可变的数组。 切片是可索引的，并且可以由 len() 函数获取长度。计算容量的函数 cap() 可以测量切片最长可以达到多少。 123456package mainimport &quot;fmt&quot;func main()&#123; var a []int // 不需要说明长度 var b = []int&#123;1,2,3,4,5&#125; // 初始化&#125; make创建数组 123456package mainimport &quot;fmt&quot;func main()&#123; var a []int = make([]int, 10) b := make([]int, 10)&#125; 1.slice、map以及channel都是golang内建的一种引用类型，三者在内存中存在多个组成部分， 需要对内存组成部分初始化后才能使用，而make就是对三者进行初始化的一种操作方式 2. new 获取的是存储指定变量内存地址的一个变量，对于变量内部结构并不会执行相应的初始化操作， 所以slice、map、channel需要make进行初始化并获取对应的内存地址，而非new简单的获取内存地址","categories":[],"tags":[]}],"categories":[{"name":"笔记","slug":"笔记","permalink":"http://peapod.top/categories/%E7%AC%94%E8%AE%B0/"},{"name":"golang标准库","slug":"golang标准库","permalink":"http://peapod.top/categories/golang%E6%A0%87%E5%87%86%E5%BA%93/"},{"name":"每日一库","slug":"每日一库","permalink":"http://peapod.top/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%BA%93/"},{"name":"云原生","slug":"云原生","permalink":"http://peapod.top/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"},{"name":"Web前端","slug":"Web前端","permalink":"http://peapod.top/categories/Web%E5%89%8D%E7%AB%AF/"},{"name":"区块链","slug":"区块链","permalink":"http://peapod.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"分布式系统","slug":"分布式系统","permalink":"http://peapod.top/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"},{"name":"实用","slug":"实用","permalink":"http://peapod.top/categories/%E5%AE%9E%E7%94%A8/"},{"name":"Web","slug":"Web","permalink":"http://peapod.top/categories/Web/"},{"name":"说明","slug":"说明","permalink":"http://peapod.top/categories/%E8%AF%B4%E6%98%8E/"},{"name":"前端","slug":"前端","permalink":"http://peapod.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://peapod.top/tags/blog/"},{"name":"笔记","slug":"笔记","permalink":"http://peapod.top/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Go","slug":"Go","permalink":"http://peapod.top/tags/Go/"},{"name":"python","slug":"python","permalink":"http://peapod.top/tags/python/"},{"name":"微服务框架","slug":"微服务框架","permalink":"http://peapod.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/"},{"name":"标准库","slug":"标准库","permalink":"http://peapod.top/tags/%E6%A0%87%E5%87%86%E5%BA%93/"},{"name":"微服务","slug":"微服务","permalink":"http://peapod.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"GRPC","slug":"GRPC","permalink":"http://peapod.top/tags/GRPC/"},{"name":"测试","slug":"测试","permalink":"http://peapod.top/tags/%E6%B5%8B%E8%AF%95/"},{"name":"Vue3","slug":"Vue3","permalink":"http://peapod.top/tags/Vue3/"},{"name":"javascript","slug":"javascript","permalink":"http://peapod.top/tags/javascript/"},{"name":"Git","slug":"Git","permalink":"http://peapod.top/tags/Git/"},{"name":"Hyperledger Fabric进阶","slug":"Hyperledger-Fabric进阶","permalink":"http://peapod.top/tags/Hyperledger-Fabric%E8%BF%9B%E9%98%B6/"},{"name":"JSON","slug":"JSON","permalink":"http://peapod.top/tags/JSON/"},{"name":"Hyperledger Fabric","slug":"Hyperledger-Fabric","permalink":"http://peapod.top/tags/Hyperledger-Fabric/"},{"name":"clash","slug":"clash","permalink":"http://peapod.top/tags/clash/"},{"name":"beego","slug":"beego","permalink":"http://peapod.top/tags/beego/"},{"name":"说明","slug":"说明","permalink":"http://peapod.top/tags/%E8%AF%B4%E6%98%8E/"},{"name":"Gin","slug":"Gin","permalink":"http://peapod.top/tags/Gin/"},{"name":"css","slug":"css","permalink":"http://peapod.top/tags/css/"},{"name":"vim","slug":"vim","permalink":"http://peapod.top/tags/vim/"},{"name":"HTML","slug":"HTML","permalink":"http://peapod.top/tags/HTML/"}]}